<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.1.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.1.1" type="image/png" sizes="32x32"><meta name="description" content="Aaron的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Welcome">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Welcome">
<meta property="og:description" content="Aaron的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Aaron 沈思源">
<meta name="twitter:card" content="summary"><title>Welcome</title><link ref="canonical" href="http://example.com/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.1.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Welcome</div><div class="header-banner-info__subtitle">Aaron的个人博客</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/09/24/#16%20%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-09-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-06-24</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h4 id="16-最接近的三数之和"   >
          <a href="#16-最接近的三数之和" class="heading-link"><i class="fas fa-link"></i></a>16. 最接近的三数之和</h4>
      <p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) </span><br></pre></td></tr></table></div></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 10^3</code></li>
<li><code>-10^3 &lt;= nums[i] &lt;= 10^3</code></li>
<li><code>-10^4 &lt;= target &lt;= 10^4</code></li>
</ul>
<p><strong>常规思路:</strong></p>
<p>由于是一个普通的数组，如果不进行数据处理的话只能直接遍历，使用三重循环遍历所有情况，时间复杂度是$$O(n^3)$$，这显然是不符合要求的。</p>
<p><strong>优化:</strong></p>
<p>可以先对数组进行递增排序处理，用一个指针$$pointA$$遍历从$$a=nums[0]$$开始遍历整个数组，另外用两个双指针，分别指向后一个元素$$b=nums[pointA+1]$$和数组最后一个元素$$c=nums[nums.length-1]$$,求解三数之和$$tmpSum=a+b+c$$，初始化：</p>
<p>​                                                      $$pointB=pointA+1\qquad pointC=nums.length$$</p>
<p>随后，还要当前$$pointA$$的情况下的$$pointB,pointC$$进行移动，<strong>策略如下:</strong></p>
<p><strong>要求:$$pointB&lt;pointC$$</strong></p>
<ol>
<li><p>$$tmpSum\equiv target$$</p>
<p>说明已经找到一个完全符合目标的解了，直接返回<code>target</code></p>
</li>
<li><p>$$tmpSum&lt;target$$</p>
<p>右移<code>pointB</code>，直到当前$$nums[pointB]&gt;nums[pointB_{原}]$$，且不越界</p>
</li>
<li><p>$$tmpSum&gt;target$$</p>
<p>左移<code>pointC</code>，直到当前$$nums[pointC]&lt;nums[pointC_{原}]$$，且不越界</p>
</li>
</ol>
<p>(由于数组由小到大排序).</p>
<p>设置一个初始答案为一个不可能的极大值$$ans=0X3f3f3f3f$$，每次计算出一个$$tmpSum$$后，根据判断条件:</p>
<p>​                                                     $$|tmpSum-target|&lt;|target-ans|$$                   $$(1)$$</p>
<p>那么说明现在的答案更优秀，更新$$ans$$.</p>
<p>当目前的$$pointA$$情况下的$$pointB,pointC$$的情况遍历完，$$pointA$$右移，继续遍历即可。直到返回一个值。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0x3f3f3f3f</span>;<span class="comment">// a+b+c closest to target</span></span><br><span class="line">        <span class="keyword">int</span> pointA=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pointB=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pointC=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//枚举a</span></span><br><span class="line">        <span class="keyword">for</span>(;pointA&lt;nums.length;pointA++)&#123;</span><br><span class="line">            <span class="comment">//保证a每次的枚举的元素不相等</span></span><br><span class="line">            <span class="keyword">if</span>(pointA&gt;<span class="number">0</span>&amp;&amp;nums[pointA]==nums[pointA-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            pointB=pointA+<span class="number">1</span>;</span><br><span class="line">            pointC=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//双指针pointA,pointB枚举b,c</span></span><br><span class="line">            <span class="keyword">while</span>(pointB&lt;pointC)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmpSum=nums[pointA]+nums[pointB]+nums[pointC];</span><br><span class="line">                <span class="keyword">if</span>(tmpSum==target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(Math.abs(target-tmpSum)&lt;Math.abs(target-ans))&#123;</span><br><span class="line">                        ans=tmpSum;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(tmpSum&lt;target)&#123;</span><br><span class="line">                        pointB++;</span><br><span class="line">                        <span class="keyword">while</span>(pointB&lt;nums.length&amp;&amp;nums[pointB]==nums[pointB-<span class="number">1</span>])&#123;</span><br><span class="line">                            pointB++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        pointC--;</span><br><span class="line">                        <span class="keyword">while</span>(pointC&gt;=<span class="number">0</span>&amp;&amp;nums[pointC]==nums[pointC+<span class="number">1</span>])&#123;</span><br><span class="line">                            pointC--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<p><strong>思路2：递归</strong></p>
<p>解法与迭代过程类似，将迭代转换为递归的过程</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/09/24/#35%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-09-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-07-17</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h4 id="35-搜索插入位置"   >
          <a href="#35-搜索插入位置" class="heading-link"><i class="fas fa-link"></i></a>35. 搜索插入位置</h4>
      <p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></div></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></div></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></div></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></div></figure>

<p><strong>二分查找</strong></p>
<p>以$$left=0,right=nums.length-1$$为起始查找边界，以$$mid+1/mid-1$$为边界移动方案，以$$left\leq right$$为循环查找条件</p>
<p>如果一个数字在数组中查不到，如果它是过于小，那么应该返回0，二分查找的$$right$$会不断左移，直至$$left=right=0$$，最终$$right=-1$$跳出循环，应该返回$$left$$即可</p>
<p>如果是过于大，应该返回$$nums.length$$，二分查找的$$left$$会不断右移，直至$$left=right=nums.length-1$$，最终$$left=nums.length$$跳出循环，也可以直接返回$$left$$</p>
<p>如果是在数组中间某处，但是没有这个数字，最终移动状态必定是$$left=right=mid$$，其中$$nums[mid]$$必是小于这个数的最大数或者大于这个数的最小数。</p>
<p>如果是情况1：</p>
<p>则$$left=mid+1$$，这时$$left$$也正是数要插入的位置</p>
<p>如果是请看2：</p>
<p>则$$right=mid-1$$，$$left$$也是要插入的位置</p>
<p>所以返回$$left$$是正确的</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target==nums[mid])</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;nums[mid])</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/09/24/#32%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-09-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-07-04</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h4 id="32-最长有效括号"   >
          <a href="#32-最长有效括号" class="heading-link"><i class="fas fa-link"></i></a>32. 最长有效括号</h4>
      <p>给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(()&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串为 &quot;()&quot;</span><br></pre></td></tr></table></div></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;)()())&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长有效括号子串为 &quot;()()&quot;</span><br></pre></td></tr></table></div></figure>

<p><strong>栈</strong></p>
<p>用栈保存<code>(</code>，当有一个<code>)</code>时，从栈中弹出一个<code>(</code>进行配对，如果时一个可以完全匹配的有效括号，则匹配完时栈刚好是空的。而且每个有效括号串的结尾字符必定是<code>)</code>。用栈来求串中每个<code>)</code>结尾的最长有效括号长度，由于以此<code>)</code>结尾不一定完全匹配，长度可能是0。</p>
<p>比如对于串<code>()())()</code>，答案应该是4，基本操作有：</p>
<ol>
<li>扫描指针指向<code>(</code>，将当前<code>(</code>序号入栈</li>
<li>扫描指针指向<code>)</code>，栈中弹出一个元素，配对，计算当前的<code>)</code>最长有效括号长度，当前指针是1，弹出0，要求的答案是2，计算式待定。            <strong>？：1-(-1)=2，栈顶-1</strong></li>
<li>入栈序号2</li>
<li>出栈，当前序号3，要求的答案是4，计算式待定     <strong>？：3-(-1)=4，栈顶-1</strong></li>
<li>指向<code>)</code>，序号4，答案应该是0，            <strong>?：出栈-1，栈空，入栈4，4-4=0</strong></li>
<li>指向<code>(</code>，序号5，入栈</li>
<li>指向<code>)</code>，序号6，出栈5，答案应该2               <strong>?：6-4=2，栈顶4</strong></li>
</ol>
<p>可以发现，如果把第<strong>5</strong>步扫描的、栈中没有<code>(</code>配对的<code>)</code>序号4压栈，那么<strong>7</strong>步的答案就可以由当前序号6和当前栈顶元素4相减得到。</p>
<p>可以先在栈中放入一个初始元素-1，当遇到<code>(</code>时入栈，遇到<code>)</code>时先出栈一个元素，检查栈是否为空，若为空了则把当前<code>)</code>的序号压栈，并将当前<code>)</code>的有效串长度赋为0。若不是空，则把有效串长度赋值为：</p>
<p>​                                                            $$tmpLength=pointNow-stack.peek()$$</p>
<p><strong>由于栈中预留一个元素，第一次遇到 ) 时栈至少有一个元素，若出栈，为空则又会压栈当前序号，所以出栈操作时栈不会为空</strong></p>
<p><strong>java</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque &lt;Integer&gt;stack =<span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        stack.addLast(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">char</span>[]datas=s.toCharArray();</span><br><span class="line">        <span class="comment">//char element;</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,tmpans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;datas.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(datas[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                stack.addLast(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                    stack.addLast(i);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    stack.pollLast();</span><br><span class="line">                    <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                        stack.addLast(i);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        tmpans=i-stack.peekLast();</span><br><span class="line">                        ans=Math.max(ans,tmpans);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>动态规划</strong></p>
<p>求解以串中每个元素结尾的最长有效串长度，刷新最大值。</p>
<p>$$DP[i]$$表示以$$s[i]$$结尾的有效串中的最长串长度。显然：</p>
<p>$$DP[0]=0$$</p>
<p>$$DP[i]=0\qquad s[i]\equiv’(‘$$</p>
<p>对于每个$$DP[i]\quad s[i]\equiv’)’$$，则进行以下讨论：</p>
<p><strong>1：</strong>$$i=0$$</p>
<p>​    此时是$$DP[0]=0$$</p>
<p><strong>2：</strong>$$s[i-1]\equiv ‘(‘$$</p>
<p>​    此时结尾是<code>()</code>，因此结尾的<code>(</code>直接与其前一个字符配对，则转移方程为：<br>$$<br>\begin{cases}<br>DP[i]=2\qquad i\equiv1\<br>\<br>DP[i]=DP[i-2]+2\qquad i\geq2<br>\end{cases}<br>$$<br><strong>3：</strong>$$s[i-1]\equiv’)’$$</p>
<p>​    此时结尾是<code>))</code>,因此结尾字符的前一个字符也对应了一个最大有效串长度，要检查前一个字符结尾的最大有效串$$s’$$的开头字符的前一个字符是否是<code>(</code>，这样才能与当前末尾的<code>)</code>进行完整配对。如果配对不成功，则当前的<code>)</code>不能够形成有效串。如果成功，则有效串长度为</p>
<p>​                                     $$DP[i-1]+2+(s’的开头字符的第二个更前面的字符结尾的有效串长度)$$</p>
<p>不考虑数组越界的情况下，标准形式为</p>
<p>​                                    $$DP[i]=DP[i-1]+2+DP[i-DP[i-1]-2]$$</p>
<p>如果$$i-DP[i-1]-2&lt;0$$，说明前面没有有效串，方程退化为</p>
<p>​                                   $$DP[i]=DP[i-1]+2$$</p>
<p><strong>C</strong></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;=b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *DP=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(length));</span><br><span class="line">    DP[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;<span class="comment">// 结尾为(</span></span><br><span class="line">            DP[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">&#x27;(&#x27;</span>)&#123;   <span class="comment">//结尾为()</span></span><br><span class="line">                DP[i]=(i&gt;=<span class="number">2</span>?DP[i<span class="number">-2</span>]:<span class="number">0</span>)+<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//结尾为))</span></span><br><span class="line">                <span class="keyword">if</span>(i-DP[i<span class="number">-1</span>]<span class="number">-1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i-DP[i<span class="number">-1</span>]<span class="number">-1</span>]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i-DP[i<span class="number">-1</span>]<span class="number">-1</span><span class="number">-1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                            DP[i]=DP[i-DP[i<span class="number">-1</span>]<span class="number">-1</span><span class="number">-1</span>]+DP[i<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            DP[i]=<span class="number">0</span>+DP[i<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;<span class="comment">//以此结尾不可能完全匹配</span></span><br><span class="line">                        DP[i]=<span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    DP[i]=<span class="number">0</span>;<span class="comment">//以为结尾不可能完全匹配</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf(&quot;%d &quot;,DP[i]);</span></span><br><span class="line">        ans=max(ans,DP[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>





</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/09/24/#4%20%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-09-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-10</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h4 id="4-寻找两个正序数组的中位数"   >
          <a href="#4-寻找两个正序数组的中位数" class="heading-link"><i class="fas fa-link"></i></a>4. 寻找两个正序数组的中位数</h4>
      <p>给定两个大小为 m 和 n 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。</p>
<p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 $$O(log(m + n))$$。</p>
<p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 &#x3D; [1, 3]</span><br><span class="line">nums2 &#x3D; [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></div></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 &#x3D; [1, 2]</span><br><span class="line">nums2 &#x3D; [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)&#x2F;2 &#x3D; 2.5</span><br></pre></td></tr></table></div></figure>

<p>本题的难点在于如何设计一个时间复杂度仅为$$O(log_2(m+n))$$的算法来找到这个中位数，同时还要对每种边界情况进行合适的处理。</p>
<p>由于复杂度要求是$$log_2$$型，可以考虑二分法，先假设最简单的常规情况如下:</p>
<p><img src="assets/image-20200623202938068.png" alt="image-20200623202938068"></p>
<p>一共有17个元素，按照物理序号，则中位数是第$$17/2=8,Nums[8]$$元素，可以考虑用两个指针分别初始指向$$nums1[],nums2[]$$的首元素，然后指针分别尝试向后移动，分别指向自己的第$$8/2=4$$个元素(逻辑序号)；比较这两个数字的大小(这里是$$nums1[3],nums2[3]$$);其中更小的一个将自己的指针再后移一个，并”删除”掉前面的$$8/2=4$$个元素，另一个指针则回退回移动尝试前的位置，再进行<strong>下一轮比较</strong>。</p>
<p><strong>证明：上述过程删除的元素必全比要找的第k个数小</strong></p>
<p><img src="assets/image-20200623203816587.png" alt="image-20200623203816587"></p>
<p>这里删除的$$k/2$$个元素，若比要寻找的第k个数小，则等价于删除数序列最大的数(这里是$$4$$)，比第k个数小，则又等价于已知的比删除数序列最大的数大的数个数$$Length_{r}$$，要满足关系:</p>
<p>​                                                             $$Length_r\geq n-(k-1)=n-k+1$$</p>
<p><img src="assets/image-20200623204115009.png" alt="image-20200623204115009"></p>
<p>根据图1，可以知道，$$nums2[]$$的指针在比较时尝试指向的元素12及之后的元素必大于等于$$nums1[]$$指针指向的元素4的，所以目前可以确定的大于等于待删除数序列(长度$$k/2 $$)中最大的数4的元素个数是:</p>
<p>​                                       $$Length_r=(length_1-k/2)+[length_2-(k/2-1)]=n-\lfloor \frac{k}{2}\rfloor\cdot2+1$$    </p>
<p>而显然有:</p>
<p>​                                                                    $$n-\lfloor \frac{k}{2}\rfloor\cdot2+1\geq n-k+1$$</p>
<p>所以删除的数字必全在要寻找的第$$target=k$$个数的左边</p>
<p><strong>继续迭代：</strong></p>
<p>删除了$$\lfloor \frac{k}{2}\rfloor$$个数，剩下的序列中，要找第k个数就成了第$$target=k-\lfloor \frac{k}{2}\rfloor=k_2$$个数，继续删除$$\lfloor \frac{k_2}{2}\rfloor$$个数，则要找的数还在剩下的两个数组中。直到$$\lfloor \frac{k_n}{2}\rfloor=0$$,统计目前已经删除的数的个数，要找的第$$target$$数的下标就成了：</p>
<p>​                                                            $$target_{now}=target-\sum DeleteNums$$</p>
<p>如果$$target_{now}\equiv0$$，说明已经删除完毕，当前两个数组的指针指向的数中更小的一个(也就是剩下的所有数字中最小的一个)就是要找的数(因为是第0个)，如果中位数是两个数求平均，再找第二小的一个即可。</p>
<p>否则，则建立一个临时数组$$tmparray[\quad]$$，为了方便求解中位数平均的情况，$$tmparray[\quad]$$要存放到$$Remain[target_{now}+1]$$，因此长度是$$target_{now}+2$$,从两个指针处开始不断比较取当前最小的元素存入$$tmparray[\quad]$$数组，直到元素个数足够。</p>
<p><strong>特殊情况：</strong></p>
<p>其中一个数组可能出现元素越界的情况，<strong>在指针移动时，当前尝试移动量越过了数组的边界</strong>，此时指针保持不变，仅移动另一个数组的指针。那么结果会有两种情况:</p>
<ol>
<li>删除的元素在另一个数组中，正确执行，另一个数组的指针移动，本数组指针仍然保持不变，进入下一个尝试</li>
<li>删除的元素在本数组中，<strong>说明本数组所有元素都小于中位数，</strong>数组指针移动至<code>nums.length</code>，表明越界，用本数组能够删除的元素个数更新$$target$$,退出尝试循环，直接在另一个数组中从指针处开始查找$$nums[target],nums[target+1]$$</li>
</ol>
<p>如果一个数组为空，直接在另一个数组中根据中位数序号和数组长度寻找即可.</p>
<p><strong>起始：</strong></p>
<p>$$(1):\qquad L=(length_1+length_2)%2\equiv0 $$</p>
<p>总共偶数个元素，按照物理序号，则$$Nums[\frac{L}{2}-1],Nums[\frac{L}{2}]$$为寻找的数，可以设$$target=k=(\frac{L}{2}-1)$$</p>
<p>找到后再往后找一个，求平均.</p>
<p>$$(2):\qquad L=(length_1+length_2)%2\equiv1 $$</p>
<p>总共奇数个元素，按照物理序号，则$$Nums[\lfloor \frac{L}{2}\rfloor]$$为寻找的数，设$$target=k=\lfloor \frac{L}{2}\rfloor$$即为所求.</p>
<p><strong>java:</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums2.length%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> (nums2[nums2.length/<span class="number">2</span>]+nums2[nums2.length/<span class="number">2</span>-<span class="number">1</span>])/<span class="number">2.0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[nums2.length/<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums2.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1.length%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> (nums1[nums1.length/<span class="number">2</span>]+nums1[nums1.length/<span class="number">2</span>-<span class="number">1</span>])/<span class="number">2.0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[nums1.length/<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> odd_or_even;<span class="comment">//true-&gt;odd,false-&gt;even</span></span><br><span class="line">        <span class="keyword">if</span>((nums1.length+nums2.length)%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            odd_or_even=<span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            odd_or_even=<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> point1=<span class="number">0</span>,point2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=(nums1.length+nums2.length)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(!odd_or_even)</span><br><span class="line">            mid=mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> target=mid;</span><br><span class="line">        <span class="comment">//We need to find NUMS[mid]</span></span><br><span class="line">        <span class="keyword">int</span> tmp=target/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> tmppoint1,tmppoint2;</span><br><span class="line">        <span class="keyword">while</span>(tmp&gt;<span class="number">0</span>&amp;&amp;point1&lt;nums1.length&amp;&amp;point2&lt;nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(point1+tmp-<span class="number">1</span>&lt;nums1.length)&#123;</span><br><span class="line">                tmppoint1=point1+tmp-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmppoint1=point1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(point2+tmp-<span class="number">1</span>&lt;nums2.length)&#123;</span><br><span class="line">                tmppoint2=point2+tmp-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmppoint2=point2;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums1[tmppoint1]&lt;=nums2[tmppoint2])&#123;</span><br><span class="line">                target=target-(tmppoint1+<span class="number">1</span>-point1);</span><br><span class="line">                point1=tmppoint1+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                target=target-(tmppoint2+<span class="number">1</span>-point2);</span><br><span class="line">                point2=tmppoint2+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp=target/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//boolean NoOverflow=false;</span></span><br><span class="line">        <span class="keyword">int</span> tmpresult[]=<span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(point1&gt;=nums1.length)&#123;</span><br><span class="line">            tmpresult[<span class="number">0</span>]=nums2[point2+target];</span><br><span class="line">            tmpresult[<span class="number">1</span>]=nums2[point2+target+<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(point2&gt;=nums2.length)&#123;</span><br><span class="line">            tmpresult[<span class="number">0</span>]=nums1[point1+target];</span><br><span class="line">            tmpresult[<span class="number">1</span>]=nums1[point1+target+<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> tmparray[]=<span class="keyword">new</span> <span class="keyword">int</span> [target+<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;target+<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(point1&lt;nums1.length&amp;&amp;point2&lt;nums2.length)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums1[point1]&lt;=nums2[point2])&#123;</span><br><span class="line">                        tmparray[j]=nums1[point1];</span><br><span class="line">                        point1++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        tmparray[j]=nums2[point2];</span><br><span class="line">                        point2++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(point1&lt;nums1.length)&#123;</span><br><span class="line">                    tmparray[j]=nums1[point1];</span><br><span class="line">                    point1++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tmparray[j]=nums2[point2];</span><br><span class="line">                    point2++;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; </span><br><span class="line">            tmpresult[<span class="number">0</span>]=tmparray[target];</span><br><span class="line">            tmpresult[<span class="number">1</span>]=tmparray[target+<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//NoOverflow=true;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(odd_or_even)&#123;<span class="comment">//odd</span></span><br><span class="line">            <span class="keyword">return</span> Math.min(tmpresult[<span class="number">0</span>],tmpresult[<span class="number">1</span>]);      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//even</span></span><br><span class="line">            <span class="keyword">return</span> (tmpresult[<span class="number">0</span>]+tmpresult[<span class="number">1</span>])/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/09/24/#5%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-09-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-06-26</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h4 id="5-最长回文子串"   >
          <a href="#5-最长回文子串" class="heading-link"><i class="fas fa-link"></i></a>5. 最长回文子串</h4>
      <p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></div></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></div></figure>

<p><strong>动态规划：</strong></p>

        <h3 id="1-设计历史记录数组"   >
          <a href="#1-设计历史记录数组" class="heading-link"><i class="fas fa-link"></i></a>1 设计历史记录数组</h3>
      <p>本题由于答案的结构是一个字符串，有开头和结尾字母，而且对其均没有要求，所以考虑历史记录用一个二维数组表示，$$DP[i][j]$$用来表示子字符串$$S[i….j]$$是否是一个回文串。</p>
<p>那么答案就可以设置两个角标$$ansLeft、ansRight$$,用来存储最终答案字符串的起始和结尾字母。每当程序发现一个$$DP[i][j]$$是$$true$$时，检查是否有$$(ansRight-ansLeft)&lt;(j-i)$$，如果有，那么更新$$ansLeft、ansRight$$</p>

        <h3 id="2-查找历史记录数组的常规情况下的关系式"   >
          <a href="#2-查找历史记录数组的常规情况下的关系式" class="heading-link"><i class="fas fa-link"></i></a>2 查找历史记录数组的常规情况下的关系式</h3>
      <p>常规情况下，与$$DP[i][j]$$有关的数组元素，应该与其有一个简单的计算关系式。由于是问题是一个回文字符串的判断，那么明显，$$(DP[i+1][j-1]==true) \wedge (S[i]==S[j])$$，才有$$DP[i][j]=true$$</p>
<p>​                                             $$DP[i][j]=(DP[i+1][j-1]==true) \wedge (S[i]==S[j])$$                        $$(1)$$</p>

        <h3 id="3-初始值和特殊情况"   >
          <a href="#3-初始值和特殊情况" class="heading-link"><i class="fas fa-link"></i></a>3 初始值和特殊情况</h3>
      <p>由于常规情况要求$$j-1\geq i+1$$,所以字符串只有两个字母或者一个字母的情况要特殊考虑</p>
<p>一个字母的情况，肯定是回文串：</p>
<p>​                                                                             $$DP[i][i]=true$$</p>
<p>两个字母的情况，两个字母要相等：</p>
<p>​                                                           $$DP[i][j]=(S[i]==S[j])\qquad j=i+1$$</p>
<p> <strong>代码实现：</strong></p>
<p>注意到$$(1)$$中的递推关系式对于一个$$(i,j)$$，要求知道$$(i+1,j-1)$$，对于$$DP[\quad][\quad]$$矩阵，要求知道下一行的前一列的元素，所以第一层循环不能是以行$$i$$开始，因为这样会导致不完全知道矩阵下一行的情况</p>
<p>先将矩阵对角线的元素$$DP[i][i]$$置为$$true$$，再将所有$$DP[i][j+1]$$计算出来，得到一个右上三角矩阵的部分情况：<br>$$<br>\begin{bmatrix}<br>true&amp;?&amp;…\<br>&amp;true&amp;?&amp;…\<br>&amp;&amp;true&amp;?&amp;…\<br>&amp;&amp;&amp;true&amp;?\<br>&amp;&amp;&amp;&amp;true\</p>
<p>\end{bmatrix}<br>$$<br>所以，按照列来对行进行遍历，可以满足$$(1)$$对历史记录的数据要求</p>
<p><strong>java</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>||s.length()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">boolean</span> DP[][]=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">        <span class="keyword">int</span> ansLeft=<span class="number">0</span>,ansRight=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">            DP[i][i]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-i==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                        DP[i][j]=<span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span>(ansRight-ansLeft&lt;<span class="number">1</span>)&#123;</span><br><span class="line">                            ansLeft=i;</span><br><span class="line">                            ansRight=j;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        DP[i][j]=<span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(DP[i+<span class="number">1</span>][j-<span class="number">1</span>]&amp;&amp;(s.charAt(i)==s.charAt(j)))&#123;</span><br><span class="line">                        DP[i][j]=<span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span>(ansRight-ansLeft&lt;j-i)&#123;</span><br><span class="line">                            ansRight=j;</span><br><span class="line">                            ansLeft=i;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        DP[i][j]=<span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(ansLeft,ansRight+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/09/24/#63%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-09-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-07-06</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h4 id="63-不同路径-II"   >
          <a href="#63-不同路径-II" class="heading-link"><i class="fas fa-link"></i></a>63. 不同路径 II</h4>
      <p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><img src="assets/robot_maze.png" alt="img"></p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<p><strong>说明：</strong>   <em>m</em>和 <em>n</em> 的值均不超过 100。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出: 2</span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></div></figure>

<p><strong>动态规划</strong></p>
<p>设备忘录数组$$DP[\quad][\quad]$$，$$DP[i][j]$$表示从起点到达网格坐标$$(i,j)$$的路径数量。于是有状态转移方程:<br>$$<br>\begin{cases}<br>DP[i][j]=0\qquad obstacleGrid[i][j]\equiv 1\<br>\<br>DP[i][j]=DP[i-1][j]+DP[i][j-1]\qquad obstacleGrid[i][j]\equiv0<br>\end{cases}<br>$$<br>对于第一行和第一列，则直接进行初始化：</p>
<p>对于第一行$$DP[0][j]$$，当$$\forall j’&lt;j ,obstacleGrid[0][j]\equiv 0$$时，$$DP[0][j]=1$$,否则往后$$DP[0][j]$$均为0</p>
<p>第一列初始化同理</p>
<p><strong>java</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> m=obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> DP[][]=<span class="keyword">new</span> <span class="keyword">int</span> [n][m];</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n&amp;&amp;obstacleGrid[i][<span class="number">0</span>]!=<span class="number">1</span>)&#123;</span><br><span class="line">            DP[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m&amp;&amp;obstacleGrid[<span class="number">0</span>][i]!=<span class="number">1</span>)&#123;</span><br><span class="line">            DP[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)</span><br><span class="line">                    DP[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    DP[i][j]=DP[i-<span class="number">1</span>][j]+DP[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DP[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>由于每个坐标$$(i,j)$$最多只需要坐标$$(i-1,j),(i,j-1)$$的数据，因此不需要保留所有的历史记录。</p>
<p>每次只保留当前行的坐标的$$DP$$数据，下一行的第一列的数据可以直接得到，第二列开始的数据可以根据保留的上一行历史记录和前一列的由上一行对应列历史记录计算出的数据得到。也就是计算$$DP[j]$$时，$$DP[(0)-(j-1)]$$存的是本行的这些列的数据，而$$DP[(j)-(m)]$$保存着上一行对应列的数据</p>
<p><strong>java</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> m=obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> DP[]=<span class="keyword">new</span> <span class="keyword">int</span> [m];</span><br><span class="line">        <span class="comment">//起点时候有障碍</span></span><br><span class="line">        DP[<span class="number">0</span>]=obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//到达 当前i行的j列的坐标位置 的 路径个数</span></span><br><span class="line">                    DP[j]=<span class="number">0</span>;</span><br><span class="line">                <span class="comment">//本坐标不是障碍物,可到达</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;obstacleGrid[i][j-<span class="number">1</span>]==<span class="number">0</span>)&#123;<span class="comment">//不为最左列且本坐标左一个坐标可到达</span></span><br><span class="line">                    DP[j]+=DP[j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DP[m-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/09/24/#42%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-09-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-06-22</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h4 id="42-接雨水"   >
          <a href="#42-接雨水" class="heading-link"><i class="fas fa-link"></i></a>42. 接雨水</h4>
      <p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src="assets/rainwatertrap.png" alt="img"></p>
<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 <strong>感谢 Marcos</strong> 贡献此图。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></div></figure>

<p>单调栈的典型题目，难点在于如何控制进栈和出栈的策略。</p>
<p>很明显，对所有接水区域的划分可以用一下策略：两个接水柱子<code>Left</code>和<code>Right</code>之间的柱子高度<code>h</code>有:                </p>
<p>​                                                                    $$h&lt; min(Left,Right)$$</p>
<p>因此设置一个存储柱子序号的栈，初始将序号<code>0</code>入栈，</p>
<p><strong>进栈的策略是：</strong></p>
<p>如果：                                                     $$height[stack(top)]&gt;h_{now}$$                             $$(1)$$</p>
<p>则$$h_{now}$$对应的序号$$i$$入栈.</p>
<p><strong>出栈的策略是:</strong></p>
<p>当有:                                                       $$height[stack(top)]\leq h_{now}$$                              $$(2)$$</p>
<p>则启动<strong>出栈程序</strong>.</p>
<p><strong>出栈程序:</strong></p>
<p>为了不重不漏的方便计算,出栈策略会复杂一些:</p>
<p>当前如果满足$$(2)$$时，直接出栈一个元素，并且定义变量<code>tmpHeight</code> $$=height[stack(top)]$$;</p>
<p>此后，如果有：</p>
<p>​                                                          $$height[stack(top)]\equiv tmpHeight$$</p>
<p>则继续出栈，直到第一个和<code>tmpHeight</code>高度不同的栈顶元素，而根据<strong>进栈策略</strong>，可以证明，栈内元素序号对应的柱子高度是<strong>严格单调递减</strong>的，则此时栈顶的元素必有:</p>
<p>​                                                         $$height[stack(top)]&gt;tmpHeight$$</p>
<p>此时，求解一个水平层(长方形)的蓄水量。(设当前指针指向的序号是<code>i</code>，$$h_{now}=height[i]$$)</p>
<p>​                    $$Sum+={min(height[stack(top)],height[i])-tmpHeight}\times (i-stack(top)-1)$$</p>
<p>此时一个小于等于$$h_{now}\equiv height[i]$$的$$tmpHeight$$作为底，往左向第一个高于$$tmpHeight$$的柱子作为左边界的蓄水区的蓄水量。</p>
<p>如果此时这个高于$$tmpHeight$$的柱子高度$$height[stack(top)]$$满足条件$$(1)$$，则当前的$$i$$进栈，进入<strong>进栈程序</strong>；否则满足条件$$(2)$$，继续执行出栈程序。</p>
<p>最终的结果就是$$\sum sum$$</p>
<p><strong>C语言代码：</strong></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a&lt;=b)?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>* height, <span class="keyword">int</span> heightSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> volume=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> stacktop_height=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">stack</span>=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*heightSize);</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;heightSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(top!=<span class="number">-1</span>&amp;&amp;height[i]&gt;height[<span class="built_in">stack</span>[top]])</span><br><span class="line">        &#123;</span><br><span class="line">            stacktop_height=height[<span class="built_in">stack</span>[top]];</span><br><span class="line">            <span class="keyword">while</span>(top!=<span class="number">-1</span>&amp;&amp;height[<span class="built_in">stack</span>[top]]==stacktop_height)</span><br><span class="line">                top--;</span><br><span class="line">            <span class="keyword">if</span>(top==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                top++;</span><br><span class="line">                <span class="built_in">stack</span>[top]=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp=(min(height[i],height[<span class="built_in">stack</span>[top]])-stacktop_height) *(i-<span class="built_in">stack</span>[top]<span class="number">-1</span>);</span><br><span class="line">                volume+=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        <span class="built_in">stack</span>[top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> volume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>java代码：</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt;stack=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stack.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;height.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i]&lt;height[stack.getLast()])&#123;</span><br><span class="line">                    stack.addLast(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;height[i]&gt;=height[stack.getLast()])&#123;</span><br><span class="line">                    <span class="keyword">int</span> tmpHeight=height[stack.pollLast()];</span><br><span class="line">                </span><br><span class="line">                    <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;height[stack.getLast()]==tmpHeight)&#123;</span><br><span class="line">                        stack.pollLast();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                        <span class="keyword">int</span> edge=Math.min(height[i],height[stack.getLast()]);</span><br><span class="line">                        sum+=(edge-tmpHeight)*(i-stack.getLast()-<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.addLast(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/09/24/#44%20%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-09-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-13</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h4 id="44-通配符匹配"   >
          <a href="#44-通配符匹配" class="heading-link"><i class="fas fa-link"></i></a>44. 通配符匹配</h4>
      <p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>&#39;?&#39;</code> 和 <code>&#39;*&#39;</code> 的通配符匹配。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;?&#39; 可以匹配任何单个字符。</span><br><span class="line">&#39;*&#39; 可以匹配任意字符串（包括空字符串）。</span><br></pre></td></tr></table></div></figure>

<p>两个字符串<strong>完全匹配</strong>才算匹配成功。</p>
<p><strong>说明:</strong></p>
<ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>?</code> 和 <code>*</code>。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></div></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &#39;*&#39; 可以匹配任意字符串。</span><br></pre></td></tr></table></div></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;cb&quot;</span><br><span class="line">p &#x3D; &quot;?a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &#39;?&#39; 可以匹配 &#39;c&#39;, 但第二个 &#39;a&#39; 无法匹配 &#39;b&#39;。</span><br></pre></td></tr></table></div></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;adceb&quot;</span><br><span class="line">p &#x3D; &quot;*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 第一个 &#39;*&#39; 可以匹配空字符串, 第二个 &#39;*&#39; 可以匹配字符串 &quot;dce&quot;.</span><br></pre></td></tr></table></div></figure>

<p><strong>示例 5:</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;acdcb&quot;</span><br><span class="line">p &#x3D; &quot;a*c?b&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></div></figure>


        <h3 id="贪心"   >
          <a href="#贪心" class="heading-link"><i class="fas fa-link"></i></a>贪心</h3>
      <p>多个连续**<strong><em>和一个**</em></strong>是等价的.</p>
<p>将p串调整为首尾均是<code>*</code>的字符串*** u1 * u2 * u3… * <strong>，即字符串u(u可以为空)和<em>交替出现，并且首末位字符是**</em></strong>。</p>
<p>事实上，只要能够保证首末是**<strong><em>，那么p串肯定能写成</em></strong> u1 * u2 * u3… * **</p>
<p>那么只要贪心的从s串中依次找到<strong>u</strong>，就肯定能够匹配成功，因为贪心是从最短的串里找到<strong>u</strong>，留下的串长度最长，最可能实现匹配的策略，如果不贪心能够成功，贪心肯定能够成功。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">charMatch</span><span class="params">(<span class="keyword">char</span> s,<span class="keyword">char</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="string">&#x27;?&#x27;</span>||s==p)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isallStars</span><span class="params">(String str, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s,String p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sRightpointer=s.length(),pRightponiter=p.length();</span><br><span class="line">        <span class="comment">//从p末尾开始匹配,直到第一个&#x27;*&#x27;</span></span><br><span class="line">        <span class="keyword">while</span>(sRightpointer&gt;<span class="number">0</span>&amp;&amp;pRightponiter&gt;<span class="number">0</span>&amp;&amp;p.charAt(pRightponiter-<span class="number">1</span>)!=<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(charMatch(s.charAt(sRightpointer-<span class="number">1</span>),p.charAt(pRightponiter-<span class="number">1</span>)))&#123;</span><br><span class="line">                pRightponiter--;</span><br><span class="line">                sRightpointer--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="comment">//末尾的非&#x27;*&#x27;匹配失败,无法匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pRightponiter==<span class="number">0</span>)&#123;<span class="comment">//若p串已经匹配完,s也匹配完则正确,否则不可匹配</span></span><br><span class="line">            <span class="keyword">return</span> sRightpointer==<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p串当前末尾是&#x27;*&#x27;</span></span><br><span class="line">        <span class="keyword">int</span> sIndex = <span class="number">0</span>, pIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sRecord = -<span class="number">1</span>, pRecord = -<span class="number">1</span>;<span class="comment">//记录当前正在匹配的u的首字母位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sIndex &lt; sRightpointer &amp;&amp; pIndex &lt; pRightponiter) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(pIndex) == <span class="string">&#x27;*&#x27;</span>) &#123;<span class="comment">//跳过所有&#x27;*&#x27;</span></span><br><span class="line">                pIndex++;</span><br><span class="line">                pRecord = pIndex;</span><br><span class="line">                sRecord = sIndex;<span class="comment">//刷新匹配的位置</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (charMatch(s.charAt(sIndex), p.charAt(pIndex))) &#123;</span><br><span class="line">                sIndex++;</span><br><span class="line">                pIndex++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sRecord != -<span class="number">1</span> &amp;&amp; sRecord + <span class="number">1</span> &lt; sRightpointer) &#123;<span class="comment">//当前非*首字母无法匹配,且已经有匹配成功的段(包括*)</span></span><br><span class="line">                sRecord++;</span><br><span class="line">                sIndex = sRecord;</span><br><span class="line">                pIndex = pRecord;<span class="comment">//用*匹配掉s当前字母,从下一个s字母重新开始匹配当前u串</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//当前非*首字母无法匹配,还未开始匹配,直接错误</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isallStars(p, pIndex, pRightponiter);</span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/09/24/#41%20%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-09-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-06-27</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h4 id="41-缺失的第一个正数"   >
          <a href="#41-缺失的第一个正数" class="heading-link"><i class="fas fa-link"></i></a>41. 缺失的第一个正数</h4>
      <p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,0]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></div></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,-1,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></div></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,8,9,11,12]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></div></figure>



<p><strong>提示：</strong></p>
<p>你的算法的时间复杂度应为$$O(n)$$，并且只能使用<strong>常数</strong>级别的额外空间。</p>

        <h3 id="思路："   >
          <a href="#思路：" class="heading-link"><i class="fas fa-link"></i></a>思路：</h3>
      <p>算法复杂度只能为$$O(n)$$，那么循环操作最多只能够对数组进行常数次的遍历操作，额外存储空间为常数级别，那么不能创建新的哈希表。因此必须考虑<strong>自哈希</strong>方法。</p>
<p><strong>问题特点：</strong></p>
<p>假设整数数组$$nums[\quad]$$，元素个数为$$nums.length$$，那么其中没有出现的最小的正整数最大值肯定是从$$1$$开始的每个正整数$$nums[\quad]$$中都有对应数字，而$$nums[\quad]$$显然最多能连续表达到的最大数字是$$nums.length$$，即数组元素组成的集合是$$[1,nums.length]$$，此时其中没有出现的最小的正整数是所有情况中的最大值                                                                         $$ans_{max}=nums.length+1$$，</p>
<p>其他情况下，问题的答案必定在$$[1,nums.length]$$中，所以问题答案的范围是:</p>
<p>​                                                                         $$ans\in[1,nums.length+1]$$</p>
<p>如果$$nums[\quad]$$ 数组中$$[1,nums.length]$$每个元素都出现了，才有$$ans=nums.length+1$$，否则$$ans$$是$$[1,nums.length]$$在$$nums[\quad]$$中没有出现的最小数。</p>
<p><strong>自哈希：</strong></p>
<p>暂时不考虑空间复杂度限制，遍历一遍数组，如果$$nums[i]\in[1,nums.length]$$，那么用一个类似$$bool$$型的数组$$exist[\quad]$$进行标记，表示数字$$nums[i]$$已经存在，即：</p>
<p>​                                                                         $$exist[nums[i]]=true$$</p>
<p>当遍历完后，从$$exist[1]$$开始遍历标记数组，找到第一个$$exist[j]=false$$，这个$$j$$就是我们要找的数字。</p>
<p>下面考虑如何用$$nums[\quad]$$本身来表示$$exist[\quad]$$以满足空间复杂度要求。</p>
<p>如果$$nums[i]\in[1,nums.length]$$，由于$$nums[\quad]$$角标从$$0$$开始，因此可以对$$nums[nums[i]-1]$$进行一个标记，表示$$nums[i]$$这个数字已经出现，而且这个标记又不能对原来的$$nums[nums[i]-1]$$表示的数据造成不可逆的破坏。</p>
<p>对于$$true/false$$表示的是否已经出现，可以用数字的正负来表示，将原数据置负，且原数据如果是正数可以通过绝对值来进行恢复。</p>
<ol>
<li><p>$$nums[i]\leq0$$</p>
<p>这个元素对于问题答案没有影响</p>
</li>
<li><p>$$nums[i]\geq nums.length+1$$</p>
<p>同样没有影响，把满足这样条件的数组元素删去，答案不变。因为只要存在$$1\leq nums[j]&lt;nums[i]$$,这个数据就没有影响了，如果全体$$nums[j]\geq nums[i]$$,那么答案是1</p>
</li>
</ol>
<p>将所有$$nums[i]\leq 0$$的值改变为$$nums.length+1$$，对答案没有影响，且为正数，表示未标记(false)。</p>
<p>对$$nums[\quad]$$进行遍历，得到每个元素绝对值，当有$$1\leq |nums[i]|\leq nums.length$$时，进行置负(标记为true)：    </p>
<p>​                                                       $$nums[|nums[i]|-1]=-(nums[|nums[i]|-1])$$</p>
<p>遍历，找到第一个$$nums[j]&gt;0$$，由于标记操作是$$|nums[i]|-1$$，所以表示数字$$j+1$$是最小的在数组中没有出现的正整数。</p>
<p><strong>java</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length=nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                nums[i]=length+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmpnums=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            tmpnums=Math.abs(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(tmpnums&lt;=length)&#123;</span><br><span class="line">                nums[tmpnums-<span class="number">1</span>]=-Math.abs(nums[tmpnums-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/09/24/HowtoUseGit/">Git教程</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2020-09-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2020-09-24</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>参考资料：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/896043488029600" >https://www.liaoxuefeng.com/wiki/896043488029600</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></div><div class="post-readmore"><a class="post-readmore__link" href="/2020/09/24/HowtoUseGit/"><span class="post-readmore__text">阅读全文</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://s1.ax1x.com/2020/09/24/0SnK1g.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">Hello world!</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/Waldenth" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="waldenth@outlook.com" target="_blank" rel="noopener" data-popover="social.outlook" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fas fa-mail-bulk"></i></span></a><a class="sidebar-ov-social-item" href="ywcz0817" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="3218606649" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">13</div><div class="sidebar-ov-state-item__name">归档</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Aaron 沈思源</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.1.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.1.1"></script><script src="/js/stun-boot.js?v=2.1.1"></script><script src="/js/scroll.js?v=2.1.1"></script><script src="/js/header.js?v=2.1.1"></script><script src="/js/sidebar.js?v=2.1.1"></script></body></html>