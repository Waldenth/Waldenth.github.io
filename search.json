[{"title":"LeetCode-139-单词拆分","url":"/2020/09/27/LeetCode-139/","content":"\n### [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)\n\n\n\n给定一个**非空**字符串 *s* 和一个包含**非空**单词列表的字典 *wordDict*，判定 *s* 是否可以被空格拆分为一个或多个在字典中出现的单词。\n\n这是一个行内数学公式：$\\begin{vmatrix} a & b \\\\ c & d \\end{vmatrix}$\n\n这个数学公式会换行显示：\n$$\\begin{vmatrix} a & b \\\\ c & d \\end{vmatrix}$$\n\n**说明：**\n\n- 拆分时可以重复使用字典中的单词。\n- 你可以假设字典中没有重复的单词。\n<!-- more -->\n\n#### example\n\n**示例 1：**\n\n```\n输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n输出: true\n解释: 返回 true 因为 \"leetcode\" 可以被拆分成 \"leet code\"。\n```\n\n**示例 2：**\n\n```\n输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\n输出: true\n解释: 返回 true 因为 \"applepenapple\" 可以被拆分成 \"apple pen apple\"。\n     注意你可以重复使用字典中的单词。\n```\n\n**示例 3：**\n\n```\n输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n输出: false\n```\n#### Dynamic Programming\n\n**思路：动态规划**\n\n要判断的字符串s长度是$$s.length()$$，假设字符串是`ABC`,可以划分的方案有:\n\n1. `[NULL],[ABC]`\n2. `[A],[BC]`\n3. `[AB],[C]`\n\n一共有$s.length()$种划分方案，分别判断每种划分方案产生的子字符串时候都满足可由字典匹配的要求，如果某种划分方案的两个子字符串都可以被匹配，说明原字符串可以被匹配。\n\n对于划分的左部分字符串，可以在划分原字符串的左边一部分时就得知，用数组$$DP[\\quad]$$来存储已经知道的左部字符串能否匹配的信息。也就是：\n\n​                                                       $$DP[i]:\\quad表示字符串s[0...i-1]能否被字典所匹配$$\n\n那么对于$$j>i$$，$$DP[j]$$就可以表示成：\n\n​\t\t                                              $$DP[j]=(DP[i])\\&\\&(s[i...j-1]是否可被匹配)$$\n\n对$$0\\leq i<j$$的所有$$i$$进行枚举，计算可能的$$DP[j]$$的值，当有一个值是`true`，就说明字符串$$s[0...i-1]$$能被字典所匹配，无需再继续枚举\n\n#### Boundary Condition\n\n**临界条件处理：**\n\n对于每个字符串划分时的第一种情况，由于产生了空串$$NULL$$，根据通常情况的循环表达式：\n\n```java\nfor(int j=1;j<nums.length();j++)\n  \tfor(int i=0;i<j;i++){\n        //计算当前情况得到的DP[j],DP[j]=DP[i]&&(s[i...j-1]是否可以匹配)\n\t}\n```\n\n可以看到，循环表达式处理空串划分情况是$$DP[0]$$和$$s[0...j-1]$$，说明$$DP[0]$$用来表示空串的情况，所以默认要将$$DP[0]$$初始化为$$true$$\n\n$$a,b,c$$\n$a,b,c$\n\n\n**$$s[i....j-1]$$** **的处理：**\n\n将所给字典构建一个哈希集合进行映射，利用`.contains()`来判断$$s[i....j-1]$$是否能被字典某个元素匹配.\n\n#### Java Code\n\n\n```java\nclass Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        Set<String>Dictionary=new HashSet(wordDict);\n        boolean DP[]=new boolean[s.length()+1];\n        DP[0]=true;\n        for(int i=1;i<=s.length();i++){\n            for(int j=0;j<i;j++){\n                if(DP[j]){\n                    if(Dictionary.contains(s.substring(j,i))){\n                        DP[i]=true;\n                        break;\n                    }\n                }\n            }\n        }\n        return DP[s.length()];\n    }\n}\n```\n\n","tags":["LeetCode","动态规划"]},{"title":"LeetCode-91-解码方法","url":"/2020/09/27/LeetCode-91/","content":"\n\n\n### [91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)\n\n一条包含字母 `A-Z` 的消息通过以下方式进行了编码：\n\n```\n'A' -> 1\n'B' -> 2\n...\n'Z' -> 26\n```\n\n给定一个只包含数字的**非空**字符串，请计算解码方法的总数。\n\n我的`LeetCode`笔记仓库：https://github.com/Waldenth/My-LeetCode\n\n<!-- more -->\n\n**示例 1:**\n\n```\n输入: \"12\"\n输出: 2\n解释: 它可以解码为 \"AB\"（1 2）或者 \"L\"（12）。\n```\n\n**示例 2:**\n\n```\n输入: \"226\"\n输出: 3\n解释: 它可以解码为 \"BZ\" (2 26), \"VF\" (22 6), 或者 \"BBF\" (2 2 6) 。\n```\n\n#### Dynamic Programming\n\n设`DP[i]`表示字符串`s[0...i]`的编码数量，考虑`DP[i]`和`DP[i-1],DP[i-2],DP[i-3]...`之间的联系，\n\n首先考虑`i`的一般情况，若`s[i]='0'`，那么其自身必然不能构成一个编码，必须和前面一个字符一起才可能组成`10,20`两个可能的编码，因此在`s[i]='0'`的情况下：\n\n1. ​\t`s[i-1]='2'or s[i-1]='1'`,此时`s[i-1],s[i]`一起构成一个字母编码,且只有这种情况，所以关系是`DP[i]=DP[i-2]`\n2.  `s[i-1]!='1'and'2'`,此时无法解码，最后一个`0`无法解码，`return 0`\n\n再考虑`'1'<=s[i]<='9'`的情况，其自身可以编码，也可能与前一个`s[i-1]`一起编码，但是有条件\n\n1. ​\t`s[i-1]=1`，此时一起编码对`s[i]`没有要求，`DP[i]=DP[i-1]+DP[i-2]`\n2. `s[i-1]=2`，此时一起编码有条件：\n   1. `'1'<=s[i]<='6'`，可以一起编码，`DP[i]=DP[i-1]+DP[i-2]`\n   2. `7<=s[i]<=9`，不可以一起编码，`DP[i]=DP[i-1]`\n\n再考虑更一般情况，此时最后一个字母不可能与前一个字母一起编码，`DP[i]=DP[i-1]`\n\n#### Boundary Condition\n\n一般情况考虑完，还要考虑特殊情况，前面的表达式要求`i-2>=0`，因此无法把`i=0,1,2`考虑进去，需要特殊考虑。\n\n\n\n1. `i=0`，当前字符串只有一个码，如果是`0`无法编码，返回0，否则`DP[0]=1`\n2. `i=1`，当前字符串有两个码，在`Dynamic Programming`表达式`DP[i]=DP[i-1]+DP[i-2]`中，将`DP[i-2]`退化成0，分析可得`i=1`在这种表达式的情况下，既可以一起编码又可以字符各自单独编码，因此是2，将表达式加入`(i>=2)?(DP[i-1]+DP[i-2]):2`即可。\n\n#### Java Code\n\n```java\nclass Solution {\n    public int numDecodings(String s) {\n        int length=s.length();\n        if(length==0)//空串\n            return 0;\n        int DP[]=new int [length];\n        if(s.charAt(0)=='0')//首数字0,无法匹配\n            return 0;\n        if(length==1)//长度1,非0\n            return 1;\n        DP[0]=1;\n        for(int i=1;i<length;i++){\n            if(s.charAt(i)=='0'){\n                if(s.charAt(i-1)=='1'||s.charAt(i-1)=='2'){\n                    DP[i]=(i>=2) ?(DP[i-2]):(1);\n                }else\n                    return 0;\n            }else if(s.charAt(i-1)=='1'){\n                DP[i]=(i>=2) ? (DP[i-1]+DP[i-2]):2;\n            }else if(s.charAt(i-1)=='2'){\n                if(s.charAt(i)<='6'&&s.charAt(i)>='1'){\n                    DP[i]=(i>=2)?(DP[i-1]+DP[i-2]):2;\n                }else{\n                    DP[i]=DP[i-1];\n                }\n            }else{\n                DP[i]=DP[i-1];\n            }\n        }\n        return DP[length-1];\n    }\n}\n```\n\n","tags":["LeetCode","动态规划"]},{"title":"磁盘格式与数据恢复实验","url":"/2020/09/27/DiskFormatANDataRecover/","content":"\n## 实验1 磁盘格式与数据恢复\n\n### 1.1实验名称\n\n磁盘格式与数据恢复\n\n### 1.2实验目的\n\n1)    了解磁盘的物理和逻辑结构\n\n2)    熟悉FAT32文件系统\n\n3)    学会使用磁盘编辑软件\n\n4)    了解文件删除、格式化的基本原理\n\n5)    能够利用工具或者手工恢复被删除的文件\n\n<!-- more -->\n\n### 1.3实验步骤及内容\n\n**第一阶段：**\n\n熟悉WinHex的使用。\n\nn 熟悉磁盘工具的使用。\n\nn 利用WinHex查看物理磁盘和逻辑磁盘。\n\nn 了解WinHex中相关工具的用法。\n\n \n\n**第二阶段：**\n\nn 分析本地硬盘的主引导扇区\n\nn 利用磁盘编辑工具查看MBR磁盘分区并分析：\n\nn 主引导扇区由哪些部分组成？\n\nn 四个主分区项的内容各代表什么？\n\nn 分析主扩展分区表的结构。\n\nn 通过分区项来确定每个本地逻辑盘的位置以及大小，并画出本地硬盘的逻辑结构。\n\nn 每个本地盘的开始扇区位置，总扇区数，结束扇区位置，各扩展分区表扇区位置，保留空间数量。\n\nn  利用磁盘编辑工具查看GPT磁盘分区并分析\n\nn GPT分区结构与MBR的具体差异有哪些？\n\nn 主分区头所在扇区包括哪些重要内容，验证这些重要内容的有效性。\n\nn 通过分区节点分析自己硬盘的各分区信息。\n\n**第三阶段：**\n\nn  熟悉FAT32文件格式。\n\nn 用WinHex打开某个FAT32分区格式的逻辑盘。\n\nn 查看该逻辑盘的起始扇区，分析起始扇区中的相关字段（BPB:BIOS Parameter Block）。\n\nn 查看FAT1和FAT2的内容和大小。\n\nn 查看该逻辑盘的根目录区。\n\nn 查看某个文件的目录项结构和FAT链以及具体存储位置。\n\nn 在根目录下建立文本文件：test-学号后3位.txt，其中填充60K左右的文本字符保存（注意：先行存储其他数据使得该文件的首簇高位不为0）。\n\nn 查看该文件的目录项，对其进行分析，并得到该文件所在位置以及大小。\n\nn 查看首簇位置，并得到簇链表。通过簇链表查看该文件内容。\n\nn 记录首簇位置（14H-15H,1AH-1BH）和文件大小（1CH-1FH）。\n\n \n\n**第四阶段：**\n\nn 手工恢复被删除的文件\n\nn 删除前面所建立的文件。(del&shift+del)\n\nn 利用WinHex在该文件所在盘符查找该.txt文件的目录项。\n\nn 查看目录项的变化。\n\nn 利用该残余目录项来计算被删除的文件所在的位置。\n\nn 手工恢复该文件（文件名、首簇高位、簇链表修复）。\n\n\n\n**课后习题思考：**\n\nn   在磁盘分区过程中，用户提供了哪些信息？分析分区工具的工作原理。\n\nn  高级格式化与低级格式化的具体原理和区别是什么？\n\nn 查找资料，对NTFS分区的总体结构进行分析，尝试对NTFS下删除的文件进行手工恢复。\n\nn   用数据粉碎工具（如金山、360、Strongdisk等）粉碎指定文件，分析其数据粉碎原理。\n\nn  通过分区表看到的分区字节数为何与资源管理器中看到的分区字节数有差异？\n\nn   如果删除的文件是长文件名，如何恢复所有文件名。\n\n\n\n### 1.4实验关键过程、数据及其分析\n\n#### 1.4.1 WinHex的使用\n\n以管理员模式启动WinHex，在选项界面中选择要查看的磁盘，如图1.1所示\n\n​            ![image-20200926231839438](https://i.loli.net/2020/09/26/kvCuXMUqwQ49FD1.png)                       \n\n​               图**1.1** 启动WinHex\n\n\n\n在WinHex操作界面中，选择自己要查看的逻辑盘和物理盘，确定即可打开相应的磁盘查看，如图1.2所示 ，左上角显示的是磁盘的文件目录，左下角显示的是磁盘的数据区数据信息。\n\n​     ![image-20200926231848471](https://i.loli.net/2020/09/26/5pcERn2Ay6rdFbP.png)\n\n​                图**1.2** 利用WinHex查看磁盘\n\n  \n\n由于磁盘快照生成较久，选择更新快照。\n\n \n\n在WinHex中主要使用的工具是进入指定的偏移或地址。选择导航,可以选择相应的功能，如图1.3所示 \n\n​     ![image-20200926231858453](https://i.loli.net/2020/09/26/DEyxN73pnqhiQmK.png)\n\n​              图**1.3** WinHex导航工具的使用\n\n转到偏移量可以选择基地址以及偏移量跳转到自己想要到达的地址；跳至扇区可以通过扇区为单位进行跳转。文件记录功能主要用于文件恢复过程中，利用其跳转到簇链表相应的位置。\n\n在对磁盘进行修改之后，由于WinHex没有更新磁盘信息，需要重新对磁盘进行快照，如图1.4所示。\n\n ![image-20200926231911378](https://i.loli.net/2020/09/26/2NxfwuLUX7SkKZs.png)\n\n​               图**1.4** WinHex重新快照\n\n#### 1.4.2 分析本地硬盘的主引导扇区【GPT＋MBR】\n\n\n\n利用WinHex打开MBR分区形式的磁盘，如图2.1所示，从00开始的512个字节是硬盘的主引导扇区。\n\n ![image-20200926231923158](https://i.loli.net/2020/09/26/TirBOU1yCPbjchq.png)\n\n​               图**2.1** 查看主引导扇区\n\n主引导扇区是硬盘第一个扇区，它由主引导记录(MBR),硬盘主分区表(DPT)和引导扇区标记(ID)三部分组成。\n\n主引导记录MBR：从0至多占用的0x1BDH一共446个字节，存放系统主引导程序。\n\n硬盘主分区表DPT:占用64个字节，0x1BEH – Ox1FDH , 它有四个分区项，每个项16个字节，最后8=4+4个字节存放相对扇区地址和该分区占用的扇区数量。\n\n通过WinHex自带的分区表-模板，查看物理硬盘的结构，如图2.2所示\n\n \n\n​            ![image-20200926231929898](https://i.loli.net/2020/09/26/FLqvs8NZYUklRE6.png)\n\n图**2.2** 分区表模板查看\n\n\n\n可以看到，前1B8个字节是其引导代码，从1BE开始是硬盘分区表，最后以55AA结尾。每一个分区表项的长度是16个字节。如图2.3所示。\n\n ![image-20200926231937004](https://i.loli.net/2020/09/26/ID2Nmlb9Gx7Vjq6.png)\n\n​            图**2.3** 分区表地址数据\n\n以第一个分区为例，分区表从80 20开始，到0F 00结束。00 0F A0 00表示其占有的扇区数，00 00 08 00代表其起始扇区(16进制)。0x800=2048,这与分区信息是对应的，如图2.4所示。\n\n ![image-20200926231942449](https://i.loli.net/2020/09/26/LdG4KwltmkcYI91.png)\n\n​             图**2.4** 分区第一扇区地址\n\n \n\n下面根据WinHex中分区扇区数量计算分区大小并与Windows计算机磁盘管理进行验证。\n\n以E盘为例，根据图2.3，其具有0x00513800=5322752个扇区，一个扇区512字节，因此具有2661376KB=2599MB=2.53GB，与图2.4分区E是对应的。\n\n \n\n扩展分区：主分区表只支持4个分区项目，当分区更多时无法满足，因此需要扩展分区表EBR。要使用扩展分区，首先，主分区表中必须要有一个基本扩展分区项，用于指出所有扩展分区总体信息。所有的扩展逻辑盘全在这个基本扩展分区项指出的主扩展分区中。其结构如图2.5所示。\n\n ![image-20200926231950488](https://i.loli.net/2020/09/26/gVezuUsHtiBOCbZ.png)\n\n图**2.5** 扩展分区和逻辑盘\n\n\n\n查看GPT分区，首先添加一块硬盘，进入cmd，输入命令diskpart，显示挂载在主机上的磁盘，进入磁盘转换。输入命令将其转换为GPT分区格式\n\n ![image-20200926231957708](https://i.loli.net/2020/09/26/5ksNXwEJWKTO9qv.png)\n\n  图**2.6** 转换磁盘分区格式\n\n\n\n使用WinHex打开硬盘1，如图2.7所示\n\n ![image-20200926232005449](https://i.loli.net/2020/09/26/Jmgxs4LqiXvnhu5.png)\n\n  图**2.7** GPT磁盘信息\n\n利用WinHex自带的分区表模板，查看GPT磁盘的分区表信息，如图2.8所示\n\n​     ![image-20200926232036170](https://i.loli.net/2020/09/26/BJ1VLlEnogSQYjw.png)\n\n​                          图**2.8** GPT磁盘分区表\n\n可以看到从1BE-1CA是磁盘保护性的主引导记录MBR，从0x200=512开始是磁盘的分区表。从0x400=1024开始是CPT磁盘的第一个分区表项。\n\n分区表项中存储了对应分区的起始LBA，LBA即逻辑地址块，是GPT分区形式的基本单位，每一个LBA的大小也是512个字节。\n\n分区表项1中，起始LBA块是34，终止LBA块是65569，下面验证分区1的大小：\n\n由分区表项信息，分区1一共有65569-34+1=65536个LBA块，因此有32768KB=32MB，对比图2.7分区1信息，可以发现正确。\n\n \n\nGPT与MBR分区的具体差异：\n\n​    1、MBR分区表最多只能识别2TB左右的空间，大于2TB的容量将无法识别从而导致硬盘空间浪费；GPT分区表则能够识别2TB以上的硬盘空间。\n\n2、MBR分区表最多只能支持4个主分区或三个主分区+1个扩展分区(逻辑分区不限制)；GPT分区表在Windows系统下可以支持128个主分区。\n\n3、在MBR中，分区表的大小是固定的；在GPT分区表头中可自定义分区数量的最大值，也就是说GPT分区表的大小不是固定的。\n\n#### 1.4.3 FAT32文件系统格式分析\n\n\n\n用WinHex打开一个FAT32格式的逻辑盘，如图3.1所示\n\n ![image-20200926232049173](https://i.loli.net/2020/09/26/Fi4BEOPnSe7A3c2.png)\n\n​              图**3.1** FAT32磁盘\n\n \n\n通过WinHex自带的引导扇区模板，查看该逻辑盘的起始扇区，分析起始扇区中的相关字段，如图3.2所示。\n\n \n\n0-3是其固有的字段，从0xB开始，到0x20是该逻辑盘对应的BPB(BIOS Parameter Block，BIOS参数块)字段。通过BPB可以查看这个磁盘的基本信息。如每个扇区的字节数，这里可以看到是512字节，每个簇有8个扇区。\n\n \n\nFAT32 Selection是该FAT32文件系统的一个表，从表中可以看到每一个FAT它的扇区数是5183，最后在偏移量1FE处也是以55AA结尾。\n\n![image-20200926232058111](https://i.loli.net/2020/09/26/wKZADkpriBtHXYS.png)\n\n​               图**3.2** 引导扇区模板\n\n在FAT32文件系统的磁盘中，FAT1和FAT2是存储簇链表的地方，由于FAT区十分重要，故存放两个，作为备份。\n\n在根目录区，建立了每个文件的索引，并记录了每一个文件相关的信息。用WinHex模板打开根目录查看文件，如图3.3所示\n\n ![image-20200926232113509](https://i.loli.net/2020/09/26/TLaQ7J2qz5uvGDk.png)\n\n​                      图**3.3** 查看根目录\n\n本磁盘中存储了hello25.exe文件，通过根目录模板，可以查看它的文件名是HELLO25，扩展名是EXE，创建时间是9/22 23:55，簇高位号是0，文件大小是2560Bytes=2.5KB等等信息。\n\n   在根目录下建立文本文件：test-学号后3位.txt，其中填充60KB左右的文本字符保存。更新磁盘快照，利用WinHex查看txt文件的簇，在左上角文件管理中右键选择该文件，导航->列出的簇，并取消缩短连续簇链表，如图3.4所示。\n\n![image-20200926232216972](https://i.loli.net/2020/09/26/X3IHpRa7qVltNoJ.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图**3.4** 查看根目录\n\n可以看到txt文件的首簇号是506，总共用了13个簇来存储。根据Windows文件属性可以看到，文件实际大小是50.7KB，但是占用了52KB，而图3.4显示文件占用了13个簇，由前面的信息，本系统一个簇是8个扇区，4KB，13个簇正是52KB，这就是文件实际的占用大小。50.7KB文件需占用13个簇才可以存下。\n\n \n\n下面根据文件占用的簇跳转到文件内容的位置。在WinHex中选择导航->跳转到FAT记录->填写首簇号506，跳转到簇链表对应位置。由于是FAT32系统，簇链表中每个结点大小是4个字节，文件占用13个簇，在簇链表中便占据52个字节，如图3.5所示，高亮部分即txt文件的占用的簇链表。\n\n​\t\t\t\t\t\t\t\t ![image-20200926232234479](https://i.loli.net/2020/09/26/AGgKlyOqrDaTLZb.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图**3.5** 文件簇链表\n\n\n\n注意到簇链表首结点值是0x000001FB=507,而文件的首簇号是506，这是因为在FAT32文件系统中，FAT表是连续存储的，访问首簇号结点对应的值默认是首簇号+1.\n\n \n\n记录下文件的簇链表，在WinHex中选择导航->跳至扇区，填写簇506/507，可以发现跳转到txt文件存储处，如图3.6所示。\n\n​\t\t\t\t\t\t ![image-20200926232252109](https://i.loli.net/2020/09/26/l1hRGqpKba7WPS3.png)\t\t\n\n​                            \t\t\t\t\t\t\t\t\t\t\t\t图**3.6** 文件簇链表\n\n\n\n \n\n根据目录项的定义，一个目录项占据32个字节，00H-07H字节是文件的正名，1CH-1FH是文件的占据的字节大小，打开WinHex，利用模板跳转到test-001.txt的目录项所在的位置，如图3.7所示。\n\n![image-20200926232312698](https://i.loli.net/2020/09/26/SDBtVYF8qM7Ej9W.png)\t\t\n\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图**3.7** 查看目录项\n\n可以看到第1AH-1BH=26-27字节是(逆序)  01FA，14H-15H=20-21字节是 0000，组成的首簇号是0x000001FA=506，正是该文件之前查看的首簇号，说明观察正确。而1CH-1FH=28-31是文件占据的字节大小，0x00 00 CB 10=51984Byte=50.765625KB，与文件系统中显示的大小50.8KB保持一致。说明从目录项中正确读取到了文件信息。\n\n#### 1.4.4 手工恢复被删除的文件\n\n\n\n首先使用Del键进行回收站删除，重新建立磁盘快照。在WinHex中查看文件目录，可以看到事实上文件及其对应的数据仍然还存在，如图4.1所示。\n\n ![image-20200926232327821](https://i.loli.net/2020/09/26/RKHYTZeI3LSUbC7.png)\n\n​                    图**4.1** 回收站删除后查看文件\n\n跳转至目录表对应位置，如图4.2所示，\n\n ![image-20200926232335457](https://i.loli.net/2020/09/26/OfCKGvt6o3Raln2.png)\n\n​                      图**4.2** 回收站删除后查看目标表项\n\n \n\n将图4.2和图3.7进行对比，发现目录项首字节在文件删除后被进行了修改成E5，表示被删除标记。选择E5所在字节，右键编辑->填充选块，将E5随便修改成任意数据，选择文件->保存扇区，可以发现文件恢复，如图4.3所示，但是文件名会根据修改数据改变首字母。至此，完成了回收站文件删除后的文件恢复。\n\n ![image-20200926232344488](https://i.loli.net/2020/09/26/XGKcARIVZLi2leF.png)\n\n​                      图**4.3** 恢复文件\n\n再使用shift+delete删除文件EXP.TXT，转到目录项如图4.4所示\n\n ![image-20200926232352588](https://i.loli.net/2020/09/26/zLq9jHMxaudpf6h.png)\n\n​                         图**4.4 删除后目录项**\n\n可以看到目录项也被修改，首字节被修改为E5，首簇号高16位清0，但是复原后并不能打开文件，因为簇链表数据已经丢失.\n\n\n\n查看簇链表，如图4.5所示\n\n ![image-20200926232402349](https://i.loli.net/2020/09/26/SYKNyqFkOj2DdCb.png)\n\n​                               图**4.5**\n\n \n\n可以发现簇链表对应的位置已经全部清0，要恢复文件，必须恢复簇链表再修改目录项。因此现在根据其相邻的目录项来确定其首簇号。可以看到前一个目录项的首簇号是0x00040152，文件的字节大小是0x A00，占用一个簇，因此恢复文件的首簇号是0x00040153，因此依次将图4.5中的项目进行修复，如图4.6所示\n\n ![image-20200926232408684](https://i.loli.net/2020/09/26/vzi2YO3mdkuol6B.png)\n\n​                            图**4.6**\n\n将目录项被修改的首字节和首簇高位修复。如图4.7所示\n\n ![image-20200926232415456](https://i.loli.net/2020/09/26/u4Fkl5XHVBdiGLg.png)\n\n \n\n​                            图**4.7**\n\n保存，打开文件夹，发现文件恢复成功。如图4.8所示\n\n ![image-20200926232421687](https://i.loli.net/2020/09/26/cgeoaFbXxDirQ3W.png)\n\n​                          图**4.8**\n\n \n\n#### 1.4.5 课后习题思考\n\n在磁盘分区过程中，用户提供了要分区的大小，分区的文件格式，盘符等信息。利用分区大小，系统构建新的逻辑盘，利用指定的文件格式，对分区进行格式化。\n\n \n\n低级格式化就是将空白的磁盘划分出柱面和磁道,再将磁道划分为若干个扇区,每个扇区又划分出标识部分ID、间隔区GAP和数据区DATA等。可见,低级格式化是高级格式化之前的一件工作, 高级格式化就是清除硬盘上的数据、生成引导区信息、初始化FAT表、标注逻辑坏道等。\n\n \n\n数据粉碎一般会对文件所在的位置进行重复擦写，粉碎文件之后，利用winhex查看对应偏移量数据可以发现数据已经被完全改写。\n\n \n\n文件名过长时恢复文件后需要手工查看文件数据区的文件名进行恢复\n\n \n\n \n\n1、计算机是以二进制来记录数据的，所以单位从K到M再到G是以1024来进级的。而人们习惯了十进制，以1000来进级。这样造成了显示容量和实际一样。当然，也有些不良厂家以1000为进级计算标注容量，使实际容量缩水。\n\n2、硬盘在分区和格式化时会占用一定的存储空间来保存分区等一些信息，所以实际可用容量就会小于分区的容量。\n\n3、因为硬盘的分区一般都是按扇区为单位分的（每个扇区的大小一般从几KB到几百KB，不同硬盘和格式不完全相同），所以人为输入的分区容量不一定是扇区的整数倍，系统会自动取近似的容量来划分分区。\n\n### 1.5实验体会和拓展思考\n\n通过了解磁盘格式，使我对系统对于磁盘的管理有了全新的认识，之前我曾经以为磁盘分区与分类文件夹差不多，但是通过实验让我深刻理解了分区的机理和作用。对于簇链表的学习也使我理解了文件删除和恢复的机理，明白了恶意病毒破坏数据的手段。对于FAT32,NTFS等文件系统的学习使我了解到了不同文件系统各自的特点，以及在今后如何正确为自己的电脑设置合适的文件系统。\n\n通过学习磁盘格式与数据恢复，使我对如何攻击与防御恶意软件破坏数据指明了一条方向，也促使我今后提升对于文件保护的意识。而数据恢复实验可以帮助我在紧急情况下恢复自己的重要数据\n\n \n\n ","tags":["Windows","软件安全"]},{"title":"WinDbg操作-软件安全实验","url":"/2020/09/25/SoftwareSecurityWindbg_Experiment/","content":"在自己电脑上使用WinDbg解析hello25.exe程序运行时虚拟地址0x00403000h对应的物理地址（验证条件：物理地址与虚拟地址对应的数据应一致）\n\n<!-- more -->\n\n## 软件安全实验-WinDbg查看物理地址\n\n\n### basis\n\n64位系统下虚拟地址到物理地址的转换\n\n在64位体系中，实现了48位的虚拟地址，剩下的高16位用作符号扩展，要么全是0，要么全是1.\n\n与x86体系结构不同，x64下每级页表的寻址长度变成9位，因为页的大小仍然是4KB=$$2^{12}B$$，但是数据的大小却是64bit=8Byte=$$2^3 B$$，页每个数据是$$2^3 B$$，因此有$$2^9=512$$项，需要9位寻址。\n\n64位体系下，CPU将48位虚拟地址转换成物理地址有三种模型：\n\n1. $$4KB$$页面，使用PML4T,PDPT,PDT,PT四级转换结构\n2. $$2MB$$页面，使用PML4T,PDPT,PDT三级转换结构\n3. $$1GB$$页面，使用PML4T,PDPT二级转换结构\n\n一般讨论第一种.（个人PC一般$$4KB$$页面\n\n48位虚拟地址：\n\n```\n           |           |           |\t\t   |\n0000 0000 0|000 0000 00|00 0000 010|0 0000 0001| 0000 0000 0000\n-----------+-----------+-----------+-----------+----------------\n   PML4E\t\tPDPTE\t\tPDE\t\t\tPTE\t\t\t页内OFFSET\n```\n\n### WinDbg Setting\n\n\n#### Prepare Work\n\n建议用Windows10 64位标准系统，我用的是教育版，去MSDN I tell you上搜索磁力链接，离线到云盘或者下载器下载。\n\nKMS激活：开管理员`cmd`\n\n```bash\nslmgr /ipk NW6C2-QMPVW-D7KKK-3GKT6-VCFB2\n\nslmgr /skms kms.03k.org\n\nslmgr /ato\n```\n\n管理员`cmd`输入\n\n`bcdedit -debug on `命令；如果无法执行很有可能是bios设置了安全启动，需要进入bios将其关闭。\n要选择Debug Tools中的WinDbg x64而不是 x86，WinDbg要用管理员运行\n\n**网络开启全局代理**\n\n启动后`crtl+s`或者找到`symbol search path`按钮，输入：\n`srv*C:\\Symbols*https://msdl.microsoft.com/download/symbols`\n这个`C:\\symbols`就是自己从服务器下载到本地的符号表缓存文件夹,可以自己更改，之后软件就会根据这两个路径找符号表，第一次下载下来后，就可以直接在本地对应路径链接符号表了\n\n启动内核调试,如果不加载就输入`.reolad`执行，流量好几分钟不走再输入`!process`如果执行成功就没问题了,每次启动好像路径要重新设置一下，可参考\n\n每次启动WinDbg时需要确定`srv`是否配置正确。\n\nhttps://zhuanlan.zhihu.com/p/47771088\n\n#### Steps\n\n1. 运行测试程序，添加进程，`db 401000`，查看数据\n\n   ![image-20200922201025478](https://i.loli.net/2020/09/25/NokQGuJI4vfhTHO.png)\n\n2. 运行另一个**WinDbg**，启动本地内核调试，输入命令`process 0 0 Hello25.exe`，查看`DirBase(CR3)`![image-20200922201229684](https://i.loli.net/2020/09/25/sMCb8vIOJ6jzywc.png)\n\n3.  虚拟地址401000，写成48位标准形式是0x 000000 401000\n\n   ```\n   0000 0000 0|000 0000 00|00 0000 010|0 0000 0001| 0000 0000 0000\n   -----------+-----------+-----------+-----------+----------------\n      PML4E\t\tPDPTE\t\tPDE\t\t\tPTE\t\t\t页内OFFSET\n   ```\n\n   PML4E=PDPTE=0,\n\n   PDE=2\n\n   PTE=1\n\n   页内偏移=0\n\n   由于PML4E=0，上一级的12-35位提供下一级的物理基地址高24位，低12位补0，输入`!dq 39c45000+0*8`,\n\n   这里一个页项64bit=8字节，第0个页项，对应项字节地址(即首地址)即`+0*8`\n\n   ![image-20200922202933529](https://i.loli.net/2020/09/25/SgZpdFrVBclI7ms.png)\n\n4. PDPTE=0，输入`!dq 07e7e6000+0*8`\n\n   ![image-20200922203027885](https://i.loli.net/2020/09/25/QEUVWRDumPYXHij.png)\n\n5. PDE=2，输入`!dq 069ca7000+0x2*8`\n\n   ![image-20200922203141535](https://i.loli.net/2020/09/25/WJQaxIomzBSpwlN.png)\n\n6. PTE=1，输入`!dq 028968000+0x1*8`\n\n   ![image-20200922203305876](https://i.loli.net/2020/09/25/LuPGD4wOJcXSbTH.png)\n\n7. 页内偏移0，输入`!db 11a6be000+0`\n\n   ![image-20200922203947854](https://i.loli.net/2020/09/25/4bGEwgiYuUl1z6e.png)\n\n   比较第1步，成功访问相同数据。\n\n","tags":["Windows","软件安全"]},{"title":"JAVA 多文件运行的命令行操作","url":"/2020/09/25/JAVA_multifile_command/","content":"\n## JAVA 多文件运行的命令行操作\n\n\n\n如果有多个`.java`文件互相依赖，直接用`java {mainfile}.java`是无法运行的，而如果主文件设置是处于某个`package`中，不能在文件同级目录下运行.\n\n<!-- more -->\n\n### Web Info\n\n该如何解决呢？解决办法如下：\n\n1.由于是在运行阶段出现的问题，那么可能是环境变量配置不当的问题，即可能是`classpath`路径配置错误，而导致.class文件无法加载。那么此时你可以检查是否配置好`classpath`路径，一般来说`classpath`路径配置如下：\n\n`.;%java_home%\\lib;%java_home%\\lib\\tools.jar；` （注意前面的` .` 以及 `;` 缺一不可,点代表的是运行的当前路径）\n\n其中`.`表示当前路径，`;`表示分隔符。\n\n\n\n2.如果你试过了很多次，`classpath`也配置对了，依旧出现这个错误，注意你使用的测试代码，是否在某一个包名的下面；\n\n比如说如下测试代码：\n\n![img](https://i.loli.net/2020/09/25/dIsWtF3P7K49qSH.png)\n\n在文件所在的当前目录下，运行`javac TestPlusPlus.java`编译成功，生成`TestPlusPlus.class`文件，这个时\n\n候，你用`java TestPlusPlus`想运行程序，总会出现”找不到或无法加载主类“的错误。这个时候要注意，\n\n之所以找不到，是因为`TestPlusPlus`在HelloWorld包名的下面。\n\n解决办法：\n\n1.去掉` ”package HelloWorld;“` 重新用`javac `编译`TestPlusPlus.java`,再运行`java TestPlusPlus`就可以了。\n\n2.新建一个包名一样的文件夹，在本例中，为建立一个HelloWorld的文件夹，把`TestPlusPlus.java`文件移到该目录下。\n\n然后在HelloWorld文件夹的平级下，打开DOS命令窗口，运行`javac HelloWorld/TestPlusPlus.java`编译程序，\n\n运行`java HelloWorld/TestPlusPlus`(或者`java HelloWorld.TestPlusPlus`也可以)，则可以运行含有包名的java程序。\n\n\n\n**注意:包名不要含有'.'(点),' '(空格)等特殊符号，这样的话命令行无法判断包名与java程序名的分割点在哪里，从而还是找到或者无法加载主类。**\n\n**因此，命令`java HelloWorld/TestPlusPlus`只能这样写**，\n\n**不能**写成``java ./HelloWorld/TestPlusPlus``和`java /HelloWorld/TestPlusPlus`,因为空有一个`/`不知道是哪个目录，而`.`又不能加。另外，指明路径时最好不要用反斜杠`\\`\n\n```shell\njava charactor/Run.java  # YES,运行的.java文件(要先编译出.class)\njava charactor/Run\t\t#\tYES\t目标是.class\njava charactor.Run\t\t# YES\n\njava charactor\\Run.java\t#YES\t不好\njava charactor\\Run\t\t#NO\njava charactor.Run.java\t#NO,用.指引路径不要加.扩展名,会以为成一级目录\njava .charactor.Run\t\t#NO,当前是在charactor文件夹同级目录下,不要加点\n```\n\n\n\n### Why?：\n\njava程序运行class文件,对于有包名的类,java把包名当成文件夹处理.\"包名+类名\"相当于\"文件夹目录+类名\"来寻找类。\n\n```shell\njava charactor.Run\njava charactor/Run\n```\n\n**多文件要先编译**\n\n```shell\njavac .\\property\\*.java -encoding UTF-8\njava property.Item\n{java property/Item}\n```\n\n若编译好了一个包，可以在同级目录下编写`java`文件来`import`这个包\n\n![image-20200912155753020](https://i.loli.net/2020/09/25/7SypAFvck36qDHi.png)\n\n```java\nimport property.*;\npublic class test{\n    public static void main(String[]args){\n        Item i1=new LifePotion();\n        Item i2=new MagicPotion();\n        System.out.println(\"i1 是Item类型,执行effect:\");\n        i1.effect();\n        System.out.println(\"i2也是Item类型,执行effect:\");\n        i2.effect();\n    }\n}\n```\n\n编译，`classpath`默认就是当前目录，不要再设置，有中文需要加上后缀`-encoding UTF-8`\n\n```shell\n javac  .\\test.java -encoding UTF-8\n java   test\n```\n\n如果在别的地方写`.java`，需要设置`-cp` ，直接执行中文会乱码\n\n![image-20200912160535205](https://i.loli.net/2020/09/25/5nABpdjDgzMfyaS.png)\n\n```shell\njava -cp \".\\DT\" test.java\n```\n\n```shell\njavac -cp \".\\DT\" test.java\n```\n\n最好是写成\n\n`.\\DT\\;`\n\n`.\\DT;`\n\n重点是`;`\n\n编译后\n\n```shell\njava -cp \".\\DT\\;\" Test\n```\n\n对于.class文件来说，只需要指明包的路径即可；但是对于jar文件来说，必须要指定全路径即路径+文件名.jar的格式，不能只指定一个路径\n\n```shell\njavac -cp \"F:\\MyNotes\\How2J\\DT\\;\"  Test.java\njava -cp \"F:\\MyNotes\\How2J\\DT\\;\"  Test\n```\n\n","tags":["java"]},{"title":"C语言中的函数参数使用引用'&'和指针'*'","url":"/2020/09/24/&andPoint/","content":"\n# C语言的指针与引用\n\n**本文有误,C语言并不支持引用,这是C++的特性**\n\n我们知道指针是保存地址的变量，int a=10；int*p=&a；\n那么我们就建立了一个指针p变量指向int型数据a；\n指针的一个很常见的应用就是传入函数做形参对数据进行操作。\n我们知道仅仅向函数传入形参,函数执行完后不能对我们的main()实参进行修改的。如果要修改，那么指针是一个很重要的手段。可以说，没有指针，C语言的函数很多功能都实现不了。\n但是,C语言还有一种函数形参，姑且叫做'引用'，这个也是能够实现指针的一些功能的。\nint a=10；function(a)；//function（）声明是 int function(int &b)\n也能实现对main（）中a的修改\n但是它们之间有一定的区别。\n<!-- more -->\n## C语言的指针简介\n```\tc\nvoid swap_1(int a,int b)\n{\n    int t=a;\n    a=b;\n    b=t;\n    return;\n}\nvoid swap_2(int *a,int *b)\n{\n    int t=*a;\n    *a=*b;\n    *b=t;\n    return ;\n}\nint main()\n{\n\tint a=10;int b=20;\n\tswap_1(a,b);\n\tswap_2(&a,&b);\n\treturn 0;\n}\n```\n 1. **swap_1()无效，swap_2()有效**`swap_1(a,b);\n\tswap_2(&a,&b);` ，函数内部和传入函数的参数都是临时变量，**`swap_1(a,b)`仅仅传入了两个临时参数，对两个参数进行交换，但是函数结束后临时变量销毁，并没有改变**`main()`中的a和b；\n\t`swap_2(&a,&b)`却不同，函数声明中形式变量是指针，传入的是地址，函数的临时变量利用地址对a，b两个数据进行了操作。这样即使函数结束，临时变量销毁，a,b地址上的a,b还是被进行了交换；\n2. 需要注意的是，虽然函数使用指针对main()中的数据变量进行了修改，但是函数内部，指针也仍然是临时变量。当函数需要对数组进行扩展`realloc(),malloc()`时，使用这种指针临时变量是危险并且很容易出错的。\n3. \n\n\n## C语言引用简介\n\n我们知道，C语言的函数传入的一般都是作为临时变量使用的。这是初学者非常意外的事情。很多人初学C函数语法，都会写出`swap_1()`的数值函数，然而这个函数并没有实现之前预想的交换`main()`中的两个`int`型变量的值。\n解决这个问题，一种思路是使用指针，也就是定义&声明函数时指出形式参数是一个指针变量。这里在强调一下指针：\n`int* a`的意思是定义一个变量`a`，a是指向一个`int`型数据的指针。这个指针保存的数据是这个被指向的数据的地址。\n所以`int b=10;a=&b;`这样我们就让这个指针变量保存了b的地址，指针a也就指向了数据b。\n\n**但是**，指针刚开始的理解并不是那么直观，有没有一种能够和初学者想法一样的直接传入函数后操作就能够实现对`main()`等等其他模块内的数据进行操作的方法呢？**“引用”**就是一个解决方法\n```c\nvoid swap_3(int &a,int &b)\n{\n    int t=a;\n    a=b;\n    b=t;\n    return ;\n}\nint main()\n{\n\tint a=10;int b=20;\n\tswap_3(&a,&b);\n\tprintf(\"a=%d,b=%d\\n\",a,b);\n\treturn 0;\n}\n```\n![运行结果](https://img-blog.csdnimg.cn/20191218210928987.png)\n可以看到，函数`swap_3()`成功实现了交换，而且没有用到较为复杂的指针和地址，除了形参加上了`&`符号，几乎和新手想的一样，但是却成功了\n这种`return_value_name function_name(&parameter_list)`的定义与声明，传入的参数是一个实际参数的**引用**。\n引用实现了函数对传入参数的直接操纵。可以理解为,这里的函数引用，其实是对实际参数取了一个在函数内部的**别名**，函数内部使用这个别名直接对这个实际参数进行了处理。\n**注意，这一点是很重要的。因为当我们使用指针实现对数据在函数内进行修改时，这个指针也是一个临时变量，指针对指向的数据操纵后也就销毁了。如果我们在函数内想对一个数组指针扩大数组范围，使用临时变量的指针``realloc()``后，在离开函数后，其实这里的realloc()改变的是这个临时指针变量指向的内存空间。而离开函数后指针销毁，原来的实际指针指向的内存单元并没有也相应改变。这是危险的**\n\n\n## 指针&引用在C函数中实际应用一例\n\n*程序目标，设计一个链表节点初始化函数，要求对一个类型的指针赋予对应类型的一个内存空间，并把节点值赋值为data* \n\n**错误写法**\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct LNode\n{\n\tint data;\n\tstruct LNode*next;\n}LinkNode;\n\n\nvoid Init_LinkNode(LinkNode*n,int data)\n{\n\tn=(LinkNode*)malloc(sizeof(LinkNode));\n\tn->data=data;\n\tn->next=NULL;\n}\n\nint main()\n{\n\tLinkNode*L=NULL;\n\n\tInit_LinkNode(L,1);\n\n\tprintf(\"%d\\n\",L->data);\n\n\tfree(L);\n\treturn 0;\n}\n```\n![发生错误](https://img-blog.csdnimg.cn/20191218224256158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dhbGRlbnRo,size_16,color_FFFFFF,t_70)\n为什么会发生错误？\n**A：**这是一个非常典型的指针理解不到位造成的错误。事实上，`Init_LinkNode()`函数传入的指针变量`n`在函数中仍然是一个临时变量，这个临时变量`n`和`main()`中的L都指向NULL，传入函数后，临时变量获得了一块内存单元并进行处理，但是出函数后，这个临时指针变量销毁了。指向的处理化后的内存单元也没了。而L却仍然指向NULL,这就造成了错误。\n\n**正确写法1**\n```c\nvoid Init_LinkNode(LinkNode*&n,int data)\n{\n\tn=(LinkNode*)malloc(sizeof(LinkNode));\n\tn->data=data;\n\tn->next=NULL;\n}\n\n```\n![运行正确](https://img-blog.csdnimg.cn/20191218225013899.png)\n这里我们向函数中传入的是`LinkNode*&n`\n`int * &c = a;\t\t//这里c是一个引用，它是指针a的引用`\n区分技巧：在分析上面代码时，可以从变量标识符开始从右往左看，最靠近标识符的是变量的本质类型，而再往左即为对变量类型的进一步修饰。\n\n举例 ：\n\nint * & a;\n\n标识符a的左边紧邻的是&，证明a是一个引用变量，而再往左是*，可见a是一个指针的引用，再往左是int，可见a是一个指向int类型的指针的引用。\n————————————————\n版权声明：本文为CSDN博主「csu_zhengzy~」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/qq_18108083/article/details/84679104\n\n**正确写法2**\n既然传入的指针变量是临时变量，那可不可以传入指针变量的指针呢？\n```c\nvoid Init_LinkNode(LinkNode**n,int data)\n{\n\t*n=(LinkNode*)malloc(sizeof(LinkNode));\n\t(*n)->next=NULL;\n\t(*n)->data=data;\n}\n\nint main()\n{\n\tLinkNode*L;\n\n\tInit_LinkNode(&L,1);\n\n\tprintf(\"%d\\n\",L->data);\n\n\tsystem(\"PAUSE\");\n}\n```\n![Awesome!](https://img-blog.csdnimg.cn/20191218225730193.png)\n由于`*`运算优先级低于`->`加上括号\n我们得到了这个awesome的结果，向函数传入指针的指针，这个临时变量就可以操纵`main()`里面的指针了\n","tags":["C","C++"]},{"title":"C/cpp的小数IEEE-754","url":"/2020/09/24/IEEE-754/","content":"\n\n很多人对学python的爱好者diss的常见手段之一，就是让他们解释这个程序的结果\n```python\na=0.1+0.2\nprint(a)\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200119222726243.png)\n这其实就是涉及到计算机中小数的表示了.\n接下来，我们用最适合解释这种表示的C语言来介绍计算机中小数的表示，以及经典的IEEE-754标准。\n<!-- more -->\n## C中小数的表示\n\n学过C的都知道，.C中，小数一般都是被叫做浮点数，`int`表示的是**整型变量**，对应的就是`float`，被称作**浮点数**(英文float)，很多人就将其理解为C的小数变量表示。此外，C中还有一种浮点数形式`double`，熟悉概念的人应该知道，这是**双精度浮点数**的意思(英文double)\n它们两者之间的区别？一般的了解者可能会说，`double`比`float`表示小数时精度更高一些。的确是这样，但是我们怎样更加深入的理解，并解释上文python程序中这一个貌似有点奇怪的结果呢？我们先从一个简单C程序说起.\n**考虑到查阅资料和网页工具的方便性，使用Dev-c++，编译环境TDM-GCC 4.9.2 64bit**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200119223701687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dhbGRlbnRo,size_16,color_FFFFFF,t_70)\n如之前所述，可以看到，a变量为`float`型，也是4字节32bit，将其赋值0.3，打印小数8位，也出现了类似python程序的现象，出现了一个`1`，为什么好端端赋值0.3确打印了个1出来？这就涉及到二进制小数的表示了。\n首先说明，十进制表示法中，有一些数字是没法用有限位表示的，比如循环小数，无理数。\n同样，二进制表示法，也有小数没办法用有限位表示，而且，很多十进制可以轻松表达的小数，二进制表示却较复杂.\n 1. 0.75的二进制表示，0.11 ，二进制可以有限位精确表示\n 2. 然而0.3的二进制表示则是：`0.0 100 1100 1100 1100 1100 1100 1100110011001100110011001101....`事实上这么多位下来还是没有完全精确的表示0.3。而我们之前看到，a占据的内存单元只有32bit，甚至无法满足这个精度(由于IEEE-754标准)\n 那么这个32位的浮点数a怎么存储0.3，为什么打印小数点后8位是0.3000 0001呢？\n 经典的IEEE-754标准可以解释这个问题\n\n\n## IEEE-754 浮点标准 部分简介\n\n在计算机小数表示中，小数一般是科学计数法表述的.\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200119224953992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dhbGRlbnRo,size_16,color_FFFFFF,t_70)\n`float`又被称为单精度浮点表示，`double`是与之对应的双精度浮点表示。\n这里只介绍`float`，结构如上图上部，双精度与其类似，但是精度更高。后续可以自然理解。\n\n之所以叫做**浮点**，这其实是一个非常形象的描述\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200119231148576.png)\n小数点其实是可以运动的，根据指数m，小数点可以左移/右移 |m|位，以此来表示不同大小的\"小数\"。\n\n比如我们定义这样一个C变量\n```c\nfloat a=0.75;\n```\n那么,a可以简单写成二进制0.11，用二进制科学计数法表示也就是`1.1 x 2^-1`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200119225410853.png)\n\n有关IEEE-754:\n是20世纪80年代以来最广泛使用的浮点数运算标准，为许多CPU与浮点运算器所采用。这个标准定义了表示浮点数的格式（包括负零-0）与反常值（denormal number）），一些特殊数值（无穷（Inf）与非数值（NaN）），以及这些数值的“浮点数运算符”；它也指明了四种数值舍入规则和五种例外状况（包括例外发生的时机与处理方式）。\nIEEE 754规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现）。只有32位模式有强制要求，其他都是选择性的。大部分编程语言都有提供IEEE浮点数格式与算术，但有些将其列为非必需的。例如，IEEE 754问世之前就有的C语言，有包括IEEE算术，但不算作强制要求（C语言的float通常是指IEEE单精确度，而double是指双精确度）。\n该标准的全称为IEEE二进制浮点数算术标准（ANSI/IEEE Std 754-1985），又称IEC 60559:1989，微处理器系统的二进制浮点数算术（本来的编号是IEC 559:1989）。后来还有“与基数无关的浮点数”的“IEEE 854-1987标准”，有规定基数为2跟10的状况。最新标准是“ISO/IEC/IEEE FDIS 60559:2010”。\n\n另外，IEEE((美国)电气和电子工程师协会)的读法，I-E-E-E是一种方式，但其实口语中更广泛的是读作I triple E\n\n现在，按照上图，按照IEEE-754,我们这样存储0.75：\ns：符号位 0正1负，显然，这里是正数，为0\nexp：表示指数，30-23共8位，可表示0-255，在IEEE-754标准中，exp段可视为无符号数，但是并不是表示数字的指数，而是指数的`带偏阶的指数`。可表示的范围中，1-254部分，有一个偏阶bias，bias=2^(k-1) -1 k是exp段位数，因此单精度中bias=127(双精度是1023)\n科学计数法表示中的指数E=-1，加上偏阶bias，结果是126，所以exp段应该存储的是无符号数126，0111 1110\nfrac:这一段被称作**尾数**，也就是科学计数法中小数部分'0.1'，这里有一个现象，exp=1--254可表示的数字往往被称作**规格化数**，可以看到，小数点前的部分都是'1',所以，可以节省一位(因为知道规格化数肯定小数点前一位是1)，所以，IEEE-754标准规定，规格化数的有**前导位1**，尾数只要存储小数点后的数字就行了。小数点后是0.'1'，那么用23位尾数表示就是：\n(0.) `1000 0000 .....0000` （23位）\n\n**这里可以看到，浮点数的精度其实是靠尾数决定的，尾数位数越多，可表示的精度越高，这就是为什么有52位位数的double比有23位尾数的float精度高的原因**\n\n现在，根据IEEE-754规格化单精度浮点数标准，我们可以写出32位浮点数0.75在IEEE-754格式下的表示了:\n0--0111 1110--1000 0000 0000 0000 0000 000\n\n接着，我们还要填之前的一个坑:以上只是IEEE-754对**规格化数**的表示，规格化数exp段范围是只有1-254的。那么0和255呢？规定如下:\n\nexp=0时，如果尾数frac也为0，那么此时编码表示0，这就是\"机器零\"，因为机器无法表示比它更小的数了，便把它作为0\n\nexp=0,frac非0，这表示的是**非规格化数**，规格化数都是1.xxx * 2^xx ，单精度浮点数能够表示的最接近零的数绝对值是1.000..00 x 2 ^ -126,为了填补规格化数和机器零之间的\"距离\"， 就有了非规格化数。与规格化数不同，非规格化数没有前导为位1，也就是说，可以表示 0.xx * 2 ^ xx 。\n此外，非规格化数的偏阶bias也不再是127，而是126，也就是说，它表示的其实是0.xxx * 2 ^ -126  将它与规格化最小数1.000..00 x 2 ^ -126 比较，`填补规格化数和机器零之间的\"距离\"`\n这一解释就显得非常的形象了。\n\n此外，\nexp=255,frac=0时，表示无穷(溢出了)，(为了形成实数的拓扑闭集合)\nexp=255,frac非0，表示NaN,即不是数的意思，Not a Number,这里不再过多介绍。\n.\n.\n.\nDouble表示与float类似。不再赘述。而目前的最新标准中，新增了其他一些精度表示，比如半精度，其实也是与上述介绍类似的。\n\n\n## 对0.3000 0001的解释\n到现在为止，其实对浮点数的介绍已经不少了.现在尝试解释0.3000 0001的由来。\nfloat a=0.3,\n可知，0.3在二进制小数中不能通过有限精度表示的，\n0.3=0.0 100 1100 1100 1100 1100 1100 1100110011001100110011001101....\n根据IEEE-754,我们选取小数点后第一个非0数字开始：\n1 00110011001100110011001100110011001100110011001101...\n1作前导位，接着后24位是：0011 0011 0011 0011 0011 001 1 \n而单精度尾数段只有23位，进行舍入:\n注意看这里的最后一位是1，而不是0， 这里就采用了四舍五入的原则，回忆一下，在10进制中比如0.57四舍五入保留一位小数的结果是0.6，那就是因为第2位小数是7，超过了5所以进1位，  在二进制中就看下一位是1还是0，如果是1就进位。24位二进制串中的第24位为1，因此进位到23位。再进位，所以尾数是：\n0011 0011 0011 0011 0011 010\n转换为IEEE-754格式:\n0--0111 1101--0011 0011 0011 0011 0011 010\n这就是单精度float变量a对0.3的存储，我们读取它.\n1.0011 0011 0011 0011 0011 010 x 2^ 125-127=\n0.01 0011 0011 0011 0011 0011 010 \n转换为10进制:\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200119235800501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dhbGRlbnRo,size_16,color_FFFFFF,t_70)\n读取8位小数，0.3000 0001 1，四舍五入，就是0.3000 0001.\n当然，我们还可以验证9位小数，0.3000 00011 9，四舍五入结果应该是0.3000 00012，通过程序验证:\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200120000009393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dhbGRlbnRo,size_16,color_FFFFFF,t_70)\n程序结果完美符合我们的预测。\n\n此外，还想讨论几件事情，\nhttp://www.styb.cn/cms/ieee_754.php\n这个网站提供了IEEE-754转换功能，之前我也是认为正确的，但是在写这篇文章时意外感觉作者可能有了一个疏忽，就是忘记了尾数的舍入。\n0.3在该网站的结果是这样的:\n0--0111 1101--0011 0011 0011 0011 0011 001\n尾数对应段应该是0011 0011 0011 0011 0011 0011，但是作者似乎没有考虑舍入，而是直接截取了23位，这就造成结果是0.0100110011001100110011001\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200120000649263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dhbGRlbnRo,size_16,color_FFFFFF,t_70)\n无法解释本环境下的结果了。当然这只是我的想法，欢迎大家指正。\n除此之外，IEEE-754还可以解释一些浮点运算现象，比如一个大数加上一个较小的小数，结果会发现较小数\"没有加上去\",不过这些就涉及更复杂的保护，舍入，粘贴位的概念了，以后有机会可以再写写。\n","tags":["C","计算机组成原理"]},{"title":"Git教程","url":"/2020/09/24/HowtoUseGit/","content":"\n参考资料：https://www.liaoxuefeng.com/wiki/896043488029600\n\n<!-- more -->\n\n### 用户名\n\n安装完成后，还需要最后一步设置，在命令行输入：\n\n```\n$ git config --global user.name \"Your Name\"\n$ git config --global user.email \"email@example.com\"\n```\n\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。\n\n注意`git config`命令的`--global`参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。\n\n输入\n\n```shell\ngit config --list\n```\n\n可以查看配置的一些东西。可以看到`user.name` 和`user.email` 分别是什么\n\n**重命名**\n\n这边给出了`--repalce-all` 这个东西。\n\n然后我尝试着用\n\n```shell\n$ git config --global --replace-all user.email \"输入你的邮箱\" \n\n$ git config --global --replace-all user.name \"输入你的用户名\"\n```\n\n### 仓库初始化\n\n初始化一个Git仓库，使用`git init`命令，当前目录成为仓库.\n\n文件一定要放到`learngit`目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。\n\n和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。\n\n什么是版本库呢？版本库又名仓库，英文名**repository**，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。\n\n所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：\n\n```shell\n$ mkdir learngit\n$ cd learngit\n$ pwd\n/Users/michael/learngit\n```\n\n`pwd`命令用于显示当前目录。在我的Mac上，这个仓库位于`/Users/michael/learngit`。\n\n 如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。\n\n第二步，通过`git init`命令把这个目录变成Git可以管理的仓库：\n\n```shell\n$ git init\nInitialized empty Git repository in /Users/michael/learngit/.git/\n```\n\n瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个`.git`的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。\n\n如果你没有看到`.git`目录，那是因为这个目录默认是隐藏的，用`ls -ah`命令就可以看见。\n\n### 文件入库\n\n第一步，用命令`git add`告诉Git，把文件添加到仓库：\n\n```\n$ git add readme.txt\n```\n\n第二步，用命令`git commit`告诉Git，把文件提交到仓库：\n\n```\n$ git commit -m \"wrote a readme file\"\n```\n\n`-m`后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录\n\n为什么Git添加文件需要`add`，`commit`一共两步呢？因为`commit`可以一次提交很多文件，所以你可以多次`add`不同的文件\n\n```\n$ git add file1.txt\n$ git add file2.txt file3.txt\n$ git commit -m \"add 3 files.\"\n```\n\n### 查看日志和版本回退\n\n版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用`git log`命令查看：\n\n```shell\n$ git log\ncommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -> master)\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 21:06:15 2018 +0800\n\n    append GPL\n\ncommit e475afc93c209a690c39c13a46716e8fa000c366\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 21:03:36 2018 +0800\n\n    add distributed\n\ncommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 20:59:18 2018 +0800\n\n    wrote a readme file\n```\n\n`git log`命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是`append GPL`，上一次是`add distributed`，最早的一次是`wrote a readme file`。\n\n如果嫌输出信息太多，看得眼花缭乱的，可以试试加上`--pretty=oneline`参数\n\n```shell\n$ git log --pretty=oneline\n1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -> master) append GPL\ne475afc93c209a690c39c13a46716e8fa000c366 add distributed\neaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file\n```\n\n首先，Git必须知道当前版本是哪个版本，在Git中，用`HEAD`表示当前版本，也就是最新的提交`1094adb...`（注意我的提交ID和你的肯定不一样），上一个版本就是`HEAD^`，上上一个版本就是`HEAD^^`，当然往上100个版本写100个`^`比较容易数不过来，所以写成`HEAD~100`。\n\n现在，我们要把当前版本`append GPL`回退到上一个版本`add distributed`，就可以使用`git reset`命令：\n\n```shell\n$ git reset --hard HEAD^\nHEAD is now at e475afc add distributed\n```\n\n最新的那个版本`append GPL`已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？\n\n办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个`append GPL`的`commit id`是`1094adb...`，于是就可以指定回到未来的某个版本：\n\n```shell\n$ git reset --hard 1094a\nHEAD is now at 83b0afe append GPL\n```\n\n版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了.\n\n现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的`commit id`怎么办？\n\n在Git中，总是有后悔药可以吃的。当你用`$ git reset --hard HEAD^`回退到`add distributed`版本时，再想恢复到`append GPL`，就必须找到`append GPL`的commit id。Git提供了一个命令`git reflog`用来记录你的每一次命令：\n\n```\n$ git reflog\ne475afc HEAD@{1}: reset: moving to HEAD^\n1094adb (HEAD -> master) HEAD@{2}: commit: append GPL\ne475afc HEAD@{3}: commit: add distributed\neaadf4e HEAD@{4}: commit (initial): wrote a readme file\n```\n\n终于舒了口气，从输出可知，`append GPL`的commit id是`1094adb`，现在，你又可以乘坐时光机回到未来了\n\n#### 小结\n\n现在总结一下：\n\n- `HEAD`指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令`git reset --hard commit_id`。\n- 穿梭前，用`git log`可以查看提交历史，以便确定要回退到哪个版本。\n- 要重返未来，用`git reflog`查看命令历史，以便确定要回到未来的哪个版本。\n- \n\n### 工作区（Working Directory）\n\n就是你在电脑里能看到的目录，比如我的`learngit`文件夹就是一个工作区：\n\n#### Stage 暂存区\n\n![git-stage-after-commit](https://i.loli.net/2020/09/25/Cf6eVF5nbraBxJW.jpg)\n\n\n\n**每次修改，如果不用`git add`到暂存区(stage)，那就不会加入到`commit`中**\n\n**如果在git add 文件之后，commit之前，在工作区中对该文件进行修改，commit时会将该次修改一起提交**\n\n\n\n命令`git checkout -- readme.txt`意思就是，把`readme.txt`文件在工作区的修改全部撤销，这里有两种情况：\n\n一种是`readme.txt`自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n\n一种是`readme.txt`已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n\n总之，就是让这个文件回到最近一次`git commit`或`git add`时的状态。\n\n**`git checkout`其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。**\n\n#### 小结\n\n场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令`git checkout -- file`。\n\n场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令`git reset HEAD `，就回到了场景1，第二步按场景1操作。(还没有提交commit，回到当前版本就可以丢弃暂存区修改)\n\n场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考[版本回退](https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192)一节，不过前提是没有推送到远程库\n\n### 删除文件\n\n在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件`test.txt`到Git并且提交\n\n```\ngit add test.txt\n```\n\n一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用`rm`命令删了\n\n这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，`git status`命令会立刻告诉你哪些文件被删除了\n\n现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令`git rm`删掉，并且`git commit`：\n\n```\ngit rm test.txt\nrm 'test.txt'\n```\n\n现在，文件就从版本库中被删除了。\n\n另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：\n\n```\n$ git checkout -- test.txt\n```\n\n`git checkout`其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。\n\n**删除了所有文件**\n\n```shell\ngit rm *\n```\n\n **注意：从来没有被添加到版本库（暂存区stage+master）就被删除的文件，是无法恢复的！**\n\n#### 小结\n\n命令`git rm`用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失**最近一次提交后你修改的内容**。\n\n### 关于文件夹\n\n**删除**\n\n```powershell\ngit  rm  {要删除的文件夹}  -r -f  \n```\n\n**创建**\n\n```shell\nmkdir {}\n```\n\n#### rm指令\n\nLinux `rm` （英文全拼：remove）命令用于删除一个文件或者目录。\n\n语法\n\n```\nrm [options] name...\n```\n\n**参数**：\n\n- -i 删除前逐一询问确认。\n- -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。\n- -r 将目录及以下之档案亦逐一删除。\n\n**实例** \n\n删除文件可以直接使用`rm`命令，若删除目录则必须配合选项\"`-r`\"，例如：\n\n```\n# rm  test.txt \nrm：是否删除 一般文件 \"test.txt\"? y  \n# rm  homework  \nrm: 无法删除目录\"homework\": 是一个目录  \n# rm  -r  homework  \nrm：是否删除 目录 \"homework\"? y \n```\n\n**删除当前目录下的所有文件及目录，命令行为：**\n\n```\nrm  -r  * \n```\n\n文件一旦通过rm命令删除，则无法恢复，所以必须格外小心地使用该命令。\n\n**删除当前目录下的所有文件及目录，并且是直接删除，无需逐一确认命令行为：**\n\n```\nrm  -rf  要删除的文件名或目录\n```\n\n### 远程仓库\n\n显示所有远程仓库：\n\n```shell\ngit remote -v\n```\n\n添加远程版本库：`shortname `为本地的版本库\n\n```shell\ngit remote add [shortname] [url]\n```\n\n其他相关命令：\n\n```shell\ngit remote rm name  # 删除远程仓库\ngit remote rename old_name new_name  # 修改仓库名\n```\n\n```shell\n# 提交到 Github\n$ git remote add origin git@github.com:tianqixin/runoob-git-test.git\n$ git push -u origin master\n```\n\n#### 删除远程仓库\n\n删除远程仓库你可以使用命令：\n\n```shell\ngit remote rm [别名]\n```\n\n#### 实例\n\n```shell\n$ git remote -v\norigin    git@github.com:tianqixin/runoob-git-test.git (fetch)\norigin    git@github.com:tianqixin/runoob-git-test.git (push)\n\n# 添加仓库 origin2\n$ git remote add origin2 git@github.com:tianqixin/runoob-git-test.git\n\n$ git remote -v\norigin    git@github.com:tianqixin/runoob-git-test.git (fetch)\norigin    git@github.com:tianqixin/runoob-git-test.git (push)\norigin2    git@github.com:tianqixin/runoob-git-test.git (fetch)\norigin2    git@github.com:tianqixin/runoob-git-test.git (push)\n\n# 删除仓库 origin2\n$ git remote rm origin2\n$ git remote -v\norigin    git@github.com:tianqixin/runoob-git-test.git (fetch)\norigin    git@github.com:tianqixin/runoob-git-test.git (push)\n```\n\n### SSH密钥配置\n\n```shell\ncd ~/.ssh\n```\n\n**如果之前有密钥且不用了**\n\n```shell\nrm  id_rsa\nrm  id_rsa.pub\n```\n\n**生成**\n\n```shell\n ssh-keygen -t rsa -C \"waldenth@outlook.com\"\n```\n\n**.pub是公钥**\n\n```shell\ncat id_rsa.pub\n```\n\n**VPN下如果SSH被拒绝访问Github，使用HTTPS**\n\n```shell\ngit remote add LeetCodeNote-https https://github.com/Waldenth/My-LeetCode.git\ngit push [-u] LeetCodeNote-https master\n```\n\n### 删除本地仓库\n\n**删除仓库，就是需要删除仓库文件夹下隐藏的 .git 文件夹！！！**\n\n进入项目所在目录，打开git bash，开始删除本地仓库：\n\n显示所有本地分支（初始化时只有一个master分支）\n\n```shell\n$ git branch\n```\n\n初始化本地版本库（重新初始化一次，可以忽略）\n\n```shell\n$ git init\n```\n\n找到目录下隐藏的 .git\n\n```shell\n$ ls -ah\n```\n\n删除 .git\n\n```shell\n$ rm -rf .git\n```\n\n1. 可以看到master分支已经删除\n\n```shell\n$ ls -a\n```\n\n### 创建与合并分支\n\n在[版本回退](https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192)里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即`master`分支。`HEAD`严格来说不是指向提交，而是指向`master`，`master`才是指向提交的，所以，`HEAD`指向的就是当前分支。\n\n一开始的时候，`master`分支是一条线，Git用`master`指向最新的提交，再用`HEAD`指向`master`，就能确定当前分支，以及当前分支的提交点：\n\n![git-br-initial](https://i.loli.net/2020/09/25/dCUe7BbsTvw93ip.png)\n\n每次提交，`master`分支都会向前移动一步，这样，随着你不断提交，`master`分支的线也越来越长。\n\n？这条圆圈线就是仓库版本线\n\n当我们创建新的分支，例如`dev`时，Git新建了一个指针叫`dev`，指向`master`相同的提交，再把`HEAD`指向`dev`，就表示当前分支在`dev`上：\n\n![git-br-create](https://i.loli.net/2020/09/25/7lV1FsgO2HDdWqx.png)\n\n你看，Git创建一个分支很快，因为除了增加一个`dev`指针，改改`HEAD`的指向，工作区的文件都没有任何变化！\n\n不过，从现在开始，对工作区的修改和提交就是针对`dev`分支了，比如新提交一次后，`dev`指针往前移动一步，而`master`指针不变：\n\n![git-br-dev-fd](assets/l.png)\n\n假如我们在`dev`上的工作完成了，就可以把`dev`合并到`master`上。Git怎么合并呢？最简单的方法，就是直接把`master`指向`dev`的当前提交，就完成了合并：\n\n![git-br-ff-merge](https://i.loli.net/2020/09/25/k9XHoNQmR4UZf3F.png)\n\n所以Git合并分支也很快！就改改指针，工作区内容也不变！\n\n合并完分支后，甚至可以删除`dev`分支。删除`dev`分支就是把`dev`指针给删掉，删掉后，我们就剩下了一条`master`分支：\n\n![git-br-rm](https://i.loli.net/2020/09/25/LXUN45BQvqIeaVO.png)\n\n真是太神奇了，你看得出来有些提交是通过分支完成的吗？\n\n#### 分支实战\n\n下面开始实战。\n\n首先，我们创建`dev`分支，然后切换到`dev`分支：\n\n```shell\n$ git checkout -b dev\nSwitched to a new branch 'dev'\n```\n\n`git checkout`命令加上`-b`参数表示创建并切换，相当于以下两条命令：\n\n```shell\n$ git branch dev\n$ git checkout dev\nSwitched to branch 'dev'\n```\n\n然后，用`git branch`命令查看当前分支：\n\n```shell\n$ git branch\n* dev\n  master\n```\n\n`git branch`命令会列出所有分支，当前分支前面会标一个`*`号。\n\n然后，我们就可以在`dev`分支上正常提交，比如对`readme.txt`做个修改，加上一行：\n\n```\nCreating a new branch is quick.\n```\n\n然后提交：\n\n```shell\n$ git add readme.txt \n$ git commit -m \"branch test\"\n[dev b17d20e] branch test\n 1 file changed, 1 insertion(+)\n```\n\n现在，`dev`分支的工作完成，我们就可以切换回`master`分支：\n\n```shell\n$ git checkout master\nSwitched to branch 'master'\n```\n\n切换回`master`分支后，再查看一个`readme.txt`文件，刚才添加的内容不见了！因为那个提交是在`dev`分支上，而`master`分支此刻的提交点并没有变：\n\n![git-br-on-master](https://i.loli.net/2020/09/25/NdFYXhQEvcOe2bp.png)\n\n#### 合并分支到当前分支merge\n\n现在，我们把`dev`分支的工作成果合并到`master`分支上：\n\n```shell\n$ git merge dev\nUpdating d46f35e..b17d20e\nFast-forward\n readme.txt | 1 +\n 1 file changed, 1 insertion(+)\n```\n\n`git merge`命令用于合并指定分支到当前分支。合并后，再查看`readme.txt`的内容，就可以看到，和`dev`分支的最新提交是完全一样的。\n\n注意到上面的`Fast-forward`信息，Git告诉我们，这次合并是“快进模式”，也就是直接把`master`指向`dev`的当前提交，所以合并速度非常快。\n\n当然，也不是每次合并都能`Fast-forward`，我们后面会讲其他方式的合并。\n\n**删除分支**，合并完成后，就可以放心地删除`dev`分支了：\n\n```shell\n$ git branch -d dev\nDeleted branch dev (was b17d20e).\n```\n\n删除后，查看`branch`，就只剩下`master`分支了：\n\n```shell\n$ git branch\n* master\n```\n\n因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在`master`分支上工作效果是一样的，但过程更安全。\n\n#### 新分支的文件\n\n新分支的初始文件默认是在创建时基于的原来的分支基础上的，若要让新分支为空，直接在新分支下删除所有文件并提交，这样新分支就是空了。\n\n#### 用switch切换分支\n\n我们注意到切换分支使用`git checkout `，而前面讲过的撤销修改则是`git checkout -- `，同一个命令，有两种作用，确实有点令人迷惑。\n\n实际上，切换分支这个动作，用`switch`更科学。因此，最新版本的Git提供了新的`git switch`命令来切换分支：\n\n创建并切换到新的`dev`分支，可以使用：\n\n```shell\n$ git switch -c dev\n```\n\n直接切换到已有的`master`分支，可以使用：\n\n```shell\n$ git switch master\n```\n\n使用新的`git switch`命令，比`git checkout`要更容易理解。\n\n#### 小结\n\nGit鼓励大量使用分支：\n\n查看分支：`git branch`\n\n创建分支：`git branch `\n\n切换分支：`git checkout `或者`git switch `\n\n创建+切换分支：`git checkout -b `或者`git switch -c `\n\n合并某分支到当前分支：`git merge `\n\n删除分支：`git branch -d `\n\n### 解决冲突\n\n人生不如意之事十之八九，合并分支往往也不是一帆风顺的。\n\n准备新的`feature1`分支，继续我们的新分支开发：\n\n```shell\n$ git switch -c feature1\nSwitched to a new branch 'feature1'\n```\n\n修改`readme.txt`最后一行，改为：\n\n```shell\nCreating a new branch is quick AND simple.\n```\n\n在`feature1`分支上提交：\n\n```shell\n$ git add readme.txt\n\n$ git commit -m \"AND simple\"\n[feature1 14096d0] AND simple\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n切换到`master`分支：\n\n```shell\n$ git switch master\nSwitched to branch 'master'\nYour branch is ahead of 'origin/master' by 1 commit.\n  (use \"git push\" to publish your local commits)\n```\n\nGit还会自动提示我们当前`master`分支比远程的`master`分支要超前1个提交。\n\n在`master`分支上把`readme.txt`文件的最后一行改为：\n\n```shell\nCreating a new branch is quick & simple.\n```\n\n提交：\n\n```shell\n$ git add readme.txt \n$ git commit -m \"& simple\"\n[master 5dc6824] & simple\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n现在，`master`分支和`feature1`分支各自都分别有新的提交，变成了这样：\n\n![git-br-feature1](https://i.loli.net/2020/09/25/1JpdcNOH9VaMqsg.png)\n\n这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：\n\n```shell\n$ git merge feature1\nAuto-merging readme.txt\nCONFLICT (content): Merge conflict in readme.txt\nAutomatic merge failed; fix conflicts and then commit the result.\n```\n\n果然冲突了！Git告诉我们，`readme.txt`文件存在冲突，必须手动解决冲突后再提交。`git status`也可以告诉我们冲突的文件：\n\n```powershell\n$ git status\nOn branch master\nYour branch is ahead of 'origin/master' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\nYou have unmerged paths.\n  (fix conflicts and run \"git commit\")\n  (use \"git merge --abort\" to abort the merge)\n\nUnmerged paths:\n  (use \"git add <file>...\" to mark resolution)\n\n\tboth modified:   readme.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\n我们可以直接查看readme.txt的内容：\n\n```shell\nGit is a distributed version control system.\nGit is free software distributed under the GPL.\nGit has a mutable index called stage.\nGit tracks changes of files.\n<<<<<<< HEAD\nCreating a new branch is quick & simple.\n=======\nCreating a new branch is quick AND simple.\n>>>>>>> feature1\n```\n\nGit用`<<<<<<<`，`=======`，`>>>>>>>`标记出不同分支的内容，我们修改如下后保存：\n\n```\nCreating a new branch is quick and simple.\n```\n\n再提交：\n\n```shell\n$ git add readme.txt \n$ git commit -m \"conflict fixed\"\n[master cf810e4] conflict fixed\n```\n\n现在，`master`分支和`feature1`分支变成了下图所示：\n\n![git-br-conflict-merged](https://i.loli.net/2020/09/25/GVUhwe5PIapzmBn.png)\n\n用带参数的`git log`也可以看到分支的合并情况：\n\n```shell\n$ git log --graph --pretty=oneline --abbrev-commit\n*   cf810e4 (HEAD -> master) conflict fixed\n|\\  \n| * 14096d0 (feature1) AND simple\n* | 5dc6824 & simple\n|/  \n* b17d20e branch test\n* d46f35e (origin/master) remove test.txt\n* b84166e add test.txt\n* 519219b git tracks changes\n* e43a48b understand how stage works\n* 1094adb append GPL\n* e475afc add distributed\n* eaadf4e wrote a readme file\n```\n\n最后，删除`feature1`分支：\n\n```shell\n$ git branch -d feature1\nDeleted branch feature1 (was 14096d0).\n```\n\n工作完成。\n\n#### 小结\n\n当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。\n\n解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。\n\n用`git log --graph`命令可以看到分支合并图。\n\n### 分支管理策略\n\n通常，合并分支时，如果可能，Git会用`Fast forward`模式，但这种模式下，删除分支后，会丢掉分支信息。\n\n如果要强制禁用`Fast forward`模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\n\n下面我们实战一下`--no-ff`方式的`git merge`：\n\n首先，仍然创建并切换`dev`分支：\n\n```shell\n$ git switch -c dev\nSwitched to a new branch 'dev'\n```\n\n修改readme.txt文件，并提交一个新的commit：\n\n```shell\n$ git add readme.txt \n$ git commit -m \"add merge\"\n[dev f52c633] add merge\n 1 file changed, 1 insertion(+)\n```\n\n现在，我们切换回`master`：\n\n```shell\n$ git switch master\nSwitched to branch 'master'\n```\n\n准备合并`dev`分支，请注意`--no-ff`参数，表示禁用`Fast forward`：\n\n```shell\n$ git merge --no-ff -m \"merge with no-ff\" dev\nMerge made by the 'recursive' strategy.\n readme.txt | 1 +\n 1 file changed, 1 insertion(+)\n```\n\n因为本次合并要创建一个新的commit，所以加上`-m`参数，把commit描述写进去。\n\n合并后，我们用`git log`看看分支历史：\n\n```\n$ git log --graph --pretty=oneline --abbrev-commit\n*   e1e9c68 (HEAD -> master) merge with no-ff\n|\\  \n| * f52c633 (dev) add merge\n|/  \n*   cf810e4 conflict fixed\n...\n```\n\n可以看到，不使用`Fast forward`模式，merge后就像这样：\n\n![git-no-ff-mode](https://i.loli.net/2020/09/25/tOYM2iskC5Pl3La.png)\n\n### Bug分支\n\n------\n\n软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。\n\n当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支`issue-101`来修复它，但是，等等，当前正在`dev`上进行的工作还没有提交：\n\n```shell\n$ git status\nOn branch dev\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n\tnew file:   hello.py\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   readme.txt\n```\n\n并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？\n\n幸好，Git还提供了一个`stash`功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：\n\n```shell\n$ git stash\nSaved working directory and index state WIP on dev: f52c633 add merge\n```\n\n现在，用`git status`查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。\n\n首先确定要在哪个分支上修复bug，假定需要在`master`分支上修复，就从`master`创建临时分支：\n\n```shell\n$ git checkout master\nSwitched to branch 'master'\nYour branch is ahead of 'origin/master' by 6 commits.\n  (use \"git push\" to publish your local commits)\n\n$ git checkout -b issue-101\nSwitched to a new branch 'issue-101'\n```\n\n现在修复bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交：\n\n```shell\n$ git add readme.txt \n$ git commit -m \"fix bug 101\"\n[issue-101 4c805e2] fix bug 101\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n修复完成后，切换到`master`分支，并完成合并，最后删除`issue-101`分支：\n\n```shell\n$ git switch master\nSwitched to branch 'master'\nYour branch is ahead of 'origin/master' by 6 commits.\n  (use \"git push\" to publish your local commits)\n\n$ git merge --no-ff -m \"merged bug fix 101\" issue-101\nMerge made by the 'recursive' strategy.\n readme.txt | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到`dev`分支干活了！\n\n```\n$ git switch dev\nSwitched to branch 'dev'\n\n$ git status\nOn branch dev\nnothing to commit, working tree clean\n```\n\n工作区是干净的，刚才的工作现场存到哪去了？用`git stash list`命令看看：\n\n```shell\n$ git stash list\nstash@{0}: WIP on dev: f52c633 add merge\n```\n\n工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：\n\n一是用`git stash apply`恢复，但是恢复后，stash内容并不删除，你需要用`git stash drop`来删除；\n\n另一种方式是用`git stash pop`，恢复的同时把stash内容也删了：\n\n```shell\n$ git stash pop\nOn branch dev\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n\tnew file:   hello.py\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   readme.txt\n\nDropped refs/stash@{0} (5d677e2ee266f39ea296182fb2354265b91b3b2a)\n```\n\n再用`git stash list`查看，就看不到任何stash内容了：\n\n```shell\n$ git stash list\n```\n\n你可以多次stash，恢复的时候，先用`git stash list`查看，然后恢复指定的stash，用命令：\n\n```shell\n$ git stash apply stash@{0}\n```\n\n\n\n在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。\n\n那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？\n\n有木有更简单的方法？\n\n有！\n\n同样的bug，要在dev上修复，我们只需要把`4c805e2 fix bug 101`这个提交所做的修改“复制”到dev分支。注意：我们只想复制`4c805e2 fix bug 101`这个提交所做的修改，并不是把整个master分支merge过来。\n\n为了方便操作，Git专门提供了一个`cherry-pick`命令，让我们能复制一个特定的提交到当前分支：\n\n```shell\n$ git branch\n* dev\n  master\n$ git cherry-pick 4c805e2\n[master 1d4b803] fix bug 101\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\nGit自动给dev分支做了一次提交，注意这次提交的commit是`1d4b803`，它并不同于master的`4c805e2`，因为这两个commit只是改动相同，但确实是两个不同的commit。用`git cherry-pick`，我们就不需要在dev分支上手动再把修bug的过程重复一遍。\n\n有些聪明的童鞋会想了，既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要`git stash`命令保存现场，才能从dev分支切换到master分支。\n\n#### 小结\n\n修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\n\n当手头工作没有完成时，先把工作现场`git stash`一下，然后去修复bug，修复后，再`git stash pop`，回到工作现场；\n\n在master分支上修复的bug，想要合并到当前dev分支，可以用`git cherry-pick `命令，把bug提交的修改“复制”到当前分支，避免重复劳动。\n\n### Feature分支\n\n------\n\n软件开发中，总有无穷无尽的新的功能要不断添加进来。\n\n添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。\n\n现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。\n\n于是准备开发：\n\n```shell\n$ git switch -c feature-vulcan\nSwitched to a new branch 'feature-vulcan'\n```\n\n5分钟后，开发完毕：\n\n```\n$ git add vulcan.py\n\n$ git status\nOn branch feature-vulcan\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n\tnew file:   vulcan.py\n\n$ git commit -m \"add feature vulcan\"\n[feature-vulcan 287773e] add feature vulcan\n 1 file changed, 2 insertions(+)\n create mode 100644 vulcan.py\n```\n\n切回`dev`，准备合并：\n\n```shell\n$ git switch dev\n```\n\n一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。\n\n但是！\n\n就在此时，接到上级命令，因经费不足，新功能必须取消！\n\n虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：\n\n```shell\n$ git branch -d feature-vulcan\nerror: The branch 'feature-vulcan' is not fully merged.\nIf you are sure you want to delete it, run 'git branch -D feature-vulcan'.\n```\n\n销毁失败。Git友情提醒，`feature-vulcan`分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的`-D`参数。。\n\n现在我们强行删除：\n\n```shell\n$ git branch -D feature-vulcan\nDeleted branch feature-vulcan (was 287773e).\n```\n\n终于删除成功！\n\n#### 小结\n\n开发一个新feature，最好新建一个分支；\n\n如果要丢弃一个没有被合并过的分支，可以通过`git branch -D `强行删除。\n\n\n\n### 多人协作\n\n------\n\n当你从远程仓库克隆时，实际上Git自动把本地的`master`分支和远程的`master`分支对应起来了，并且，远程仓库的默认名称是`origin`。\n\n要查看远程库的信息，用`git remote`：\n\n```shell\n$ git remote\norigin\n```\n\n或者，用`git remote -v`显示更详细的信息：\n\n```shell\n$ git remote -v\norigin  git@github.com:michaelliao/learngit.git (fetch)\norigin  git@github.com:michaelliao/learngit.git (push)\n```\n\n上面显示了可以抓取和推送的`origin`的地址。如果没有推送权限，就看不到push的地址。\n\n#### 推送分支\n\n推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：\n\n```shell\n$ git push origin master\n```\n\n如果要推送其他分支，比如`dev`，就改成：\n\n```shell\n$ git push origin dev\n```\n\n但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？\n\n- `master`分支是主分支，因此要时刻与远程同步；\n- `dev`分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；\n- bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；\n- feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。\n\n总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！\n\n#### 抓取分支\n\n多人协作时，大家都会往`master`和`dev`分支上推送各自的修改。\n\n现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：\n\n```shell\n$ git clone git@github.com:michaelliao/learngit.git\nCloning into 'learngit'...\nremote: Counting objects: 40, done.\nremote: Compressing objects: 100% (21/21), done.\nremote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0\nReceiving objects: 100% (40/40), done.\nResolving deltas: 100% (14/14), done.\n```\n\n当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的`master`分支。不信可以用`git branch`命令看看：\n\n```shell\n$ git branch\n* master\n```\n\n现在，你的小伙伴要在`dev`分支上开发，就必须创建远程`origin`的`dev`分支到本地，于是他用这个命令创建本地`dev`分支：\n\n**命令表明创建远程`origin`的`dev`分支到本地,如果要pull还需建立链接(下文)**\n\n```shell\n$ git checkout -b dev origin/dev\n```\n\n现在，他就可以在`dev`上继续修改，然后，时不时地把`dev`分支`push`到远程：\n\n```shell\n$ git add env.txt\n\n$ git commit -m \"add env\"\n[dev 7a5e5dd] add env\n 1 file changed, 1 insertion(+)\n create mode 100644 env.txt\n\n$ git push origin dev\nCounting objects: 3, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (2/2), done.\nWriting objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nTo github.com:michaelliao/learngit.git\n   f52c633..7a5e5dd  dev -> dev\n```\n\n\n\n你的小伙伴已经向`origin/dev`分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：\n\n```shell\n$ cat env.txt\nenv\n\n$ git add env.txt\n\n$ git commit -m \"add new env\"\n[dev 7bd91f1] add new env\n 1 file changed, 1 insertion(+)\n create mode 100644 env.txt\n\n$ git push origin dev\nTo github.com:michaelliao/learngit.git\n ! [rejected]        dev -> dev (non-fast-forward)\nerror: failed to push some refs to 'git@github.com:michaelliao/learngit.git'\nhint: Updates were rejected because the tip of your current branch is behind\nhint: its remote counterpart. Integrate the remote changes (e.g.\nhint: 'git pull ...') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\n```\n\n推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用`git pull`把最新的提交从`origin/dev`抓下来，然后，在本地合并，解决冲突，再推送：\n\n```shell\n$ git pull\nThere is no tracking information for the current branch.\nPlease specify which branch you want to merge with.\nSee git-pull(1) for details.\n\n    git pull <remote> <branch>\n\nIf you wish to set tracking information for this branch you can do so with:\n\n    git branch --set-upstream-to=origin/<branch> dev\n```\n\n`git pull`也失败了，**原因是没有指定本地`dev`分支与远程`origin/dev`分支的链接**，根据提示，设置`dev`和`origin/dev`的链接：\n\n```shell\n$ git branch --set-upstream-to=origin/dev dev\nBranch 'dev' set up to track remote branch 'dev' from 'origin'.\n```\n\n再pull：\n\n```shell\n$ git pull\nAuto-merging env.txt\nCONFLICT (add/add): Merge conflict in env.txt\nAutomatic merge failed; fix conflicts and then commit the result.\n```\n\n这回`git pull`成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的[解决冲突](http://www.liaoxuefeng.com/wiki/896043488029600/900004111093344)完全一样。解决后，提交，再push：\n\n```shell\n$ git commit -m \"fix env conflict\"\n[dev 57c53ab] fix env conflict\n\n$ git push origin dev\nCounting objects: 6, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (4/4), done.\nWriting objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.\nTotal 6 (delta 0), reused 0 (delta 0)\nTo github.com:michaelliao/learngit.git\n   7a5e5dd..57c53ab  dev -> dev\n```\n\n\n\n因此，多人协作的工作模式通常是这样：\n\n1. 首先，可以试图用`git push origin `推送自己的修改；\n2. 如果推送失败，则因为远程分支比你的本地更新，需要先用`git pull`试图合并；\n3. 如果合并有冲突，则解决冲突，并在本地提交；\n4. 没有冲突或者解决掉冲突后，再用`git push origin `推送就能成功！\n\n如果`git pull`提示`no tracking information`，则说明本地分支和远程分支的链接关系没有创建，用命令`git branch --set-upstream-to  origin/`。\n\n这就是多人协作的工作模式，一旦熟悉了，就非常简单。\n\n#### 小结\n\n- 查看远程库信息，使用`git remote -v`；\n- 本地新建的分支如果不推送到远程，对其他人就是不可见的；\n- 从本地推送分支，使用`git push origin branch-name`，如果推送失败，先用`git pull`抓取远程的新提交；\n- 在本地创建和远程分支对应的分支，使用`git checkout -b branch-name origin/branch-name`，本地和远程分支的名称最好一致；\n- 建立本地分支和远程分支的关联，使用`git branch --set-upstream branch-name origin/branch-name`；\n- 从远程抓取分支，使用`git pull`，如果有冲突，要先处理冲突。\n\n### 远程分支\n\n查看一下现在的分支状态:\n\n```shell\n$ git branch\n* dbg_lichen_star\n  master\n  release\n```\n\n星号(*)表示当前所在分支。现在的状态是成功创建的新的分支并且已经切换到新分支上。\n\n**创建远程分支**\n\n把新建的本地分支push到远程服务器，远程分支与本地分支同名（当然可以随意起名）：\n\n```shell\n$ git push origin dbg_lichen_star:dbg_lichen_star\n$ git push learnGit-https dev\n```\n\n\n使用`git branch -a`查看所有分支，会看到`remotes/origin/dbg_lichen_star`这个远程分支，说明新建远程分支成功。\n\n**删除远程分支**\n我比较喜欢的简单方式，推送一个空分支到远程分支，其实就相当于删除远程分支：\n\n```shell\n$ git push origin :dbg_lichen_star\n```\n\n\n也可以使用：\n\n```shell\n$ git push origin --delete dbg_lichen_star\n```\n\n\n这两种方式都可以删除指定的远程分支","tags":["git"]},{"title":"JAVA制作包","url":"/2020/09/24/JAVA_build_package/","content":"\n\n\n## 将自己的java库打包成.jar并供给调用\n\n以改良print工程为例.\n\n### build package\n\n**编写**\n\n在文件夹下建立自己的java库存放的文件夹`./mypackage`\n\n在`./mypackge`下分别写自己的库函数和类等。\n\n```java\n// ./mypackage/myprint.java\npackage mypackage;\npublic class myprint{\n    public static void println(String args){\n        System.out.println(args);\n    }\n}\n```\n\n`package mypackage`表示该编译单元是名为`mypackage`的类库的一部分，以后打包之后若其他程序想要import并调用此包必须通过`import mypackge.{xx.}*`来实现，若类在`./mypackage/branch1`下，则要改写为\n\n```java\npackage mypackage.branch1;\n```\n\n用`.`表示一级目录.\n\n<!-- more -->\n\n**编译**\n\n在类目录下通过`javac {yourfilename}.java`进行编译,生成`.class`文件等\n\n**打包**\n\n回到`mypackage`的同级目录下对`mypackage`打包，打包成`.jar`文件，jar命令详解可参考：https://www.cnblogs.com/chenjfblog/p/10164967.html\n\n命令`jar cvf {youjarname}.jar mypackage(你的包目录)`\n\n生成的`.jar`作为包，加入java虚拟机的`classpath`中,为防止污染,`classpath`可在每次启动`java`时选定，参考https://www.liaoxuefeng.com/wiki/1252599548343744/1260466914339296\n\n默认的`classpath`是`.\\`表示当前路径，可以把`-cp`写为`-cp .; {...};`，一般最好是加上`.;`再加自己指定的其他路径，应该先应该把当前路径算上。\n\n**利用jar包运行.java程序**\n\n假设打包文件名`myprint.jar`，现在编写`testPack.java`程序\n\n```java\nimport mypackage.*;\npublic class testPack{\n    public static void main(String[]args){\n        myprint  printtest=new myprint();\n        printtest.println(\"Hello World!\");\n    }\n}\n```\n\n把`.jar,.java`放到同一目录下，运行命令：\n\n`java -cp \".\\myprint.jar\" testPack.java`\n\n最好是加上`;`号\n\n`java -cp \".\\How2J\\JAR\\property.jar;\" Test.java`\n\n即可.\n\n不编译直接运行，如果`.jar`在其他地方，设置绝对路径即可：\n\n` java -cp \"D:\\mytool.jar[;]\" .\\HelloWorld.java`\n\n如果编译再运行\n\n`javac -cp \".\\How2J\\JAR\\property.jar;\" Test.java`\n\n编译后的`.class`运行方式是\n\n`java -cp \".\\How2J\\JAR\\property.jar;\" Test`\n\n```\n├─CSApp\n├─ThinkingInJava\n│  ├─chapter1-ObjectIntroduction\n│  ├─chapter2-EverythingIsObject\n│  │  └─Documentation\n│  │      ├─1\n│  │      ├─2\n│  │      └─3\n│  └─chapter3-Operators\n├─LeetCode笔记\n│  ├─assets\n│  └─code\n├─CLRS\n├─dataStructure\n└─How2J\n    ├─InterfaceANDentends\n    │  ├─charactor\n    │  └─property\n    ├─assets\n    ├─DT\n    │  └─property\n    └─JAR\n```\n\n对于.class文件来说，只需要指明包的路径即可；但是对于jar文件来说，必须要指定全路径即路径+文件名的格式，不能只指定一个路径","tags":["java"]},{"title":"GCC 编译命令","url":"/2020/09/24/HowtoUseGCC/","content":"\n## 编译命令\n\n```shell\ngcc  -{...}  -o -{outputfilename} - {....}\n```\n\n`-o`参数是用来指定输出文件名称的，默认是`a.out`，有多个参数时没有顺序要求.\n\n### 四个阶段\n\n`.c`文件转换为可执行文件在`gcc`下分为**预处理、编译、汇编、链接**4个阶段。\n\n注意`.c`文件可以根据参数直接进行到当前参数的阶段。\n\n<!-- more -->\n\n#### 预处理 -E\n\n根据文件所有`#`开头的命令，修改原程序，比如include头文件，把头文件内容加到当前文件对应位置，通常输出文件的扩展名是`.i`\n\n**预处理参数 -E (大写)**\n\n```shell\ngcc -E  file.c -o file.i\ngcc -E .\\helloworld.c -o hellloworld.i #windows10\n```\n\n要指定输出文件名，否则可能直接在shell中把文件打印出来而不生成`.i`文件\n\n#### 编译阶段 -S/s\n\n编译器将文本文件翻译成一个当前平台的汇编语言程序，文件扩展名一般是`.s`\n\n**编译参数 -S/s**\n\n并不要求当前的输入文件是预处理的`.i`，也可以从`.c`直接进行\n\n```shell\ngcc -S file.? -o file.s\ngcc -S .\\helloworld.c -o hellloworld.s\ngcc -S .\\helloworld.i -o helloworld.s\n```\n\n#### 汇编阶段 -C/c\n\n汇编器将`.s`的汇编语言文件程序翻译成机器语言的指令文件，并打包成一个**可重定位目标程序**，生成的文件扩展名是`.o`，这是一个二进制文件，`.o`文件可以供其他`.o`程序连接\n\n**汇编参数 -C/c**\n\n```shell\ngcc -c file.? -o file.o\ngcc -c .\\helloworld.i -o helloworld.o\ngcc -c .\\helloworld.c -o helloworld.o\n#...\n```\n\n#### 链接阶段\n\n在编译过程中，除非使用了`-E、-S、-C`选项（或者编译出错阻止了完整的编译过程）否则最后的步骤都是链接。\n\n直接使用`gcc`即可，事实上如果不加以上参数，`gcc`会直接把`.c`执行到这一阶段生成可执行文件，但是注意如果需要和额外的`.o`文件链接需要在命令中写明.\n\n```shell\ngcc -o helloworld helloworld.c\nPS F:\\MyNotes\\GCC_make> .\\helloworld.exe\n> hello world!\ngcc -o helloworld helloworld.o\n```\n\n貌似不能用`.s`的汇编语言文件作为输入\n\n\n\n#### 多文件编译\n\n编译只需要将`.c`文件作为输入\n\n**分开编译**\n\n注意`.o`文件仍然是不可执行的，需要和依赖的其他`.o`进行链接，如果已经生成了其他的依赖的第三方`.o`，可以用\n\n```shell\ng++ .\\main.o .\\compute.o .\\setProperty.o -o test\n```\n\n生成可执行的`test`文件，这样只有修改了的文件才会重新冲重新汇编成`.o`\n\n也可以把所有`.c/.cpp`一起编译\n\n```shell\ng++ -o test .\\compute.cpp .\\main.cpp .\\setProperty.cpp\n```\n\n但是可能会出错。\n\n\n\n#### 链接到外部库\n\n` -L` 指定库的路径 `-l` 指定需连接的库名 `-I`指定第一个头文件目录\n\n```shell\ngcc -o hello hello.c -I /home/hello/include -L /home/hello/lib -lworld\n```\n\n上面这句表示在编译`hello.c`时：\n\n\n\n大写`I`: `-I /home/hello/include`表示将`/home/hello/include`目录作为第一个寻找头文件的目录，寻找的顺序是：`/home/hello/include-->/usr/include-->/usr/local/include`\n\n\n\n就拿数学库来说，他的库名是m，他的库文件名是libm.so，很容易看出，把库文件名的头`lib`和尾`.so`去掉就是库名了。\n\n**.so和.a**\n\n动态库(.so)\n\n静态库(.a) \n\n静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库。编译之后程序文件大，但加载快，隔离性也好。 动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在。多个应用程序可以使用同一个动态库，启动多个应用程序的时候，只需要将动态库加载到内存一次即可。\n\n\n\n好了现在我们知道怎么得到库名了，比如我们自已要用到一个第三方提供的库名字叫libtest.so，那么我们只要把libtest.so拷贝到`/usr/lib`里，编译时加上`-l test`参数，我们就能用上libtest.so库了（当然要用libtest.so库里的函数，我们还需要与libtest.so配套的头文件）。\n\n**不在主目录里**\n\n放在`/lib`和`/usr/lib`和`/usr/local/lib`里的库直接用-`l`参数就能链接了，但如果库文件没放在这三个目录里，而是放在其他目录里，这时我们只用`-l`参数的话，链接还是会出错，出错信息大概是：`“/usr/bin/ld: cannot find -lxxx”`，也就是链接程序**ld**在那3个目录里找不到`libxxx.so`\n\n这时另外一个参数`-L`就派上用场了，比如常用的`X11`的库，它放在`/usr/X11R6/lib`目录下，我们编译时就要用`-L /usr/X11R6/lib` `-l X11`参数，-L参数跟着的是库文件所在的目录名。\n\n再比如我们把`libtest.so`放在`/aaa/bbb/ccc`目录下，那链接参数就是`-L /aaa/bbb/ccc -l test`\n\n\n\n#### 安装apue.h   （静态库.a）\n\n1. 下载: `[src.3e.tar.gz](http://www.apuebook.com/src.3e.tar.gz)`\n2. 解压:` tar xvf src.3e.tar.gz`\n3. 安装相应库:` sudo apt-get install libbsd-dev`\n4. 进入到apue.3e目录，执行: make\n5. `cp ./include/apue.h  /usr/include/`\n6. `cp ./lib/libapue.a  /usr/local/lib/`\n7. 编译时链接到相应库: `gcc -o 1-3 1-3.c -l apue`，这里把`.h .a`都放到了`/use/local`下，不需要`-L`\n\n命令`cp`即copy，\n\n```\ncp [options] source dest\n```\n\n","tags":["C","C++","GCC"]},{"title":"Hello World","url":"/2020/09/24/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n#### command\n\n```bash\n$ hexo clean\n$ hexo g\n$ hexo d\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","tags":["Help"]}]