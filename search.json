[{"title":"vscode头文件路径配置","url":"/2021/10/16/vscode_headfile/","content":"\n## vscode头文件路径\n\n```json\n{\n    \"configurations\": [\n        {\n            \"name\": \"Linux\",\n            \"includePath\": [\n                \"${default}\",\n                \"${workspaceFolder}\",\n                \"${workspaceFolder}/**\",\n                \"${workspaceFolder}/src\",\n                \"${workspaceFolder}/deps\",\n                \"${workspaceFolder}/src/observer\"\n            ],\n            \"compilerPath\": \"/usr/bin/gcc\",\n            \"cStandard\": \"gnu17\",\n            \"intelliSenseMode\": \"linux-gcc-x64\"\n        }\n    ],\n    \"version\": 4\n}\n```\n\n/* 是拦截所有的文件夹，不包含子文件夹\n/** 是拦截所有的文件夹及里面的子文件夹\n\n\n\n相当于/*只有后面一级\n\n/** 可以包含多级","tags":["C","C++"]},{"title":"Centos 7安装并配置OpenVPN","url":"/2021/10/07/CentOS_OpenVPN/","content":"\n## 1 安装OpenVPN\n\n开启`epel`源，并采用`yum`的方式安装`openvpn`：\n\n```bash\n$ yum install -y epel-release\n$ yum update -y\n$ yum install -y openssl lzo pam openssl-devel lzo-devel pam-devel\n$ yum install -y easy-rsa\n$ yum install -y openvpn\n```\n\n## 2 配置OpenVPN服务器\n\n### 2.1 创建配置过程中需要使用的目录\n\n1. 创建日志存放目录：`mkdir -p /var/log/openvpn/`\n2. 创建用户管理目录：`mkdir -p /etc/openvpn/server/user`\n3. 配置目录权限：`chown openvpn:openvpn /var/log/openvpn`\n\n### 2.2 生成证书\n\n通过`yum`方式安装的`easy-rsa`是3.x版本，可直接从安装目录中拷贝一份工具到`/etc/openvpn`中\n\n```bash\n$ cp -rf /usr/share/easy-rsa/3.0.8 /etc/openvpn/server/easy-rsa\n```\n\n#### 2.2.1 为服务器端创建证书\n\n1. 切换至`/etc/openvpn/server/easy-rsa`目录\n\n2. 使用命令`./easyrsa init-pki`进行初始化，会在当前目录创建PKI目录，用来存储一些中间变量和最终生成的证书\n\n3. 使用命令`./easyrsa build-ca nopass`创建证书\n\n4. 生成服务器端证书：`./easyrsa build-server-full server nopass`\n\n5. 创建Diffie-Hellman：`./easyrsa gen-dh`，确保key可以穿越不安全网络的命令\n\n6. 整理服务器端证书：\n\n   ```bash\n   $ mkdir -p /etc/openvpn/server\n   $ cp -a pki/ca.crt /etc/openvpn/server/\n   $ cp -a pki/private/server.key /etc/openvpn/server\n   $ cp -a pki/issued/server.crt /etc/openvpn/server\n   $ cp -a pki/dh.pem /etc/openvpn/server\n   $ cp -a ta.key /etc/openvpn/server\n   ```\n\n#### 2.2.2 为客户端创建证书\n\n生成无密码的客户端证书：`./easyrsa build-client-full client nopass`\n生成带密码的客户端证书：`./easyrsa build-client-full yourown`，会提示让你输入密码，记住设置的密码，在连接OpenVPN服务端时会使用，可多次操作该步骤为多个用户创建证书\n\n\n#### 2.2.3 创建ta.key\n\n为了提高`OpenVPN`的安全性，可以创建`ta.key`：`openvpn --genkey --secret ta.key`，能够加强认证方式，防止攻击\n\n### 2.3 编辑配置文件\n\n1. 拷贝`sample.conf`到`/etc/openvpn`作为起始配置文件：`cp /usr/share/doc/openvpn-*/sample/sample-config-files/server.conf /etc/openvpn/server`\n2. 使用`vi /etc/openvpn/server.conf`命令编辑配置文件 (位置可能不一定是这里，可能是`/etc/openvpn/server/server.conf`)\n   1. 将25行修改为：`local 0.0.0.0`\n   2. 取消35行注释，修改效果：`proto tcp`\n   3. 注释36行，修改效果：`; proto udp`\n   4. 修改78行，设置ca.crt的路径：`ca /etc/openvpn/server/ca.crt`\n   5. 修改79行，设置server.crt的路径：`cert /etc/openvpn/server/server.crt`\n   6. 修改80行，设置server.key的路径：`key /etc/openvpn/server/server.key`\n   7. 修改85行，设置dh的路径：`dh /etc/openvpn/server/dh.pem`\n   8. 修改141行：`push \"route 10.10.10.0 255.255.255.0\"`\n   9. 修改244行：`tls-auth /etc/openvpn/server/ta.key 0`\n   10. 取消257行注释：`compress lz4-v2`\n   11. 取消258行注释：`push \"compress lz4-v2\"`\n   12. 取消274、275行注释\n   13. 取消296行注释，并修改日志文件地址：`log /var/log/openvpn.log`\n       注释315行\n   14. 其他配置内容保持默认即可\n\n## 3 启动OpenVPN并配置开机启动\n\n1. 使用命令`vi /usr/lib/systemd/system/openvpn-server\\@.service`编辑服务文件，修改`ExecStart`的值为`ExecStart=/usr/sbin/openvpn --status %t/openvpn-server/status-%i.log --status-version 2 --suppress-timestamps --config server.conf`\n2. 修改服务文件的名称`cp /usr/lib/systemd/system/openvpn-server\\@.service /usr/lib/systemd/system/openvpn-service.service`\n3. 启动OpenVPN：`systemctl start openvpn-service`\n4. 配置OpenVPN开机启动：`sysemctl enable openvpn-service`\n\n## 4 配置防火墙\n\n配置防火墙，开启1194端口：\n\n也可通过云服务WEB控制台\n\n```bash\n$ firewall-cmd --permanent --add-masquerade\n$ firewall-cmd --permanent --add-service=openvpn\n$ firewall-cmd --permanent --add-port=1194/tcp\n$ firewall-cmd --permanent --direct --passthrough ipv4 -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE\n$ firewall-cmd --reload\n```\n\n## 5 Windows客户端配置\n\n1. 从/etc/openvpn/server/easy-rsa拷贝ta.key文件\n\n2. 从/etc/openvpn/server/easy-rsa/pki/private拷贝客户端的.key文件，例如：jiaoxn.key\n\n3. 从/etc/openvpn/server/easy-rsa/pki/issued拷贝客户端的.crt文件，例如：jiaoxn.crt\n\n4. 从/etc/openvpn/server/easy-rsa/pki拷贝客户端的ca.crt文件\n\n5. Windows系统安装OpenVPN客户端后，打开配置文件夹（默认是：C:\\Program Files\\OpenVPN\\config），新建文件夹（例如：client），拷贝前面4个文件到新建的文件夹\n\n6. 在第5步新建的文件夹中，创建client.ovpn文件（文件名和文件夹名称一致），配置内容如下，其中yourown.crt、yourown.key替换成对应的文件名client\n\n   ```basj\n   dev tun\n   proto tcp\n   remote 192.168.1.70 1194\n   resolv-retry infinite\n   nobind\n   ;user nobody\n   ;group nobody\n   persist-key\n   persist-tun\n   ca ca.crt\n   cert yourown.crt\n   key yourown.key\n   remote-cert-tls server\n   tls-auth ta.key 1\n   cipher AES-256-CBC\n   compress lz4-v2\n   verb 3\n   ;mute 20\n   ```\n\n7. 右键`VPN`图标，选择刚刚配置的文件夹名称，点击“连接”\n\n## 8 NAT转发\n\n   （1）当你安装好了openvpn时候，他会提供一个server配置的文件例子，在/usr/share/doc/openvpn-2.3.2/sample/sample-config-files 下会有一个server.conf文件，我们将这个文件复制到/etc/openvpn\n\n   [root@along ~]# rpm -ql openvpn |grep server.conf\n\n   ![img](https://gitee.com/waldenth/blogimage/raw/master/img/1216496-20180123125125162-474273153.png)\n\n   [root@along ~]# cp /usr/share/doc/openvpn-2.4.4/sample/sample-config-files/server.conf /etc/openvpn\n\n   （2）修改配置文件\n\n   [root@along ~]# vim /etc/openvpn/server.conf\n\n   [root@along ~]# grep '^[^#|;]' /etc/openvpn/server.conf 修改的地方如下：\n\n   ```\n   local 0.0.0.0     #监听地址\n   port 1194     #监听端口\n   proto tcp     #监听协议\n   dev tun     #采用路由隧道模式\n   ca /etc/openvpn/ca.crt      #ca证书路径\n   cert /etc/openvpn/server.crt       #服务器证书\n   key /etc/openvpn/server.key  # This file should be kept secret 服务器秘钥\n   dh /etc/openvpn/dh.pem     #密钥交换协议文件\n   server 10.8.0.0 255.255.255.0     #给客户端分配地址池，注意：不能和VPN服务器内网网段有相同\n   ifconfig-pool-persist ipp.txt\n   push \"redirect-gateway def1 bypass-dhcp\"      #给网关\n   push \"dhcp-option DNS 8.8.8.8\"        #dhcp分配dns\n   client-to-client       #客户端之间互相通信\n   keepalive 10 120       #存活时间，10秒ping一次,120 如未收到响应则视为断线\n   comp-lzo      #传输数据压缩\n   max-clients 100     #最多允许 100 客户端连接\n   user openvpn       #用户\n   group openvpn      #用户组\n   persist-key\n   persist-tun\n   status /var/log/openvpn/openvpn-status.log\n   log         /var/log/openvpn/openvpn.log\n   verb 3\n   ```\n\n   每个项目都会由一大堆介绍,上述修改，openvpn提供的server.conf已经全部提供，我们只需要去掉前面的注释#，然后修改我们自己的有关配置\n\n   （3）配置后的设置\n\n   [root@along ~]# mkdir /var/log/openvpn\n\n   [root@along ~]# chown -R openvpn.openvpn /var/log/openvpn/\n\n   [root@along ~]# chown -R openvpn.openvpn /etc/openvpn/*\n\n​    \n\n## 9 iptables 设置nat 规则和打开路由转发\n\n   [root@along ~]# iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -j MASQUERADE (?)\n\n   **iptables -t nat -A POSTROUTING -s 192.168.19.0/24 -o eth0 -j MASQUERADE**\n\n   [root@along ~]# iptables -vnL -t nat\n\n   [root@along ~]# vim /etc/sysctl.conf //打开路由转发\n\n   net.ipv4.ip_forward = 1\n\n   [root@along ~]# sysctl -p\n\n​    **删除1号转发规则**\n\n`iptables -t nat  -D POSTROUTING  1`\n\n​\t开启openvpn 服务\n\n   [root@along ~]# openvpn /etc/openvpn/server.conf 开启服务\n\n   [root@along ~]# ss -nutl |grep 1194\n\n   ![img](https://gitee.com/waldenth/blogimage/raw/master/img/1216496-20180123125125350-1344086972.png)\n\n   如果开启后没有打开1194 端口，说明开启服务失败，可能是配置文件有错，也有可能是权限不够，自己查询日志解决。\n\n  \n\n## 10 ping通但是无法http\n\n该问题乍一看以为是openssh 问题和Openvpn自身的问题。ping能通说明网络是通的，我们快速判断问题就需要用到tcpdump抓包工具了。从如下截图看是服务器自身不回包，所以问题原因发生在服务器自身。\n\n![下载](https://gitee.com/waldenth/blogimage/raw/master/img/%E4%B8%8B%E8%BD%BD.jpg)\n\n### 10.2 防火墙问题，关闭防火墙在测试发现问题依旧存在。\n\n```\nsystemctl stop firewalld\n```\n\n### 10.3 selinux问题，检查selinux相关设置。\n\n```\n[root@app1-192-168-10-80 ~]# setenforce 0\n[root@app1-192-168-10-80 ~]# getenforce \nDisabled\n```\n\n如上都操作后发现问题依然，这就不能忍了，必须得上百度下或者谷歌了。\n\n### 问题原因\n\n原理：问题出在了 tcp 三次握手，ping 的通 icmp ok ，http ssh mysql 都不 ok。经过nat之后，如果前面相同的端口被使用过，且时间戳大于这个链接发出的syn中的时间戳，服务器上就会忽略掉这个syn，不返会syn-ack消息，表现为用户无法正常完成tcp3次握手，从而不能打开web页面。在业务闲时，如果用户nat的端口没有被使用过时，就可以正常打开；业务忙时，nat端口重复使用的频率高，很难分到没有被使用的端口，从而产生这种问题。\n\n只有客户端和服务端都开启时间戳的情况下，才会出现能ping通不能建立tcp三次握手的情况\n\n#### 问题解决办法\n\n修改 /etc/sysctl.conf 中的如下两个配置，在测试就可以正常访问了。\n\n```\nnet.ipv4.tcp_timestamps = 0\nnet.ipv4.tcp_tw_recycle = 0\n```\n\nsysctl -p 生效\n\n### TCP不行就换UDP吧\n\n无语了\n\n **附：如上功能在什么环境下会用到。**\n\n```\n今天用php连接最近新开发的一个服务做测试，发现命令行打印出：Cannot assign requested address\n\n网上找了下原因，大致上是由于客户端频繁的连服务器，由于每次连接都在很短的时间内结束，导致很多的TIME_WAIT，以至于用光了可用的端 口号，所以新的连接没办法绑定端口，即“Cannot assign requested address”。是客户端的问题不是服务器端的问题。通过netstat，的确看到很多TIME_WAIT状态的连接。\n\nclient端频繁建立连接，而端口释放较慢，导致建立新连接时无可用端口。\n\n网上的解决方法：\n\n执行命令修改如下2个内核参数 （需要root权限） \nsysctl -w net.ipv4.tcp_timestamps=1  开启对于TCP时间戳的支持,若该项设置为0，则下面一项设置不起作用\nsysctl -w net.ipv4.tcp_tw_recycle=1  表示开启TCP连接中TIME-WAIT sockets的快速回收\n```","tags":["Linux"]},{"title":"CMU15-721-Lecture02笔记","url":"/2021/10/05/CMU15-721-Lec02-In-Memory-Databases/","content":"## Lec-02 In-memory Databases \n\n[video](https://www.bilibili.com/video/BV1Y7411o7GN?p=2)\n\n## Disk-oriented DBMS(面向磁盘的数据库)\n\n- 数据主要是在**非易失性存储器**中(HDD,SSD),以页或者帧(Page or Frame)为单位做存储\n\n- 使用在内存中的**缓存池(Buffer Pool)**来将磁盘数据导入内存并在内存中处理，缓存来自磁盘的page\n\n- **槽(slot)** , 数据库的数据存储结构是通过表空间（table space）->段(segment)->区（或者簇extends)->页（page)进行管理, 其中页是最小管理单元，而数据库表的记录在页内保持有序的方法就是**槽(slot)管理**，以MySQL为例分析：\n\n  - Innodb是多条记录对应一个槽，而槽的作用就是用来在页面内进行数据搜索的，因为查找一条数据时，是用B+tree来保证通过树形结构找到一个记录所在的页，而在页内部真正找到这条记录是通过槽来完成的\n\n  - 在页内部，Innodb划分出一个区域比如10byte，作为槽的区域（当然槽的区域根据使用的大小是可以变化的），一个槽占用2byte。那么现在可以将这个槽看作是长度大小为5的数组。\n\n  - 当我们将一条数据记录写入数据库时，通过数据库的Innodb最终决定写入在这个页内。那么写在这个页的哪里呢？形象的理解就是这个页，就相当于一张A4纸；数据记录就是一条信息，我们写的时候就是从上到下，从左至右的方法去写。Innodb的写入方式基本上也是这样的写入方式，但是这其中有很多问题需要数据库去解决。其中就是写入后数据记录的顺序问题。\n\n  - 模拟数据的写入过程：\n    1.写入第1条记录1，该记录在页内偏移量为120，长度为100，则slot[0]=120;\n    2.写入第2条记录10，该记录在页内偏移量为220，长度为100，则slot[1]=220;\n    3.写入第3条记录5，该记录在页内偏移量为320，长度为100，此时需要移动slot的内容，则slot[1]=320;slot[2]=220;\n\n  - 这样通过 slot的有序性，就保证了写入页内的数据记录的有序性。上面说过，Innodb的槽是多条记录对应一个slot。对于innodb它页内记录通过双向链表相互联接。\n\n    - slot[0]=120对应记录1的偏移量，而记录1有指向记录2的指针，记录2有指向记录3的指针；\n    - slot[1]=420对应记录4的偏移量（这里假设每条记录长度为100），记录4有指向记录5的指针，记录5的指向记录6的指针\n    - 后面的槽依次类推。slot[2]管理7，8，9三条记录；slot[3]管理10，11，12三条记录；slot[4]管理13，14，15三条记录；\n\n<!-- more -->\n    \n\n### Buffer Pool Issue（缓冲池）\n\n由于引入了缓冲池，磁盘型DB完整过程如下：\n\n- 完整查询过程：\n\n  1.从数据库索引中查找对应记录的**Page ID**和**slot(数据库页的槽)**，如果索引的节点没有加载到内存中，需要从磁盘中加载\n\n  2.去页表中查询该Page是否已经加载到内存\n\n  3.如果没有的话，从磁盘中找到该页，并且复制到缓存池的一帧中(frame)\n\n  4.如果缓存池没有空的frame，则按一定替换原则evict某页(LRU,FIFO,CLOCK)，并且还要更新page table\n\n  5.如果page是dirty的即被修改过，就需要把对应修改后的内容写回磁盘中\n\n  ![image-20211005210919847](https://gitee.com/waldenth/blogimage/raw/master/img/image-20211005210919847.png)\n\n- 这种架构的坏处：\n\n  Every tuple access has to go through the buffer pool manager regardless of whether that data will always be in memory.\n\n  无论查询元组是否在内存中都需要去buffer pool中查找\n\n  \n\n### Concurrency Control Issue（并发控制）\n\n面向磁盘的数据库假定**在尝试访问没有加载到内存的数据的时候，事务会“stall(抛锚，熄火)”**\n\n当然系统为了提高性能会允许一个事务stall的时候同时执行其他事务，靠上锁来实现ACID。(原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）)\n\n锁存储在in-memory的一个hash-table，叫lock manager,避免锁数据被swap到磁盘上，**All the info about lock is in memory!**，所有关于锁的信息全部在内存中！\n\n\n\n### Logging & Recovery Issue （日志与恢复）\n\n- 事务提交前，把修改写入**Write-Ahead-Log(WAL)**，WAL包含undo log 和 redo log\n- 每一个log entry（日志项）包含事务修改前后数据的镜像\n- The DBMS flushes WAL pages to disk separately from corresponding modified database pages, so it takes extra work to keep track of what log record is responsible for what page，DBMS将WAL页面从相应的修改过的数据库页面分别刷新到磁盘，因此需要额外的工作来跟踪日志记录负责哪个页面\n- 在事务提交之前，必须将所有修改刷新到WAL。\n- 需要维护log record是负责哪一个page的信息（利用LSN Log Sequence Number）\n\n### 开销比较\n\n如果不考虑disk flushing,面向磁盘数据库开销主要花费在：\n\nBUFFER POOL 34%\n\nLATCHING 14% (隔离的是线程,保证并发线程操作临界资源的正确性)\n\nLOCKING 16% (隔离的是事务，一般锁住的是数据库的表，行)\n\nLOGGING 12% \n\nB-TREE KEYS 16% 索引查找时间\n\nCPU 7% \n\n## In-memory DBMS(面向内存的数据库)\n\n背景：DRAM的发展，价格和容量足以把整个数据库的数据都存储到内存中\n\n这时候磁盘IO不再是数据库性能的瓶颈,而需要考虑以下可以优化的性能瓶颈\n\n- Locking/Latching：\n\n  - lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。此外，lock，正如在大多数数据库中一样，是有死锁机制的。\n  - latch一般称为闩锁（轻量级锁），因为其要求锁定的时间必须非常短。\n\n  ![20201207103106902](https://gitee.com/waldenth/blogimage/raw/master/img/20201207103106902.png)\n\n- Cache-line misses，cache命中\n\n- Pointer chasing，指针追踪\n\n- Predicate evaluation，谓词运算\n\n- Data movement and copying，数据移动和复制\n\n- Networking ，网络通信\n\n因为所有数据都在内存中，因此不会存在脏页，也不需要维护undo log信息，也不需要LSN机制\n\n\n\n### 与面向磁盘数据库的一些不同\n\n- Data Organization\n\n  1.从索引Index中查找数据指针所在的Block ID与Offset\n\n  2.根据Block ID与Offset找到数据指针的内存地址,指针存储在Fixed-Length Data Blocks(固定长度数据块)中\n\n  3.根据这个64-bits指针去Variable-Length Data Blocks(可变长度数据块)去寻找真正的数据\n\n![微信截图_20200426204351](https://gitee.com/waldenth/blogimage/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200426204351.png)\n\n\n- Indexes\n\n  In-memory DBMS并不会记录索引的更新。数据库再重启时，当所有数据加载到内存之后直接在内存中重建这个索引。\n\n- Query Processing\n\n  由于数据都在内存中，随机访问的速度并不比顺序访问要差\n\n- Logging & Revocery\n\n  1.仍然需要维护WAL，即修改数据库之前,把修改记录写入WAL然后同步到内存中\n\n  2.使用组提交来提交WAL，分摊fsync系统调用的开销\n\n  3.也可以使用更轻量级的logging策略，只存储redo信息\n\n- Concurrency control——提供原子性与隔离性\n\n  在面向磁盘的数据库中，锁是存放在另外一个内存中的hash表，与数据记录本身是分开来存储的。因为记录是可能被swap到外存。\n\n  而在IMDB中，由于数据记录一直在内存中，不会swap到外存，因此可以把记录有关的锁的信息与记录一起保存。\n\n  所以尝试取锁的效率=尝试获得数据的效率\n\n  瓶颈在于：多个事务同时尝试访问某个数据，只有一个事务能抢到锁\n\n  如果用mutex实现的话性能太慢，建议用CAS来保证这里的同步\n\n### CAS\n\n```c++\n__sync_bool_compare_and_swap(&M, 20, 30);\n```\n\n当且仅当M地址代表的值等于20的时候，把M地址所在的值设为30。否则失败，因为不等于的话说明这个值肯定被别的线程修改了\n\n### 并发控制\n\n接下来的会详细讨论并发控制的一些策略：\n\n#### 悲观策略——2 PHASE LOCKING 两段锁协议\n\n操作数据之前一定先抢锁\n\n2PL解决死锁两种策略：\n\n- 1.死锁探测\n\n  维护一个队列，队列存放着拿着锁的事务，一个后台线程周期性扫这个队列的事务，看哪些事务在运行，哪些stall，这就可以找到发生死锁的事务。\n\n- 2.死锁预防\n\n  在分配锁之前看有没有其他事务已经拿到这把锁，如果这个事务拿不了锁：\n\n  1）等待\n\n  2）自杀\n\n  3）杀死另外一个拿锁的事务\n\n#### 乐观策略——Timestamp Ordering 时间戳排序\n\n操作数据不抢锁，事务提交的时候比较时间戳，以时间为序，按每个transaction的时间来排谁先执行\n\n参考资料：[CMU Database Systems - Timestamp Ordering Concurrency Control - fxjwind - 博客园 (cnblogs.com)](https://www.cnblogs.com/fxjwind/p/11114136.html)\n\n##### Basic T/O Protocol\n\n首先每个txn(事务，Transaction)需要有一个独一无二的timestamp，这个在单机很容易实现；其次，Timestamp必须是单调递增的，最后，不同的schema会选择在不同的时间给txn打上timestamp，可能是txn刚到的时候，也可能是txn执行完的时候。\n\n**txn是transaction的简写，ts为timestamp**\n\n每一个事务txn都会分配一个时间戳，每一个记录的头部维护上一次事务操作的时间戳。然后事务对时间戳进行操作的时候，比较现在事务的时间戳与记录头部当前的时间戳。\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/312753-20190626115738779-1763049586.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n以课程案列，首先，给每个object加上读时间戳和写时间戳，表示最后一次读写该对象的时间，如图，对象A,B分别加上读写时间戳，均为10000，然后对图中事务txn的每个读写操作进行时间戳比对\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/image-20211005214323198.png\" alt=\"image-20211005214323198\" style=\"zoom: 33%;\" />\n\n\n\n- 读Object操作：拿**当前事务ts**和**Object的写ts**比较，如果Object的写ts比较新，那么读需要abort，因为，你不能读一个未来的值\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/image-20211005214627964.png\" alt=\"image-20211005214627964\" style=\"zoom:50%;\" />\n\n可以看到，案例txn中READ(A)首先将本事务ts=10001对象A的写ts=10000比较，本txn的ts更新，因此READ(A)操作合法，并将对象A的读时间戳更新为$max(R-ts(A),ts(txn))$,这里将A读ts改为10001\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/312753-20190626120512358-23562664.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/image-20211005215134735.png\" alt=\"image-20211005215134735\" style=\"zoom: 50%;\" />\n\n写Object操作：要同时将本txn的ts和该对象的读、写ts进行比较，比较对象写是因为你不能用过去的值覆盖未来的值，比较对象读是因为如果有未来的txn读过这个值，你就不能再更新。**即事务txn的时间戳要大于对象的读和写时间戳才可以进行操作**，操作后，需要更新对象的写时间戳\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/image-20211005215251726.png\" alt=\"image-20211005215251726\" style=\"zoom:50%;\" />\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/312753-20190626120535298-1569553780.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n课程案例中，假设本txn在省略号部分处理其他事情，无读写操作，此时另一个时间戳为10005的txn进行了对对象A的写操作，A的写ts修改为10005，当本txn其他事情完成，继续后续另一个的WRITE(A)操作时：\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/image-20211005215739487.png\" alt=\"image-20211005215739487\" style=\"zoom:50%;\" />\n\n进行ts比较，此时txn ts=10001< Object A write ts=10005，操作不合法，事务无法提交，处理失败，回滚\n\n##### 乐观并发控制\n\n```\n1. Read Phase: Transaction’s copy tuples accessed to private work space to ensure repeatable reads, and\nkeep track of read/write sets.\n\n2. Validation Phase: When the transaction invokes COMMIT, the DBMS checks if it conflicts with other\ntransactions. Parallel validation means that each transaction must check the read/write set of other\ntransactions that are trying to validate at the same time. Each transaction has to acquire locks for its\nwrite set records in some global order. Original OCC uses serial validation.\nThe DBMS can proceed with the validation in two directions:\n? Backward Validation: Check whether the committing transaction intersects its read/write sets\nwith those of any transactions that have already committed.\n? Forward Validation: Check whether the committing transaction intersects its read/write sets with\nany active transactions that have not yet committed.\n\n3. Write Phase: The DBMS propagates the changes in the transactions write set to the database and\nmakes them visible to other transactions’ items. As each record is updated, the transaction releases\nthe lock acquired during the Validation Phase\n```\n\n具体可以参考slides的过程\n\n##### 时间戳的分配策略\n\n- 基于互斥量：并发性能低\n- 原子加操作:   CAS操作去维护一个全局计数器\n- 批量原子加操作\n- 硬件CLOCK:  Intel CPU only\n- 硬件计数器: 尚未有硬件实现\n\n#### 并发控制的性能瓶颈\n\n- Lock Thrashing 锁抖动\n\n  Each transaction waits longer to acquire locks, causing other transaction to wait longer to acquire\n  locks.\n\n  Can measure this phenomenon by removing deadlock detection/prevention overhead. \n\n  solution： force txns to acquire locks in primary key order\n\n- Memory Allocation 内存分配\n\n  Copying data on every read/write access slows down the DBMS because of contention on the memory\n  controller.\n\n  Default libc malloc is slow. Never use it \n\n- Timestamp Allocation 时间戳分配\n\n","tags":["database"]},{"title":"MingW GCC使用EGE图形库","url":"/2021/07/25/UseEGEbyMingW/","content":"\n```bash\negeball: egeball.cpp\n\tg++ egeball.cpp -o egeball -I\"F:/workspace/ege20.08_all/EGE20.08/demo/test/include\" -L\"F:/workspace/ege20.08_all/EGE20.08/demo/test/lib\" -lgraphics64 -lgdiplus -luuid -lmsimg32 -lgdi32 -limm32 -lole32 -loleaut32 -lwinmm\n\n```\n\n注意:\n\n参数-L添加库文件搜索目录，因为libhello.a在libtest/lib目录中，这里需要指定该目录通知gcc，参数-l指定链接的库文件名称，比如 -ltest：编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.so来确定库的名称\n\n**-**include和**-**I参数\n**-**include用来包含头文件，但一般情况下包含头文件都在源码里用#include xxxxxx实现，**-**include参数很少用。**-**I参数是用来指定头文件目录\n\n\n\n**-l**参数和**-L**参数\n\n**-l**参数就是用来指定程序要链接的库，**-l**参数紧接着就是库名，那么库名跟真正的库文\n件名有什么关系呢？就拿数学库来说，他的库名是m，他的库文件名是libm.so，很容易看出，把库文件名的\n头lib和尾.so去掉就是库名了。\n\n好了现在我们知道怎么得到库名了，比如我们自已要用到一个第三方提供的库名字叫libtest.so，那么我们只要把libtest.so拷贝到/usr/lib\n\n里，编译时加上**-**ltest参数，我们就能用上libtest.so库了（当然要用libtest.so库里的函数，我们还需要与libtest.so配套的头文件）。\n\n放在***\\*/lib\\****和***\\*/usr/lib\\****和***\\*/usr/local/lib\\****里的库直接用**-l**参数就能链接了，但如果库文件没放在这三个目录里，而是放在其他目录里，这时我们只用**-l**参数的话，链接还是会出错，出错信息大概是：“/usr/bin/ld: cannot find**-**lxxx”，也就是链接程序ld在那3个目录里找不到libxxx.so，这时另外一个参数**-L**就派上用场了，比如常用的X11的库，它放在/usr/X11R6/lib目录下，我们编译时就要用**-L**/usr/X11R6/lib \n\n\n\n测试新token","tags":["C","C++","编译"]},{"title":"关于 SFML 在 Visual Studio下的环境搭建","url":"/2021/07/25/VisualStudioSimpleNES/","content":"\n# 关于 SFML 在 Visual Studio下的环境搭建\n\nSFML 全称 Simple and Fast Multimedia Library，它是一个开放源代码，跨平台，支持多种编程语言绑定，并且提供简单易用的接口，用于多媒体程序和游戏开发，是替代SDL的开源库。极地的学习门槛让它成为适合初学者学习的开发环境。\n\n \n\nSFML 包含5个模块，system, window, graphics, audio 和network，其中开发独立（单机）游戏，前4个是必须掌握和学习的。\n\n \n\n参考:https://www.cnblogs.com/CooCoChoco/p/13611153.html\n\n\n\n## 1.下载SFML \n\n下载地址：https://www.sfml-dev.org/download/sfml/2.5.1/\n\n![img](https://gitee.com/waldenth/blogimage/raw/master/img/1872684-20200903223757733-1360715270.png)\n\n![img](https://gitee.com/waldenth/blogimage/raw/master/img/1872684-20200903223948821-847265459.png)\n\n 从SFML 官方网站下载SDK，当前的最新版本是V2.5.1，需要VC2013以上编译环境，如果电脑上安装VC2010，可以点击“old versions”找到较早期的版本下载。\n\n \n\n \n\n## 2.配置SFML \n\n将下载好的SDK 压缩包解压到本机电脑，本文示例目录为 C:\\SimpleNES-master\\SFML-2.5.1\n\n使用 Visual Studio 新建一个空项目，设置工程属性选项，在菜单栏的 项目下，SimpleNES 属性\n\n![img](https://gitee.com/waldenth/blogimage/raw/master/img/1872684-20200903224313171-1857791939.png)\n\n \n\n**第一步：**选择 配置属性 → C/C++ → 附加包含目录中将 SFML 的头文件目录包含：C:\\SimpleNES-master\\SFML-2.5.1\\include\n\n ![img](https://gitee.com/waldenth/blogimage/raw/master/img/1872684-20200903225500259-791839589.png) \n\n \n\n**第二步：**选择 配置属性 → 链接器 → 附加库目录中将 SFML 的静态库目录包含：C:\\SimpleNES-master\\SFML-2.5.1\\lib\n\n ![img](https://gitee.com/waldenth/blogimage/raw/master/img/1872684-20200903225848455-865151637.png)\n\n \n\n \n\n第三步：\n\n（debug）  选择 配置属性 → 链接器 → 输入 → 附加依赖项，加入 sfml-graphics.lib;sfml-window.lib;sfml-system.lib;\n\n（Release）选择 配置属性 → 链接器 → 输入 → 附加依赖项，加入 sfml-graphics.lib,sfml-window.lib,sfml-system.lib;\n\n ![img](https://gitee.com/waldenth/blogimage/raw/master/img/1872684-20200903230215849-2097976373.png)","tags":["C","C++","编译"]},{"title":"systemctl如何关闭/启用/禁用服务","url":"/2021/07/21/Systemctl_Linux/","content":"\n## systemctlsystemctl如何关闭/启用/禁用服务\n\n启动服务：systemctl start vsftpd.service\n\n关闭服务：systemctl stop vsftpd.service\n\n重启服务：systemctl restart vsftpd.service\n\n显示服务的状态：systemctl status vsftpd.service\n\n在开机时启用服务：systemctl enable vsftpd.service\n\n在开机时禁用服务：systemctl disable vsftpd.service\n\n查看服务是否开机启动：systemctl is-enabled vsftpd.service\n\n查看已启动的服务列表：systemctl list-unit-files|grep enabled\n\n查看启动失败的服务列表：systemctl --failed","tags":["Linux"]},{"title":"海康威视SDK开发","url":"/2021/01/28/HikVisionSDK/","content":"\n## demo测试运行\n\ndemo和动态连接库分为Linux和Windows版本,其中Windows使用Visual Studio构建工程,\nLinux下使用Ubuntu,但是要注意参考makefile编写\n\n<!-- more -->\n\n### 平台：Windows 64\n\nVisual Studio 2019\n\n#### demo运行\n....\n....\n#### 接口测试\n....\n....\n### 平台：Linux 64\n\nUbuntu + g++ + makefile\n\n#### demo运行\n....\n....\n#### 接口测试\n....\n....\n\n\n\n### RTSP链接格式\n\nHikvision \tRTSP 直播流：rtsp://admin:abcd1234@192.168.31.167:554/h264/ch1/sub/av_stream\n\t\t     \t\t\t\t\t\t\t\t  rtsp://admin:abcd1234@192.168.31.167:554/Streaming/Channels/101?transportmode=unicast\n  \t\t\t\t\tRTSP 回放流：rtsp://admin:abcd1234@192.168.31.167:554/streaming/tracks/101?starttime=20210509t122832z&endtime=20210509t125205z","tags":["C++"]},{"title":"CSAPP Bomb Lab","url":"/2020/11/08/bomblabProcedure/","content":"\n## Bomb Lab Procedure\n\nThis is an x86-64 bomb for self-study students. \n\n**ATTENTION:**\nif `gdb` says its authority  not enough, \n`sudo su`\n`chmod 777 bomb `\n\n#### 准备工作\n\n首先使用`Linux objdump`工具反汇编保存bomb二进制文件的反汇编代码bomb.asm\n\n```bash\nobjdump -d bomb > bomb.asm\n```\n\n再开启`gdb`调试bomb二进制文件\n\n```bash\ngdb bomb\n```\n\n**注意**\n\n`gdb run`可能会提示权限不够，要修改成可读可写可执行，输入命令\n\n```bash\nsudo su;\nchomd 777 bomb\n```\n\n#### 查看代码\n\n##### C 代码\n\n首先查看`.c`代码，由于缺少头文件和其他文件，只能查看`bomb`的整体逻辑\n\n这一段起始代码是尝试进行读文件操作，大概意识是拆除炸弹可以把所有的炸弹密钥字符串写入一个文档，然后将路径作为参数传递给`bomb`启动执行，如果没有传递参数，那么炸弹密钥通过命令行读取\n\n```c\nint main(int argc, char *argv[])\n{\n    char *input; //源代码38行\n\n    /* Note to self: remember to port this bomb to Windows and put a \n     * fantastic GUI on it. */\n\n    /* When run with no arguments, the bomb reads its input lines \n     * from standard input. */\n    if (argc == 1) {  \n\tinfile = stdin;\n    } \n\n    /* When run with one argument <file>, the bomb reads from <file> \n     * until EOF, and then switches to standard input. Thus, as you \n     * defuse each phase, you can add its defusing string to <file> and\n     * avoid having to retype it. */\n    else if (argc == 2) {\n\tif (!(infile = fopen(argv[1], \"r\"))) {\n\t    printf(\"%s: Error: Couldn't open %s\\n\", argv[0], argv[1]);\n\t    exit(8);\n\t}\n    }\n\n    /* You can't call the bomb with more than 1 command line argument. */\n    else {\n\tprintf(\"Usage: %s [<input_file>]\\n\", argv[0]);\n\texit(8);\n    }\n```\n\n下面这一段是初始化炸弹` initialize_bomb();`想必是一个初始化函数，然后打印开始提示信息\n\n```c\n/* Do all sorts of secret stuff that makes the bomb harder to defuse. */ //66行\n    initialize_bomb();\n\n    printf(\"Welcome to my fiendish little bomb. You have 6 phases with\\n\");\n    printf(\"which to blow yourself up. Have a nice day!\\n\");\n```\n\n主体部分，程序分为6个phase，每一个都需要你输入一行字符串，然后对应调用phase_n()函数进行判断是否触发炸弹\n\n```c\n/* Hmm...  Six phases must be more secure than one phase! */  //72\n    input = read_line();             /* Get input                   */\n    phase_1(input);                  /* Run the phase               */\n    phase_defused();                 /* Drat!  They figured it out!\n\t\t\t\t      * Let me know how they did it. */\n    printf(\"Phase 1 defused. How about the next one?\\n\");\n\n    /* The second phase is harder.  No one will ever figure out\n     * how to defuse this... */\n    input = read_line();\n    phase_2(input);\n    phase_defused();\n    printf(\"That's number 2.  Keep going!\\n\");\n\n    /* I guess this is too easy so far.  Some more complex code will\n     * confuse people. */\n    input = read_line();\n    phase_3(input);\n    phase_defused();\n    printf(\"Halfway there!\\n\");\n\n    /* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */\n    input = read_line();\n    phase_4(input);\n    phase_defused();\n    printf(\"So you got that one.  Try this one.\\n\");\n    \n    /* Round and 'round in memory we go, where we stop, the bomb blows! */\n    input = read_line();\n    phase_5(input);\n    phase_defused();\n    printf(\"Good work!  On to the next...\\n\");\n\n    /* This phase will never be used, since no one will get past the\n     * earlier ones.  But just in case, make this one extra hard. */\n    input = read_line();\n    phase_6(input);\n    phase_defused();\n\n    /* Wow, they got it!  But isn't something... missing?  Perhaps\n     * something they overlooked?  Mua ha ha ha ha! */\n    \n    return 0;\n```\n\n##### 反汇编代码\n\n先定位到main\n\n```asm\n0000000000400da0 <main>:\n  400da0:\t53                   \tpush   %rbx\n  400da1:\t83 ff 01             \tcmp    $0x1,%edi\n  400da4:\t75 10                \tjne    400db6 <main+0x16>\n  400da6:\t48 8b 05 9b 29 20 00 \tmov    0x20299b(%rip),%rax        # 603748 <stdin@@GLIBC_2.2.5>\n  400dad:\t48 89 05 b4 29 20 00 \tmov    %rax,0x2029b4(%rip)        # 603768 <infile>\n  400db4:\teb 63                \tjmp    400e19 <main+0x79>\n  400db6:\t48 89 f3             \tmov    %rsi,%rbx\n  400db9:\t83 ff 02             \tcmp    $0x2,%edi\n  400dbc:\t75 3a                \tjne    400df8 <main+0x58>\n  400dbe:\t48 8b 7e 08          \tmov    0x8(%rsi),%rdi\n  400dc2:\tbe b4 22 40 00       \tmov    $0x4022b4,%esi\n  400dc7:\te8 44 fe ff ff       \tcallq  400c10 <fopen@plt>\n  400dcc:\t48 89 05 95 29 20 00 \tmov    %rax,0x202995(%rip)        # 603768 <infile>\n  400dd3:\t48 85 c0             \ttest   %rax,%rax\n  400dd6:\t75 41                \tjne    400e19 <main+0x79>\n  400dd8:\t48 8b 4b 08          \tmov    0x8(%rbx),%rcx\n  400ddc:\t48 8b 13             \tmov    (%rbx),%rdx\n  400ddf:\tbe b6 22 40 00       \tmov    $0x4022b6,%esi\n  400de4:\tbf 01 00 00 00       \tmov    $0x1,%edi\n  400de9:\te8 12 fe ff ff       \tcallq  400c00 <__printf_chk@plt>\n  400dee:\tbf 08 00 00 00       \tmov    $0x8,%edi\n  400df3:\te8 28 fe ff ff       \tcallq  400c20 <exit@plt>\n  400df8:\t48 8b 16             \tmov    (%rsi),%rdx\n  400dfb:\tbe d3 22 40 00       \tmov    $0x4022d3,%esi\n  400e00:\tbf 01 00 00 00       \tmov    $0x1,%edi\n  400e05:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400e0a:\te8 f1 fd ff ff       \tcallq  400c00 <__printf_chk@plt>\n  400e0f:\tbf 08 00 00 00       \tmov    $0x8,%edi\n  400e14:\te8 07 fe ff ff       \tcallq  400c20 <exit@plt>\n  400e19:\te8 84 05 00 00       \tcallq  4013a2 <initialize_bomb>;初始化炸弹\n  \n  \n  ;gdb调试信息：\n  ;(gdb) print (char*)(0x402338)\n  ;$1 = 0x402338 \"Welcome to my fiendish little bomb. You have 6 phases with\"\n  400e1e:\tbf 38 23 40 00       \tmov    $0x402338,%edi\n  400e23:\te8 e8 fc ff ff       \tcallq  400b10 <puts@plt>\n  ;gdb) print (char*)(0x402378)\n  ;$2 = 0x402378 \"which to blow yourself up. Have a nice day!\"\n  400e28:\tbf 78 23 40 00       \tmov    $0x402378,%edi\n  400e2d:\te8 de fc ff ff       \tcallq  400b10 <puts@plt>;打印提示信息\n  ; edi(第一参数寄存器)存放要打印的字符串的地址，通过callq  400b10 <puts@plt>打印\n  ;=========================================================================\n  ;下面一段就是一个炸弹,炸弹先调用read_line,然后将返回的地址传递给phase_n函数，\n  ;如果输入的不正确那么就会执行爆炸函数输出bomb!\n  ;\n  ;\n  ;; 获取输入字符串,rax返回值是字符串地址\n  400e32:\te8 67 06 00 00       \tcallq  40149e <read_line>\n  ;; 获取的输入字符串地址赋给rdi\n  400e37:\t48 89 c7             \tmov    %rax,%rdi\n  400e3a:\te8 a1 00 00 00       \tcallq  400ee0 <phase_1>\n  400e3f:\te8 80 07 00 00       \tcallq  4015c4 <phase_defused>\n  400e44:\tbf a8 23 40 00       \tmov    $0x4023a8,%edi\n  400e49:\te8 c2 fc ff ff       \tcallq  400b10 <puts@plt>\n  \n  \n  400e4e:\te8 4b 06 00 00       \tcallq  40149e <read_line>\n  400e53:\t48 89 c7             \tmov    %rax,%rdi\n  400e56:\te8 a1 00 00 00       \tcallq  400efc <phase_2>\n  400e5b:\te8 64 07 00 00       \tcallq  4015c4 <phase_defused>\n  400e60:\tbf ed 22 40 00       \tmov    $0x4022ed,%edi\n  400e65:\te8 a6 fc ff ff       \tcallq  400b10 <puts@plt>\n  \n  \n  400e6a:\te8 2f 06 00 00       \tcallq  40149e <read_line>\n  400e6f:\t48 89 c7             \tmov    %rax,%rdi\n  400e72:\te8 cc 00 00 00       \tcallq  400f43 <phase_3>\n  400e77:\te8 48 07 00 00       \tcallq  4015c4 <phase_defused>\n  400e7c:\tbf 0b 23 40 00       \tmov    $0x40230b,%edi\n  400e81:\te8 8a fc ff ff       \tcallq  400b10 <puts@plt>\n  \n  \n  400e86:\te8 13 06 00 00       \tcallq  40149e <read_line>\n  400e8b:\t48 89 c7             \tmov    %rax,%rdi\n  400e8e:\te8 79 01 00 00       \tcallq  40100c <phase_4>\n  400e93:\te8 2c 07 00 00       \tcallq  4015c4 <phase_defused>\n  400e98:\tbf d8 23 40 00       \tmov    $0x4023d8,%edi\n  400e9d:\te8 6e fc ff ff       \tcallq  400b10 <puts@plt>\n  \n  \n  400ea2:\te8 f7 05 00 00       \tcallq  40149e <read_line>\n  400ea7:\t48 89 c7             \tmov    %rax,%rdi\n  400eaa:\te8 b3 01 00 00       \tcallq  401062 <phase_5>\n  400eaf:\te8 10 07 00 00       \tcallq  4015c4 <phase_defused>\n  400eb4:\tbf 1a 23 40 00       \tmov    $0x40231a,%edi\n  400eb9:\te8 52 fc ff ff       \tcallq  400b10 <puts@plt>\n  \n  \n  400ebe:\te8 db 05 00 00       \tcallq  40149e <read_line>\n  400ec3:\t48 89 c7             \tmov    %rax,%rdi\n  400ec6:\te8 29 02 00 00       \tcallq  4010f4 <phase_6>\n  400ecb:\te8 f4 06 00 00       \tcallq  4015c4 <phase_defused>\n  400ed0:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400ed5:\t5b                   \tpop    %rbx\n  400ed6:\tc3                   \tretq   \n  400ed7:\t90                   \tnop\n  400ed8:\t90                   \tnop\n  400ed9:\t90                   \tnop\n  400eda:\t90                   \tnop\n  400edb:\t90                   \tnop\n  400edc:\t90                   \tnop\n  400edd:\t90                   \tnop\n  400ede:\t90                   \tnop\n  400edf:\t90                   \tnop\n```\n\n查看`read_line`\n\n```asm\n000000000040149e <read_line>:\n  40149e:\t48 83 ec 08          \tsub    $0x8,%rsp\n  4014a2:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  4014a7:\te8 4d ff ff ff       \tcallq  4013f9 <skip>\n  4014ac:\t48 85 c0             \ttest   %rax,%rax\n  4014af:\t75 6e                \tjne    40151f <read_line+0x81>\n  4014b1:\t48 8b 05 90 22 20 00 \tmov    0x202290(%rip),%rax        # 603748 <stdin@@GLIBC_2.2.5>\n  4014b8:\t48 39 05 a9 22 20 00 \tcmp    %rax,0x2022a9(%rip)        # 603768 <infile>\n  4014bf:\t75 14                \tjne    4014d5 <read_line+0x37>\n  4014c1:\tbf d5 25 40 00       \tmov    $0x4025d5,%edi\n  4014c6:\te8 45 f6 ff ff       \tcallq  400b10 <puts@plt>\n  4014cb:\tbf 08 00 00 00       \tmov    $0x8,%edi\n  4014d0:\te8 4b f7 ff ff       \tcallq  400c20 <exit@plt>\n  4014d5:\tbf f3 25 40 00       \tmov    $0x4025f3,%edi\n  4014da:\te8 01 f6 ff ff       \tcallq  400ae0 <getenv@plt>\n  \n  4014df:\t48 85 c0             \ttest   %rax,%rax\n  ; rax为零则跳转到4014ee,否则edi清零并callq  400c20 <exit@plt>\n  4014e2:\t74 0a                \tje     4014ee <read_line+0x50>\n  4014e4:\tbf 00 00 00 00       \tmov    $0x0,%edi\n  4014e9:\te8 32 f7 ff ff       \tcallq  400c20 <exit@plt>\n  \n  4014ee:\t48 8b 05 53 22 20 00 \tmov    0x202253(%rip),%rax        # 603748 <stdin@@GLIBC_2.2.5>\n  4014f5:\t48 89 05 6c 22 20 00 \tmov    %rax,0x20226c(%rip)        # 603768 <infile>\n  4014fc:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401501:\te8 f3 fe ff ff       \tcallq  4013f9 <skip>\n  401506:\t48 85 c0             \ttest   %rax,%rax\n  401509:\t75 14                \tjne    40151f <read_line+0x81>\n  40150b:\tbf d5 25 40 00       \tmov    $0x4025d5,%edi\n  401510:\te8 fb f5 ff ff       \tcallq  400b10 <puts@plt>\n  401515:\tbf 00 00 00 00       \tmov    $0x0,%edi\n  40151a:\te8 01 f7 ff ff       \tcallq  400c20 <exit@plt>\n  40151f:\t8b 15 3b 22 20 00    \tmov    0x20223b(%rip),%edx        # 603760 <num_input_strings>\n  401525:\t48 63 c2             \tmovslq %edx,%rax\n  401528:\t48 8d 34 80          \tlea    (%rax,%rax,4),%rsi\n  40152c:\t48 c1 e6 04          \tshl    $0x4,%rsi\n  401530:\t48 81 c6 80 37 60 00 \tadd    $0x603780,%rsi\n  401537:\t48 89 f7             \tmov    %rsi,%rdi\n  40153a:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  40153f:\t48 c7 c1 ff ff ff ff \tmov    $0xffffffffffffffff,%rcx\n  401546:\tf2 ae                \trepnz scas %es:(%rdi),%al\n  401548:\t48 f7 d1             \tnot    %rcx\n  40154b:\t48 83 e9 01          \tsub    $0x1,%rcx\n  40154f:\t83 f9 4e             \tcmp    $0x4e,%ecx\n  ;ecx有符号小于等于0x4e则跳转到40159a(引爆炸弹的下一条指令处)\n  401552:\t7e 46                \tjle    40159a <read_line+0xfc> \n  \n  401554:\tbf fe 25 40 00       \tmov    $0x4025fe,%edi\n  401559:\te8 b2 f5 ff ff       \tcallq  400b10 <puts@plt>\n  40155e:\t8b 05 fc 21 20 00    \tmov    0x2021fc(%rip),%eax        # 603760 <num_input_strings>\n  401564:\t8d 50 01             \tlea    0x1(%rax),%edx\n  401567:\t89 15 f3 21 20 00    \tmov    %edx,0x2021f3(%rip)        # 603760 <num_input_strings>\n  40156d:\t48 98                \tcltq   \n  40156f:\t48 6b c0 50          \timul   $0x50,%rax,%rax\n  401573:\t48 bf 2a 2a 2a 74 72 \tmovabs $0x636e7572742a2a2a,%rdi\n  40157a:\t75 6e 63 \n  40157d:\t48 89 b8 80 37 60 00 \tmov    %rdi,0x603780(%rax)\n  401584:\t48 bf 61 74 65 64 2a \tmovabs $0x2a2a2a64657461,%rdi\n  40158b:\t2a 2a 00 \n  40158e:\t48 89 b8 88 37 60 00 \tmov    %rdi,0x603788(%rax)\n  401595:\te8 a0 fe ff ff       \tcallq  40143a <explode_bomb> ;引爆炸弹\n  40159a:\t83 e9 01             \tsub    $0x1,%ecx\n  40159d:\t48 63 c9             \tmovslq %ecx,%rcx\n  4015a0:\t48 63 c2             \tmovslq %edx,%rax\n  4015a3:\t48 8d 04 80          \tlea    (%rax,%rax,4),%rax\n  4015a7:\t48 c1 e0 04          \tshl    $0x4,%rax\n  4015ab:\tc6 84 01 80 37 60 00 \tmovb   $0x0,0x603780(%rcx,%rax,1)\n  4015b2:\t00 \n  4015b3:\t83 c2 01             \tadd    $0x1,%edx\n  4015b6:\t89 15 a4 21 20 00    \tmov    %edx,0x2021a4(%rip)        # 603760 <num_input_strings>\n  4015bc:\t48 89 f0             \tmov    %rsi,%rax\n  4015bf:\t48 83 c4 08          \tadd    $0x8,%rsp\n  4015c3:\tc3                   \tretq   \n```\n\n`strings_not_equal`函数\n\n```asm\n0000000000401338 <strings_not_equal>:\n  401338:\t41 54                \tpush   %r12\n  40133a:\t55                   \tpush   %rbp \n  40133b:\t53                   \tpush   %rbx ; rbp,rbx压栈,说明该函数要使用\n  ; 分别赋值rdi,rsi,说明匹配的字符串地址应该在rdi,rsi处\n  40133c:\t48 89 fb             \tmov    %rdi,%rbx ;\n  40133f:\t48 89 f5             \tmov    %rsi,%rbp \n  \n  401342:\te8 d4 ff ff ff       \tcallq  40131b <string_length>\n  401347:\t41 89 c4             \tmov    %eax,%r12d\n  40134a:\t48 89 ef             \tmov    %rbp,%rdi\n  40134d:\te8 c9 ff ff ff       \tcallq  40131b <string_length>\n  401352:\tba 01 00 00 00       \tmov    $0x1,%edx\n  401357:\t41 39 c4             \tcmp    %eax,%r12d\n  40135a:\t75 3f                \tjne    40139b <strings_not_equal+0x63>\n  40135c:\t0f b6 03             \tmovzbl (%rbx),%eax\n  40135f:\t84 c0                \ttest   %al,%al\n  401361:\t74 25                \tje     401388 <strings_not_equal+0x50>\n  401363:\t3a 45 00             \tcmp    0x0(%rbp),%al\n  401366:\t74 0a                \tje     401372 <strings_not_equal+0x3a>\n  401368:\teb 25                \tjmp    40138f <strings_not_equal+0x57>\n  40136a:\t3a 45 00             \tcmp    0x0(%rbp),%al\n  40136d:\t0f 1f 00             \tnopl   (%rax)\n  401370:\t75 24                \tjne    401396 <strings_not_equal+0x5e>\n  401372:\t48 83 c3 01          \tadd    $0x1,%rbx\n  401376:\t48 83 c5 01          \tadd    $0x1,%rbp\n  40137a:\t0f b6 03             \tmovzbl (%rbx),%eax\n  40137d:\t84 c0                \ttest   %al,%al\n  40137f:\t75 e9                \tjne    40136a <strings_not_equal+0x32>\n  401381:\tba 00 00 00 00       \tmov    $0x0,%edx\n  401386:\teb 13                \tjmp    40139b <strings_not_equal+0x63>\n  401388:\tba 00 00 00 00       \tmov    $0x0,%edx\n  40138d:\teb 0c                \tjmp    40139b <strings_not_equal+0x63>\n  40138f:\tba 01 00 00 00       \tmov    $0x1,%edx\n  401394:\teb 05                \tjmp    40139b <strings_not_equal+0x63>\n  401396:\tba 01 00 00 00       \tmov    $0x1,%edx\n  40139b:\t89 d0                \tmov    %edx,%eax\n  40139d:\t5b                   \tpop    %rbx\n  40139e:\t5d                   \tpop    %rbp\n  40139f:\t41 5c                \tpop    %r12\n  4013a1:\tc3                   \tretq   \n```\n\n\n\n#### 第一个炸弹\n\n```asm\n0000000000400ee0 <phase_1>:\n  400ee0:\t48 83 ec 08          \tsub    $0x8,%rsp ;申请8字节栈空间\n  ;给寄存器esi(rsi低32位)赋值,应该是一个地址,esi(rsi)是第二个参数寄存器\n  400ee4:\tbe 00 24 40 00       \tmov    $0x402400,%esi ;\n  ;调用匹配字符串函数\n  400ee9:\te8 4a 04 00 00       \tcallq  401338 <strings_not_equal>\n  ;测试匹配函数结束后的eax(返回值rax低32位)寄存器值,若0,栈复原退出,否则调用炸弹爆炸函数\n  400eee:\t85 c0                \ttest   %eax,%eax\n  400ef0:\t74 05                \tje     400ef7 <phase_1+0x17>\n  400ef2:\te8 43 05 00 00       \tcallq  40143a <explode_bomb>\n  400ef7:\t48 83 c4 08          \tadd    $0x8,%rsp\n  400efb:\tc3                   \tretq   \n```\n\n结合phase1的代码\n\n```asm\n ;; 获取输入字符串,rax返回值是字符串地址\n  400e32:\te8 67 06 00 00       \tcallq  40149e <read_line>\n  ;; 获取的输入字符串地址赋给rdi\n  400e37:\t48 89 c7             \tmov    %rax,%rdi\n  400e3a:\te8 a1 00 00 00       \tcallq  400ee0 <phase_1>\n  400e3f:\te8 80 07 00 00       \tcallq  4015c4 <phase_defused>\n  400e44:\tbf a8 23 40 00       \tmov    $0x4023a8,%edi \n  400e49:\te8 c2 fc ff ff       \tcallq  400b10 <puts@plt>\n```\n\n`read_line`函数会将读入字符串地址存放在`rdi `和`rsi`中，`strings_not_equa`l函数会使用`edi`和`esi`中的值当做两个字符址，并且判断他们是否相等，相等返回0\n\n`edi`存放的是`callq  400b10 <puts@plt>`要打印的信息的地址，用gdb调试\n\n```bash\n(gdb) print (char*)(0x4023a8)\n$3 = 0x4023a8 \"Phase 1 defused. How about the next one?\"\n```\n\n可见打印的是成功拆除的信息。因此，炸弹1的整体逻辑就是\n\n```mermaid\ngraph LR\nA[开始] --> B[ 函数readline ]\n     B--> C(rdi=&输入字符串<br>rsi=&密钥字符串) --> D{string_not_equal}\n     D--> |返回0| E[puts success info]\n     D--> |返回非0| F[bomb_explode]\n```\n\n于是，重点在于找到给`rsi`赋地址的语句，这个地址存储的就是密钥字符串\n\n```asm\n0000000000400ee0 <phase_1>:\n  400ee0:\t48 83 ec 08          \tsub    $0x8,%rsp ;申请8字节栈空间\n  ;给寄存器esi(rsi低32位)赋值,应该是一个地址,esi(rsi)是第二个参数寄存器\n  400ee4:\tbe 00 24 40 00       \tmov    $0x402400,%esi ; rsi赋地址语句\n```\n\n`esi`是`rsi`的低32位，400ee4给`esi`赋值就是给`rsi`赋值为密钥字符串地址\n\n`gdb`调试\n\n```bash\n(gdb) print (char*) (0x402400)\n$7 = 0x402400 \"Border relations with Canada have never been better.\"\n```\n\n第一个炸弹的密钥就是**\"Border relations with Canada have never been better.\"**\n\n#### 第二个炸弹\n\n查看`phase_2`代码\n\n```asm\n0000000000400efc <phase_2>:\n  400efc:\t55                   \tpush   %rbp\n  400efd:\t53                   \tpush   %rbx ; rbx rbp压栈，要被调用\n  400efe:\t48 83 ec 28          \tsub    $0x28,%rsp ; 申请0x28=40字节栈帧\n  400f02:\t48 89 e6             \tmov    %rsp,%rsi ; 将rsp值赋给rsi\n  ;根据函数名,应该是读入六个数\n  400f05:\te8 52 05 00 00       \tcallq  40145c <read_six_numbers>\n  \n  400f0a:\t83 3c 24 01          \tcmpl   $0x1,(%rsp); 查栈顶元素是否是1,\n  \t\t\t\t\t\t\t\t\t\t\t\t\t  ; 由下文分析可知phase_2栈顶存储的是第一个输入的值\n  \t\t\t\t\t\t\t\t\t\t\t\t\t  ; 因此密钥第一个数字必定是1\n  400f0e:\t74 20                \tje     400f30 <phase_2+0x34>;是1，跳转到400f30进行首轮哨兵初始化等操作,不是则引爆炸弹\n  400f10:\te8 25 05 00 00       \tcallq  40143a <explode_bomb> ;引爆炸弹\n  400f15:\teb 19                \tjmp    400f30 <phase_2+0x34> \n  \n  ;取出rbx-4处的值赋给eax\n  400f17:\t8b 43 fc             \tmov    -0x4(%rbx),%eax\n  400f1a:\t01 c0                \tadd    %eax,%eax; eax=2*eax\n  ;比较eax*2和rbx处的值,注意:eax是rbx-4处的值，即将rbx和前一个数的两倍比较\n  400f1c:\t39 03                \tcmp    %eax,(%rbx)\n  ; rbx和前一个数的两倍相等则跳转\n  400f1e:\t74 05                \tje     400f25 <phase_2+0x29> \n  ; 不相等引爆炸弹\n  400f20:\te8 15 05 00 00       \tcallq  40143a <explode_bomb>\n  ; rbx=rbx+4\n  400f25:\t48 83 c3 04          \tadd    $0x4,%rbx\n  ; 将rbx和rbp比较\n  ;将加4后的值和rbp比较，\n  ;注意rbp是rsp+24 (400f30代码),而rsp是第一个数，一个数四个字节。那么rbp就应该是\n  ;后那个数后面那个地址，即rbp是个循环哨兵\n  400f29:\t48 39 eb             \tcmp    %rbp,%rbx\n  ; 不相等跳转回rbx-4，继续取rbx前一个数的两倍与其比较\n  400f2c:\t75 e9                \tjne    400f17 <phase_2+0x1b>\n  ; 相等则直接跳转出去\n  400f2e:\teb 0c                \tjmp    400f3c <phase_2+0x40>\n  \n  400f30:\t48 8d 5c 24 04       \tlea    0x4(%rsp),%rbx ;将rsp+4存到rbx\n  400f35:\t48 8d 6c 24 18       \tlea    0x18(%rsp),%rbp ; 将rsp +24 存到rbp\n  ; 无条件跳回去,取rbx前一个数的两倍与其比较\n  400f3a:\teb db                \tjmp    400f17 <phase_2+0x1b> \n  \n  400f3c:\t48 83 c4 28          \tadd    $0x28,%rsp\n  400f40:\t5b                   \tpop    %rbx\n  400f41:\t5d                   \tpop    %rbp\n  400f42:\tc3                   \tretq   \n```\n\n查看`read_six_number`代码\n\n内部调用了`sscanf` 这个函数（功能是从一个字符串中读取一定格式的数据，和 `scanf` 一样，除了 `scanf` 是从标准输入流中读取）。参数顺序分别是，待读取内容的字符串(`rdi`)、用于格式读取的格式化字符串(`rsi`)，还有各个变量读取后存放的地址(`rdx`)。返回读到的有效数据个数\n\n- `%rdx`由 `%rsi` 给出，`%rsi` 又由 `phrase2` 的 `%rsp` 给出，所以 `phrase2` 中的 `%rsp` 地址处存放 `sscanf` 中第1个输入的值。\n\n```asm\n000000000040145c <read_six_numbers>:\n  40145c:\t48 83 ec 18          \tsub    $0x18,%rsp ; 申请0x18=24字节栈帧\n  401460:\t48 89 f2             \tmov    %rsi,%rdx; rdx=rsi\n  401463:\t48 8d 4e 04          \tlea    0x4(%rsi),%rcx; rcx=rsi+4\n  \n  ;                                       \trax=rsi+0x14\n  401467:\t48 8d 46 14          \tlea    0x14(%rsi),%rax\n  40146b:\t48 89 44 24 08       \tmov    %rax,0x8(%rsp);将rax存入rsp+8处\n  ;此时栈\n  ;| ......... |  <- rsi,rdx \n  ;|  返回地址  |\n  ;|           |\n  ;|  rsi+0x14 |\n  ;|           |  <- rsp\n  \n  401470:\t48 8d 46 10          \tlea    0x10(%rsi),%rax; rax=rsi+0x10\n  401474:\t48 89 04 24          \tmov    %rax,(%rsp); 将rax存入rsp处\n  ;此时栈\n  ;| ......... |  <- rsi,rdx \n  ;|  返回地址  |\n  ;|           |\n  ;|  rsi+0x14 |\n  ;|  rsi+0x10 |  <- rsp\n  401478:\t4c 8d 4e 0c          \tlea    0xc(%rsi),%r9\n  40147c:\t4c 8d 46 08          \tlea    0x8(%rsi),%r8\n  \n  \n  ;将rsi赋值为0x4025c3\n  401480:\tbe c3 25 40 00       \tmov    $0x4025c3,%esi\n  401485:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  ;调用了scanf\n  40148a:\te8 61 f7 ff ff       \tcallq  400bf0 <__isoc99_sscanf@plt>\n  \n  \n  40148f:\t83 f8 05             \tcmp    $0x5,%eax\n  ; eax 大于5 跳转到401499准备返回,否则调用爆炸函数,eax存放的应该是读到的数字个数\n  401492:\t7f 05                \tjg     401499 <read_six_numbers+0x3d>\n  401494:\te8 a1 ff ff ff       \tcallq  40143a <explode_bomb>\n  ; 释放栈帧，返回\n  401499:\t48 83 c4 18          \tadd    $0x18,%rsp\n  40149d:\tc3                   \tretq   \n```\n\n- `%rcx`，`phrase2` 中的 `%rsp+0x4` 处存放第2个值\n- `%r8`，`phrase2` 中的 `%rsp+0x8` 存放第3个值\n- `%r9`，`phrase2` 中的 `%rsp+0xc` 存放第4个值\n\n- 第5个、第6个值所在的地址需要通过压栈传参，参数的入栈顺序是从右至左。可知，`phrase2` 中的 `%rsp+0x10` 存放第五个值、`phrase2` 中的 `%rsp+0x14` 存放第六个值。第六个值先入栈，更加靠近栈底（高地址）。\n\n打印0x4025c3处的值\n\n```bash\n(gdb) x /4wd 0x4025c3\n0x4025c3:\t622879781\t1680154724\t543434016\t622879781\n```\n\n乱七八糟，尝试用字符串打印\n\n```asm\n(gdb) print (char*)0x4025c3\n$5 = 0x4025c3 \"%d %d %d %d %d %d\"\n```\n\n这说明`sscanf`读取的确实是6个数字。可以确定，第2个炸弹的密钥是**1 2 4 8 16 32**\n\n#### 第三个炸弹\n\n查看`phase_3`代码\n\n```asm\n0000000000400f43 <phase_3>:\n  400f43:\t48 83 ec 18          \tsub    $0x18,%rsp\n  400f47:\t48 8d 4c 24 0c       \tlea    0xc(%rsp),%rcx ; rcx存储接受输入的第2个数字的地址\n  400f4c:\t48 8d 54 24 08       \tlea    0x8(%rsp),%rdx ; rdx 是sscanf接受输入字符串的地址,为rsp+8\n  \n  400f51:\tbe cf 25 40 00       \tmov    $0x4025cf,%esi ;esi(rsi)为sscanf的第二个参数,输入格式\n  400f56:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400f5b:\te8 90 fc ff ff       \tcallq  400bf0 <__isoc99_sscanf@plt> ; 又调用sscanf获取输入\n  \n```\n\n代码开头就调用了`sscanf`，所以这个函数前面一定会有一个字符串常量存储需要读取的数据格式，函数的第二个参数用`rsi(esi)`存储，`400f51:`处代码告诉了`esi`的字符串首地址是`0x4025cf`，\n\n使用`gdb`调试\n\n```bash\n(gdb) print (char*) 0x4025cf\n$1 = 0x4025cf \"%d %d\"\n```\n\n确定这个炸弹的输入是两个数字\n\n继续查看代码，发现其`cmp,jmp`等跳转指令很多，而且极其的有规律，猜测是个switch语句\n\n```asm\n  400f60:\t83 f8 01             \tcmp    $0x1,%eax ; eax与1比较,应该是返回值sscanf返回读到的2数据个数\n  ; eax大于1 跳转L1,否则触发爆炸,因为密钥是2个数字,小于等于1个有效数据肯定错误\n  400f63:\t7f 05                \tjg     400f6a <phase_3+0x27>\n  400f65:\te8 d0 04 00 00       \tcallq  40143a <explode_bomb>\n  ; L1, 结合上文代码,这是比较ssacnf获取的第一个输入数据和0x7的大小\n  400f6a:\t83 7c 24 08 07       \tcmpl   $0x7,0x8(%rsp)\n  ; 无符号大于7跳转到L2爆炸\n  400f6f:\t77 3c                \tja     400fad <phase_3+0x6a>\n  ; 无符号小于等于7, 将eax赋值为sscanf获取的第一个输入\n  400f71:\t8b 44 24 08          \tmov    0x8(%rsp),%eax\n  ; 间接跳转, 跳转到 (0x402470+%rax*8)内存数据表示的地址,这是switch典型代码,0x402470存储的应该是一个跳转表\n  400f75:\tff 24 c5 70 24 40 00 \tjmpq   *0x402470(,%rax,8)\n  ; 跳转表元素的每个数据应该是下面的一段,进行一次mov操作,修改eax值后统一跳转到400fbe处\n  ; case1\n  400f7c:\tb8 cf 00 00 00       \tmov    $0xcf,%eax\n  400f81:\teb 3b                \tjmp    400fbe <phase_3+0x7b>\n  ; case2\n  400f83:\tb8 c3 02 00 00       \tmov    $0x2c3,%eax\n  400f88:\teb 34                \tjmp    400fbe <phase_3+0x7b>\n  ; case3\n  400f8a:\tb8 00 01 00 00       \tmov    $0x100,%eax\n  400f8f:\teb 2d                \tjmp    400fbe <phase_3+0x7b>\n  ; case4\n  400f91:\tb8 85 01 00 00       \tmov    $0x185,%eax\n  400f96:\teb 26                \tjmp    400fbe <phase_3+0x7b>\n  ; case5\n  400f98:\tb8 ce 00 00 00       \tmov    $0xce,%eax\n  400f9d:\teb 1f                \tjmp    400fbe <phase_3+0x7b>\n  ; case6\n  400f9f:\tb8 aa 02 00 00       \tmov    $0x2aa,%eax\n  400fa4:\teb 18                \tjmp    400fbe <phase_3+0x7b>\n  ; case7\n  400fa6:\tb8 47 01 00 00       \tmov    $0x147,%eax\n  400fab:\teb 11                \tjmp    400fbe <phase_3+0x7b>\n  ; L2 触发爆炸\n  400fad:\te8 88 04 00 00       \tcallq  40143a <explode_bomb>\n  400fb2:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400fb7:\teb 05                \tjmp    400fbe <phase_3+0x7b>\n  ;?\n  400fb9:\tb8 37 01 00 00       \tmov    $0x137,%eax\n  ; case 结束后跳转到的地方\n  ; 显然这里是把ssacnf获取的第二个输入数字与case处理后的eax比较\n  400fbe:\t3b 44 24 0c          \tcmp    0xc(%rsp),%eax\n  ; 若相等,则复原栈帧跳出去\n  400fc2:\t74 05                \tje     400fc9 <phase_3+0x86>\n  ; 不等就爆炸\n  400fc4:\te8 71 04 00 00       \tcallq  40143a <explode_bomb>\n  400fc9:\t48 83 c4 18          \tadd    $0x18,%rsp\n  400fcd:\tc3                   \tretq   \n```\n\n因此本题答案可不唯一，第一个数字应该无符号小于等于7，\n\n`gdb`打印跳转表\n\n```bash\n(gdb) x /8gx 0x402470\n0x402470:\t0x0000000000400f7c [case1]\t\t0x0000000000400fb9 [?]\n0x402480:\t0x0000000000400f83 [case2]     \t0x0000000000400f8a [case3]\n0x402490:\t0x0000000000400f91 [case4]\t\t0x0000000000400f98 [case5]\n0x4024a0:\t0x0000000000400f9f [case6]      0x0000000000400fa6 [case7]\n```\n\n因此 假设第一个数字是0，那么跳转到的是`case1`，`eax=0xcf`，第二个数字得是`0xcf=207`\n\n第一个数字是1，跳转到？,`eax=0x137=311`\n\n#### 第四个炸弹\n\n查看`phase_4`代码，考察的是函数递归调用\n\n```asm\n000000000040100c <phase_4>:\n  40100c:\t48 83 ec 18          \tsub    $0x18,%rsp ; 申请0x18=24直接栈帧\n  ;| phase_4 ret addr |\n  ;|                  |\t <- rcx   (sscanf 输入2nd)\n  ;|                  |  <- rdx   (sscanf 输入1st)\n  ;|                  |  <- rsp\n  401010:\t48 8d 4c 24 0c       \tlea    0xc(%rsp),%rcx\n  401015:\t48 8d 54 24 08       \tlea    0x8(%rsp),%rdx ; sscanf获取的输入存放的地址\n  \n  \n  40101a:\tbe cf 25 40 00       \tmov    $0x4025cf,%esi;esi(rsi)为sscanf的第二个参数,输入格式\n  40101f:\tb8 00 00 00 00       \tmov    $0x0,%eax ; eax(rax)清零 \n  401024:\te8 c7 fb ff ff       \tcallq  400bf0 <__isoc99_sscanf@plt>; 调用sscanf\n  401029:\t83 f8 02             \tcmp    $0x2,%eax; sscanf返回的eax是有效数据个数，判断是否是2\n  ; 不相等跳转到爆炸处,有效输入个数不是2,必然和密钥不匹配,错误\n  40102c:\t75 07                \tjne    401035 <phase_4+0x29>\n  ; 是2个有效输入,比较第一个输入和0xe=14\n  40102e:\t83 7c 24 08 0e       \tcmpl   $0xe,0x8(%rsp)\n  ; 第一个输入无符号小于等于14 跳转避开炸弹,否则到401035处爆炸\n  401033:\t76 05                \tjbe    40103a <phase_4+0x2e>\n  ; 引爆炸弹\n  401035:\te8 00 04 00 00       \tcallq  40143a <explode_bomb>\n  ; 避开炸弹跳转点,将edx置为0xe=14\n  40103a:\tba 0e 00 00 00       \tmov    $0xe,%edx\n  ; esi清零\n  40103f:\tbe 00 00 00 00       \tmov    $0x0,%esi\n  ; edi置为sscanf获取的第一个输入\n  401044:\t8b 7c 24 08          \tmov    0x8(%rsp),%edi\n  ; 调用func4函数\n  ;| phase_4 ret addr |\n  ;|                  |\t <- rcx   (sscanf 输入2nd)\n  ;|                  |  <- rdx   (sscanf 输入1st)\n  ;|                  | \n  ;| func4  ret addr  |  <- rsp\n  ;|                  |\n  401048:\te8 81 ff ff ff       \tcallq  400fce <func4>\n  ; 调用结束后检查 eax\n  40104d:\t85 c0                \ttest   %eax,%eax\n  ;  返回值非零引爆炸弹\n  40104f:\t75 07                \tjne    401058 <phase_4+0x4c>\n  ; 返回值为零 将第二个输入与0做比较\n  401051:\t83 7c 24 0c 00       \tcmpl   $0x0,0xc(%rsp)\n  ; 第二个输入是0 则跳出,否则仍然引爆炸弹\n  401056:\t74 05                \tje     40105d <phase_4+0x51>\n  ; 引爆炸弹\n  401058:\te8 dd 03 00 00       \tcallq  40143a <explode_bomb>\n  40105d:\t48 83 c4 18          \tadd    $0x18,%rsp\n  401061:\tc3                   \tretq  \n```\n\n又调用了`sscanf`函数，`esi`与`phase_3`中地址相同，因此输入格式又是`\"%d %d\"`\n\n\n\n其调用了一个函数`func4`\n\n```asm\n0000000000400fce <func4>:\n  400fce:\t48 83 ec 08          \tsub    $0x8,%rsp ;申请8字节栈帧\n  ;| phase_4 ret addr |\n  ;|      ...         |\t <- rcx (ecx)   (sscanf 输入2nd)\n  ;|      ...         |  <- rdx (edx)  (sscanf 输入1st)\n  ;|                  | \n  ;| func4  ret addr  |  \n  ;|                  |  <- rsp\n  ; 初次调用:edx=14,esi=0, edi = sscanf input 1\n  ; 此前edx被赋值为0xe=14,现eax=14\n  400fd2:\t89 d0                \tmov    %edx,%eax\n  ; eax=eax-esi  更新eax\n  400fd4:\t29 f0                \tsub    %esi,%eax\n  ; ecx=eax\n  400fd6:\t89 c1                \tmov    %eax,%ecx\n  ; 将ecx逻辑右移(加0右移)31位,ecx长为32位,也就是之前的最高位变为最低位,其余31位填充补0\n  400fd8:\tc1 e9 1f             \tshr    $0x1f,%ecx\n  ; eax=eax+(eax最高位)\n  400fdb:\t01 c8                \tadd    %ecx,%eax\n  ; 这里是一个缩写 sar $1,%eax (对应的机器码为 D1F8)  eax = eax/2\n  400fdd:\td1 f8                \tsar    %eax\n  ; ecx= rax+rsi\n  400fdf:\t8d 0c 30             \tlea    (%rax,%rsi,1),%ecx\n  ; ecx和edi比较\n  400fe2:\t39 f9                \tcmp    %edi,%ecx\n  ; ecx小于等于edi则跳至另一个递归方案\n  400fe4:\t7e 0c                \tjle    400ff2 <func4+0x24>\n  ; 否则 edx=rcx-1\n  400fe6:\t8d 51 ff             \tlea    -0x1(%rcx),%edx\n  ; 递归调用func4\n  400fe9:\te8 e0 ff ff ff       \tcallq  400fce <func4>\n  ; eax=2*eax\n  400fee:\t01 c0                \tadd    %eax,%eax\n  ; 本层递归结束,递归出口，回上一层递归\n  400ff0:\teb 15                \tjmp    401007 <func4+0x39>\n  ; 另一个递归方案 , eax清零\n  400ff2:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400ff7:\t39 f9                \tcmp    %edi,%ecx\n  ; 递归出口,回上一层递归\n  400ff9:\t7d 0c                \tjge    401007 <func4+0x39>\n  400ffb:\t8d 71 01             \tlea    0x1(%rcx),%esi\n  400ffe:\te8 cb ff ff ff       \tcallq  400fce <func4>\n  401003:\t8d 44 00 01          \tlea    0x1(%rax,%rax,1),%eax\n  ; 返回\n  401007:\t48 83 c4 08          \tadd    $0x8,%rsp\n  40100b:\tc3                   \tretq  \n```\n\n尝试将func4由汇编翻译回`C`代码，\n\n```c\n#include <stdio.h>\nint func4(int edi, int esi, int edx) {\n    int temp = (edx - esi);\n    int ecx=(temp>>31)&(0x0001);\n    temp+=ecx;\n    temp=temp>>1;\n    int mid = temp + esi;\n    if (mid > edi) {\n        edx = mid - 1;\n        int ret1 = func4(edi, esi, edx);\n        return 2 * ret1;\n    } else {\n        if (mid >= edi) {\n            return 0;\n        } else {\n            esi = mid + 1;\n            int ret2 = func4(edi, esi, edx);\n            return (2 * ret2 + 1);\n        }\n    }\n}\nint main() {\n    for (int edi = 0; edi < 10; edi++) {\n        int res = func4(edi, 0, 14);\n        printf(\"edi=%d, res=%d\\n\", edi, res);\n    }\n    return 0;\n}\n```\n\n```bash\n> gcc -o test .\\bombPhase4.c\n> .\\test.exe\nedi=0, res=0\nedi=1, res=0\nedi=2, res=4\nedi=3, res=0\nedi=4, res=2\nedi=5, res=2\nedi=6, res=6\nedi=7, res=0\nedi=8, res=1\nedi=9, res=1\n```\n\n因此，**7 0、3 0 、1 0**等均可\n\n#### 第五个炸弹\n\n查看`phase_5`代码\n\n```asm\n0000000000401062 <phase_5>:\n  401062:\t53                   \tpush   %rbx ; rbx入栈,本函数要使用rbx\n  401063:\t48 83 ec 20          \tsub    $0x20,%rsp ; 申请0x20=32字节大小的栈帧\n  ;|   phase_5 ret addr   |\n  ;|        %rbx          |\n  ;|                      |\n  ;|                      |\n  ;|                      |\n  ;|                      | <-rsp\n  \n  401067:\t48 89 fb             \tmov    %rdi,%rbx\t; rbx=rdi (rdi=&输入字符串,可由read_line分析得到) \n  ; 反汇编的at&t风格代码\n  40106a:\t64 48 8b 04 25 28 00 \tmov    %fs:0x28,%rax ;把fs选择子的偏移值0x28(64bit)放入rax(64bit暂存器)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n  401071:\t00 00 \n  401073:\t48 89 44 24 18       \tmov    %rax,0x18(%rsp)\n  ;|   phase_5 ret addr   |\n  ;|        %rbx          |\n  ;|        %rax          |\n  ;|                      |\n  ;|                      |\n  ;|                      | <-rsp\n  \n  401078:\t31 c0                \txor    %eax,%eax ; eax清零\n  40107a:\te8 9c 02 00 00       \tcallq  40131b <string_length> ; 猜测是获取字符串长度返回eax\n  40107f:\t83 f8 06             \tcmp    $0x6,%eax ; 判断输入字符串长度是否是6\n  ; 如果长度是6,跳转L2 清零eax(rax低32位,这里可视为rax)\n  401082:\t74 4e                \tje     4010d2 <phase_5+0x70>\n  ; 长度不是6,引爆炸弹\n  401084:\te8 b1 03 00 00       \tcallq  40143a <explode_bomb>\n  401089:\teb 47                \tjmp    4010d2 <phase_5+0x70>\n  ; L1 跳回 循环点   初次从L2跳来, eax为零\n  ; 这里是根据输入的6字节字符串低4位为序号从另一个字符串中取字符存到栈的rsp+0x10为最低地址处\n  40108b:\t0f b6 0c 03          \tmovzbl (%rbx,%rax,1),%ecx ; ecx= rbx(&输入字符串)+rax(当前匹配的字符序号)\n  40108f:\t88 0c 24             \tmov    %cl,(%rsp) ; 在栈顶存储%cl (rcx最低字节)\n  401092:\t48 8b 14 24          \tmov    (%rsp),%rdx \t; rdx=%cl\n  401096:\t83 e2 0f             \tand    $0xf,%edx \t; edx高位清零,只留下最低4位\n  401099:\t0f b6 92 b0 24 40 00 \tmovzbl 0x4024b0(%rdx), %edx ; edx= M[0x4024b0+%rdx]零扩展字节至双字\n  4010a0:\t88 54 04 10          \tmov    %dl,0x10(%rsp,%rax,1); M[rsp+rax+0x10]处存入%dl(%edx低字节)\n  4010a4:\t48 83 c0 01          \tadd    $0x1,%rax\t; rax++ , rax存放的应该是当前匹配的字符序号\n  4010a8:\t48 83 f8 06          \tcmp    $0x6,%rax\t; 比较取完没\n  4010ac:\t75 dd                \tjne    40108b <phase_5+0x29> ; 没有取完全部6个,返回L1循环\n  \n  ; rsp+0x10---rsp+0x15 存储的取出的新6字节字符串 , 将 rsp+0x16清零,即字符串末尾标志'\\0'\n  4010ae:\tc6 44 24 16 00       \tmovb   $0x0,0x16(%rsp)\n  ; esi 存储 要和比较的字符串基址\n  4010b3:\tbe 5e 24 40 00       \tmov    $0x40245e,%esi\n  ; rdi 存储 rsp+0x10,即新字符串的地址\n  4010b8:\t48 8d 7c 24 10       \tlea    0x10(%rsp),%rdi\n  ;进行比较;\n  ;由之前分析strings_not_equal函数使用edi和esi中的值当做两个字符址，并且判断他们是否相等，相等返回0\n  4010bd:\te8 76 02 00 00       \tcallq  401338 <strings_not_equal>\n  ; 判断返回值是否是0\n  4010c2:\t85 c0                \ttest   %eax,%eax\n  ; 为零说明完全匹配成功,跳到L3退出\n  4010c4:\t74 13                \tje     4010d9 <phase_5+0x77>\n  ; 不为零说明无法完全匹配,爆炸\n  4010c6:\te8 6f 03 00 00       \tcallq  40143a <explode_bomb>\n  4010cb:\t0f 1f 44 00 00       \tnopl   0x0(%rax,%rax,1)\n  4010d0:\teb 07                \tjmp    4010d9 <phase_5+0x77>\n  ;L2 eax清零后跳回L1\n  4010d2:\tb8 00 00 00 00       \tmov    $0x0,%eax \n  4010d7:\teb b2                \tjmp    40108b <phase_5+0x29>\n  ;L3:\n  4010d9:\t48 8b 44 24 18       \tmov    0x18(%rsp),%rax\n  4010de:\t64 48 33 04 25 28 00 \txor    %fs:0x28,%rax\n  4010e5:\t00 00 \n  4010e7:\t74 05                \tje     4010ee <phase_5+0x8c>\n  4010e9:\te8 42 fa ff ff       \tcallq  400b30 <__stack_chk_fail@plt>\n  4010ee:\t48 83 c4 20          \tadd    $0x20,%rsp\n  4010f2:\t5b                   \tpop    %rbx\n  4010f3:\tc3                   \tretq   \n```\n\n1. 要求输入6个字符，然后依次循环这个输入的字符数组\n2. 每一轮循环取一个字符，然后取这个字符的后四位作为索引，在第二个字符常量`0x4024b0`处取一个字符依次存放到`%rsp+0x10+i`处\n\n ```bash\n(gdb) print (char*)0x4024b0\n$1 = 0x4024b0 <array> \"maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?\"\n ```\n\n​\t3. 将新`0x10(%rsp)`处的字符串和`0x40245e`处的字符串比较，相同则通过，否则爆炸\n\n```bash\n(gdb) print (char*)0x40245e\n$2 = 0x40245e \"flyers\"\n```\n\n由于低4位只能表示0-15,因此只能从`<array>: maduiersnfotvbyl`取得\n\n`f :array[9] 1001=9`，查找`ASCII`表低位为9的字符:`)9IYiy`\n\n`l :array[15] 1111`=F, `/?O_0`\n`y :array[14] 1110=E ` , `.>N^n~`\n\n`e :array[5] 5`,`%5EUeu`\n\n`r :array[6] 6`, `&6FVfv`\n\n`s :array[7] 7`, `,7GWgw`\n\n答案多种，如**`YONEFw` 、`y?nevw`**\n\n`string_length`代码\n\n```asm\n000000000040131b <string_length>:\n  40131b:\t80 3f 00             \tcmpb   $0x0,(%rdi)\n  40131e:\t74 12                \tje     401332 <string_length+0x17>\n  401320:\t48 89 fa             \tmov    %rdi,%rdx\n  401323:\t48 83 c2 01          \tadd    $0x1,%rdx\n  401327:\t89 d0                \tmov    %edx,%eax\n  401329:\t29 f8                \tsub    %edi,%eax\n  40132b:\t80 3a 00             \tcmpb   $0x0,(%rdx)\n  40132e:\t75 f3                \tjne    401323 <string_length+0x8>\n  401330:\tf3 c3                \trepz retq \n  401332:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401337:\tc3                   \tretq   \n```\n\n结合`read_line`，应该是获取`rdi`为地址的字符串的长度返回给`eax(rax)`\n\n#### 第六个炸弹\n\n查看`phase_6`代码\n\n```asm\n00000000004010f4 <phase_6>:\n  4010f4:\t41 56                \tpush   %r14\n  4010f6:\t41 55                \tpush   %r13\n  4010f8:\t41 54                \tpush   %r12\n  4010fa:\t55                   \tpush   %rbp\n  4010fb:\t53                   \tpush   %rbx ; 寄存器入栈,将要被本函数调用\n  \n  4010fc:\t48 83 ec 50          \tsub    $0x50,%rsp; 申请80字节的栈帧\n  ;|  phase_6 ret addr  |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    | <- rsp <- r13 <- rsi\n  401100:\t49 89 e5             \tmov    %rsp,%r13\n  401103:\t48 89 e6             \tmov    %rsp,%rsi\n  \n  ;调用读取6数字函数,内部调用了sscanf\n  ;sscanf参数顺序分别是，\n  ;待读取内容的字符串(rdi)、\n  ;用于格式读取的格式化字符串(rsi)，\n  ;还有各个变量读取后存放的地址(rdx)。\n  ; <read_six_numbers>中,%rdx由 %rsi 给出，%rsi 在 phrase6中 又由 %rsp 给出\n  ; 因此输入的数字存到phase_6的%rsp处\n  ;返回读到的有效数据个数\n  401106:\te8 51 03 00 00       \tcallq  40145c <read_six_numbers>\n  ;读入了 6 个数字，分别放入了 %rsp+0x0、%rsp+0x4、%rsp+0x8、%rsp+0xc、%rsp+0x10、%rsp+0x14\n  40110b:\t49 89 e6             \tmov    %rsp,%r14 \n  ; 先将r12(d低32位)置零\n  ; r12 用于计数L4循环\n  40110e:\t41 bc 00 00 00 00    \tmov    $0x0,%r12d\n  ;====================================================================\n  ;L4\n  401114:\t4c 89 ed             \tmov    %r13,%rbp\n  ; 初始情况\n  ;|  phase_6 ret addr  |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|  num6     num5     |\n  ;|  num4     num3     |\n  ;|  num2     num1     | <- rsp r13 r14 rbp rsi\n  \n  ; eax赋值为r13指向的内存数据\n  401117:\t41 8b 45 00          \tmov    0x0(%r13),%eax\n  ; eax=eax-1\n  40111b:\t83 e8 01             \tsub    $0x1,%eax\n  ; 将eax与 5比较\n  40111e:\t83 f8 05             \tcmp    $0x5,%eax\n  ; eax无符号<=5,跳过起爆函数至L1,否则爆炸,即原数据<=6\n  401121:\t76 05                \tjbe    401128 <phase_6+0x34>\n  401123:\te8 12 03 00 00       \tcallq  40143a <explode_bomb>\n  ;L1: %r12d(r12低32位)++\n  401128:\t41 83 c4 01          \tadd    $0x1,%r12d\n  ; 将r12d与6做比较\n  40112c:\t41 83 fc 06          \tcmp    $0x6,%r12d\n  ; r12=6则跳转至L2\n  401130:\t74 21                \tje     401153 <phase_6+0x5f>\n  ; 否则 ebx=r12d \n  401132:\t44 89 e3             \tmov    %r12d,%ebx\n  ;L3: rax= ebx符号扩展4字 假设r12d=i\n  401135:\t48 63 c3             \tmovslq %ebx,%rax\n  ; rax= M[rsp+4*rax]  假设r12d=i , 则rax=num(i)\n  401138:\t8b 04 84             \tmov    (%rsp,%rax,4),%eax\n  ; eax(rax)= num(i+1)与 M[rbp]=M[r13]=num(i)进行比较\n  40113b:\t39 45 00             \tcmp    %eax,0x0(%rbp)\n  ;不相等跳过爆炸函数\n  40113e:\t75 05                \tjne    401145 <phase_6+0x51>\n  ; 相等起爆\n  401140:\te8 f5 02 00 00       \tcallq  40143a <explode_bomb>\n  ; 跳过起爆函数 ebx++\n  401145:\t83 c3 01             \tadd    $0x1,%ebx\n  ; 比较ebx和5\n  401148:\t83 fb 05             \tcmp    $0x5,%ebx\n  ; ebx<=5 跳转回L3,下一个num\n  40114b:\t7e e8                \tjle    401135 <phase_6+0x41>\n  ; ebx>=6, r13+=4\n  40114d:\t49 83 c5 04          \tadd    $0x4,%r13\n  ; 跳回L4,将 r13 rbp等寄存器调整为指向栈中下一个num\n  401151:\teb c1                \tjmp    401114 <phase_6+0x20>\n  ;==================================================================\n  ;上述代码的作用是,确保输入的6个数字均<=6，并且num(i)不和num(i+1)~num(6)相同 \n  ; 1<=i<=5\n  ;==================================================================\n  \n  \n  ;L2: r12=6跳转点;跳出上面的检查循环\n  401153:\t48 8d 74 24 18       \tlea    0x18(%rsp),%rsi\n  401158:\t4c 89 f0             \tmov    %r14,%rax\n  ;|  phase_6 ret addr  |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    | <- rsi\n  ;|  num6     num5     |\n  ;|  num4     num3     |\n  ;|  num2     num1     | <- rsp r14 rax\n  \n  40115b:\tb9 07 00 00 00       \tmov    $0x7,%ecx\n  ;L5: 循环,  num[i]=7-num[i] 6个输入数字全部对7求补\n  401160:\t89 ca                \tmov    %ecx,%edx\n  ; rcx=7, rdx=7\n  401162:\t2b 10                \tsub    (%rax),%edx; edx=7-num(rax point)\n  ; num(rax point)= edx=7-num(rax point) \n  401164:\t89 10                \tmov    %edx,(%rax)\n  ; rax+=4指向下一个num\n  401166:\t48 83 c0 04          \tadd    $0x4,%rax\n  ; 判断 rax指完所有num没有\n  40116a:\t48 39 f0             \tcmp    %rsi,%rax\n  ; 没指完，跳转L5继续指\n  40116d:\t75 f1                \tjne    401160 <phase_6+0x6c>\n  \n  ;================================================================\n  ; esi清零\n  40116f:\tbe 00 00 00 00       \tmov    $0x0,%esi\n  ; 无条件跳转至L6\n  401174:\teb 21                \tjmp    401197 <phase_6+0xa3>\n  ; L7: L6处理完后跳回点\n  401176:\t48 8b 52 08          \tmov    0x8(%rdx),%rdx ; rdx= M[rdx+8]; 而edx赋了个地址,数据大小是8字节\n  40117a:\t83 c0 01             \tadd    $0x1,%eax ; eax+=1\n  40117d:\t39 c8                \tcmp    %ecx,%eax ; 将eax和ecx比较\n  ; eax ecx不相等跳回L7\n  40117f:\t75 f5                \tjne    401176 <phase_6+0x82>\n  ; eax ecx相等跳到L9\n  401181:\teb 05                \tjmp    401188 <phase_6+0x94>\n  ;L8 : L6中ecx<=1跳回点\n  401183:\tba d0 32 60 00       \tmov    $0x6032d0,%edx; 同样也把edx赋地址值0x6032d0\n  ;L9 把rdx存储的数据(即从0x6032d0+OFFSET)处获取的数据存入栈中 M[rsp+0x20++2*rsi]\n  401188:\t48 89 54 74 20       \tmov    %rdx,0x20(%rsp,%rsi,2)\n  40118d:\t48 83 c6 04          \tadd    $0x4,%rsi; rsi+=4\n  401191:\t48 83 fe 18          \tcmp    $0x18,%rsi; 判断rsi是否等于0x18=24,即循环6次了\n  ; 循环6次,栈rsp+0x20+OFFSET存入6个8字节数据了,跳到L10\n  401195:\t74 14                \tje     4011ab <phase_6+0xb7>\n  ;L6\n  ; ecx= M[rsp+rsi] ; 注意40116f把esi清零 ecx=M[rsp+rsi]=num(1...6)\n  401197:\t8b 0c 34             \tmov    (%rsp,%rsi,1),%ecx\n  ; 将ecx(num1)与1比较\n  40119a:\t83 f9 01             \tcmp    $0x1,%ecx\n  ; ecx(num1)有符号<= 1跳回L8\n  40119d:\t7e e4                \tjle    401183 <phase_6+0x8f>\n  ; eax=1\n  40119f:\tb8 01 00 00 00       \tmov    $0x1,%eax\n  ; edx=0x6032d0,是一个地址\n  4011a4:\tba d0 32 60 00       \tmov    $0x6032d0,%edx\n  ; 跳回L7\n  4011a9:\teb cb                \tjmp    401176 <phase_6+0x82>\n  ;================================================================\n  ;作用是访问一个链表，链表的首地址为 0x6032d0，针对输入的第 i 个数，\n  ;按照 num[i] 的值获取链表第 num[i] 个节点，\n  ;并把节点首地址放入 %rsp+0x20+0x0~%rsp+0x20+0x28 刚好是 6 个节点。\n  ;================================================================\n  \n  ;L10:  \n  4011ab:\t48 8b 5c 24 20       \tmov    0x20(%rsp),%rbx\n  4011b0:\t48 8d 44 24 28       \tlea    0x28(%rsp),%rax\n  4011b5:\t48 8d 74 24 50       \tlea    0x50(%rsp),%rsi\n  4011ba:\t48 89 d9             \tmov    %rbx,%rcx\n  4011bd:\t48 8b 10             \tmov    (%rax),%rdx\n  4011c0:\t48 89 51 08          \tmov    %rdx,0x8(%rcx)\n  4011c4:\t48 83 c0 08          \tadd    $0x8,%rax\n  4011c8:\t48 39 f0             \tcmp    %rsi,%rax\n  4011cb:\t74 05                \tje     4011d2 <phase_6+0xde>\n  4011cd:\t48 89 d1             \tmov    %rdx,%rcx\n  4011d0:\teb eb                \tjmp    4011bd <phase_6+0xc9>\n  4011d2:\t48 c7 42 08 00 00 00 \tmovq   $0x0,0x8(%rdx)\n  4011d9:\t00 \n  4011da:\tbd 05 00 00 00       \tmov    $0x5,%ebp\n  \n  ;%rsp+0x20+0x0~ %rsp+0x20+0x28 存储的链表节点地址指向的数值必须是递减的。低地址存的数据要更大\n  ; rax= M[rbx+8]\n  4011df:\t48 8b 43 08          \tmov    0x8(%rbx),%rax\n  ; eax= M[rax]\n  4011e3:\t8b 00                \tmov    (%rax),%eax\n  ; 比较M[rax]=M[rbx+8]和M[rbx], 32位数据\n  4011e5:\t39 03                \tcmp    %eax,(%rbx)\n  ;若不爆炸需要M[rbx]>=M[rbx+8]\n  4011e7:\t7d 05                \tjge    4011ee <phase_6+0xfa>\n  4011e9:\te8 4c 02 00 00       \tcallq  40143a <explode_bomb>\n  4011ee:\t48 8b 5b 08          \tmov    0x8(%rbx),%rbx\n  4011f2:\t83 ed 01             \tsub    $0x1,%ebp\n  4011f5:\t75 e8                \tjne    4011df <phase_6+0xeb>\n  4011f7:\t48 83 c4 50          \tadd    $0x50,%rsp\n  \n  \n  4011fb:\t5b                   \tpop    %rbx\n  4011fc:\t5d                   \tpop    %rbp\n  4011fd:\t41 5c                \tpop    %r12\n  4011ff:\t41 5d                \tpop    %r13\n  401201:\t41 5e                \tpop    %r14\n  401203:\tc3                   \tretq   \n```\n\n用`gdb`查看`0x6032d0`开始的数据,根据`401176`以8字节为单位查看\n\n```bash\n(gdb) x /6gx 0x6032d0\n0x6032d0 <node1>:\t0x00000001 0000014c\t  0x00000000 006032e0\n0x6032e0 <node2>:\t0x00000002 000000a8\t  0x00000000 006032f0\n0x6032f0 <node3>:\t0x00000003 0000039c\t  0x00000000 00603300\n```\n\n访问一个链表，链表的首地址为 `0x6032d0`，针对输入的第 `i` 个数，按照 `a[i]` 的值获取链表第 `a[i]` 个节点，并把节点首地址放入 `%rsp+0x20+0x0`~ 到 `%rsp+0x20+0x28` 刚好是 6 个节点。\n\n| 地址     | 数据       |\n| -------- | ---------- |\n| 0x6032d0 | 0x0000014c |\n| 0x6032d4 | 0x00000001 |\n| 0x6032d8 | 0x006032e0 |\n| 0x6032dc | 0x00000000 |\n| 0x6032e0 | 0x000000a8 |\n| 0x6032e4 | 0x00000002 |\n| 0x6032e8 | 0x006032f0 |\n| 0x6032ec | 0x00000000 |\n| 0x6032f0 | 0x0000039c |\n\n```bash\n(gdb) x /wx 0x6032d0\n0x6032d0 <node1>:\t0x0000014c # 链表结点1 data的低32位,由于输入的数据是int 32位，可以先不看高32位data 5\n(gdb) x /wx 0x6032d0+8\n0x6032d8 <node1+8>:\t0x006032e0 # 结点1存储的结点2的地址\n\n(gdb) x /wx 0x6032e0\n0x6032e0 <node2>:\t0x000000a8 # data 6\n(gdb) x /wx 0x6032e0+8\n0x6032e8 <node2+8>:\t0x006032f0 # addr\n\n(gdb) x /wx 0x6032f0\n0x6032f0 <node3>:\t0x0000039c # data 1\n(gdb) x /wx 0x6032f0+8\n0x6032f8 <node3+8>:\t0x00603300 # addr\n\n(gdb) x /wx 0x603300\n0x603300 <node4>:\t0x000002b3 #data 2\n(gdb) x /wx 0x603300+8\n0x603308 <node4+8>:\t0x00603310 # addr\n\n(gdb) x /wx 0x603310\n0x603310 <node5>:\t0x000001dd #data 3\n(gdb) x /wx 0x603310+8\n0x603318 <node5+8>:\t0x00603320 # addr\n\n(gdb) x /wx 0x603320\n0x603320 <node6>:\t0x000001bb #data 4\n(gdb) x /wx 0x603320+8\n0x603328 <node6+8>:\t0x00000000\n```\n\n一共6个结点，第一个结点地址数据存在`%rsp+0x20+0x0`处，这个地址数据指向的结点data应该最大，由于比较`cmp`的是32位数据，只需要注意地址指向数据的低32位。\n\n最大的数据是`0x0000039c`，是第3个结点， 此时的num1=3，\n\n第2大的数据是`0x000002b3` ，第4个结点 num2=4\n\n第3大的数据是`0x000001dd` ，第5个结点 num3=5\n\n第4大的数据是`0x000001bb` ，第6个结点 num4=6\n\n第5大的数据是`0x0000014c` ，第1个结点 num5=1\n\n第6大的数据是`0x000000a8` ，第2个结点 num3=2\n\n`num=[3,4,5,6,1,2]`\n\n但是注意这是把输入的`num`进行了`num=7-num`\n\n所以输入是\n\n`num=[4,3,2,1,6,5]`\n\n最终答案是**4 3 2 1 6 5 **","tags":["计算机组成原理"]},{"title":"微机原理-第三章-内存储器习题","url":"/2020/09/28/80X86-chapter3-Memory/","content":"\n### 3.8\n\n#### 3.8.1\n\n$512\\times 1b$的RAM芯片表示其有512个数据地址，每个数据1bit，要组成$16K\\times 8b$的存储矩阵，需要\n$$\n\\frac{16K}{512}\\times\\frac{8b}{1b}=32\\times8=256\n$$\n个RAM芯片，为保证实现每个数据8bit，需要分组，一组由8个$512\\times 1b$RAM芯片组成，为保证有$16K$个数据地址，每组只有512个地址，因此需要32组。\n\nRAM芯片数：256\n\n片内地址位数：$log_2{512}=9$\n\n片选地址位数(芯片选择端)：$log_2{\\frac{16K}{512}}=5$\n\n<!-- more -->\n\n#### 3.8.2\n\nRAM芯片数：$\\frac{16K}{1024}\\times\\frac{1b}{8b}=16\\times8=128$\n\n片内地址位数：$log_2{1024}=10$\n\n片选地址位数(芯片选择端)：$log_2{16}=4$\n\n#### 3.8.3\n\nRAM芯片数：$\\frac{16K}{2K}\\times\\frac{8b}{4b}=8\\times2=16$\n\n片内地址位数：$log_2{2K}=11$\n\n片选地址位数(芯片选择端)：3\n\n#### 3.8.4\n\nRAM芯片数：$\\frac{16K}{8K}\\times\\frac{8b}{8b}=2$\n\n片内地址位数：$log_2{8K}=13$\n\n片选地址位数(芯片选择端)：1\n\n### 3.14\n\nRAM芯片数：$\\frac{16K}{4k}\\times\\frac{8b}{1b}=4\\times8=32$\n\n片内寻址位数：$log_2{4K}=12$，因此低12位$A_0 - A_{11}$作为片内寻址\n\n片选地址位数：$14-12=2$，$A_{12},A_{13}$作为片选信号\n\n### 3.17\n\n采用字结构方式组织\n\n 2764为$8K\\times 8$结构，13根地址线，8根数据线\n\n* 字结构方式：一个字节的8位制作在一块芯片上，选中芯片可一次性读/写8位信息，封装时引线较多。例如：1K的存储器芯片由128×8组成，访问它要7根地址线和8根数据线。\n* 位结构方式：1个芯片内的基本单元作不同字的同一位，8位由8块芯片组成。优点是芯片封装时引线少，例如： 1 K存储器芯片由1024×1组成，访问它要10根地址线和1根数据线。\n\n由题干，地址区域为`00000H`至`0000 0111 1111 1111 1111H`，因此$A_{19}-A_{15}$为0，用$A_{19}-A_{17}$经过负与门产生$G_1$，$A_{16}$产生${G2}^- A^-$，$A_{15}$产生${G2}^- B^-$，$A_{14}-A_{13}$经过74LS138产生片选信号送至4个芯片，$A_0-A{12}$作为地址线\n\n![image-20200928174748637](https://i.loli.net/2020/09/28/qIPTkhexXAzcjGs.png)","tags":["计算机组成原理"]},{"title":"LeetCode-139-单词拆分","url":"/2020/09/27/LeetCode-139/","content":"\n### [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)\n\n\n\n给定一个**非空**字符串 *s* 和一个包含**非空**单词列表的字典 *wordDict*，判定 *s* 是否可以被空格拆分为一个或多个在字典中出现的单词。\n\n这是一个行内数学公式：$\\begin{vmatrix} a & b \\\\ c & d \\end{vmatrix}$\n\n这个数学公式会换行显示：\n$$\\begin{vmatrix} a & b \\\\ c & d \\end{vmatrix}$$\n\n**说明：**\n\n- 拆分时可以重复使用字典中的单词。\n- 你可以假设字典中没有重复的单词。\n<!-- more -->\n\n#### example\n\n**示例 1：**\n\n```\n输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n输出: true\n解释: 返回 true 因为 \"leetcode\" 可以被拆分成 \"leet code\"。\n```\n\n**示例 2：**\n\n```\n输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\n输出: true\n解释: 返回 true 因为 \"applepenapple\" 可以被拆分成 \"apple pen apple\"。\n     注意你可以重复使用字典中的单词。\n```\n\n**示例 3：**\n\n```\n输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n输出: false\n```\n#### Dynamic Programming\n\n**思路：动态规划**\n\n要判断的字符串s长度是$s.length()$，假设字符串是`ABC`,可以划分的方案有:\n\n1. `[NULL],[ABC]`\n2. `[A],[BC]`\n3. `[AB],[C]`\n\n一共有$s.length()$种划分方案，分别判断每种划分方案产生的子字符串时候都满足可由字典匹配的要求，如果某种划分方案的两个子字符串都可以被匹配，说明原字符串可以被匹配。\n\n对于划分的左部分字符串，可以在划分原字符串的左边一部分时就得知，用数组$DP[\\quad]$来存储已经知道的左部字符串能否匹配的信息。也就是：\n\n​                                                       $DP[i]:\\quad$表示字符串$s[0...i-1]$能否被字典所匹配\n\n那么对于$j>i$，$DP[j]$$就可以表示成：\n\n​\t\t                                              $DP[j]=(DP[i])\\&\\&(s[i...j-1])$是否可被匹配\n\n对$0\\leq i<j$的所有$i$进行枚举，计算可能的$DP[j]$的值，当有一个值是`true`，就说明字符串$s[0...i-1]$能被字典所匹配，无需再继续枚举\n\n#### Boundary Condition\n\n**临界条件处理：**\n\n对于每个字符串划分时的第一种情况，由于产生了空串$NULL$，根据通常情况的循环表达式：\n\n```java\nfor(int j=1;j<nums.length();j++)\n  \tfor(int i=0;i<j;i++){\n        //计算当前情况得到的DP[j],DP[j]=DP[i]&&(s[i...j-1]是否可以匹配)\n\t}\n```\n\n可以看到，循环表达式处理空串划分情况是$DP[0]$和$s[0...j-1]$，说明$DP[0]$用来表示空串的情况，所以默认要将$DP[0]$初始化为$true$\n\n**$s[i....j-1]$** **的处理：**\n\n将所给字典构建一个哈希集合进行映射，利用`.contains()`来判断$s[i....j-1]$是否能被字典某个元素匹配.\n\n#### Java Code\n\n\n```java\nclass Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        Set<String>Dictionary=new HashSet(wordDict);\n        boolean DP[]=new boolean[s.length()+1];\n        DP[0]=true;\n        for(int i=1;i<=s.length();i++){\n            for(int j=0;j<i;j++){\n                if(DP[j]){\n                    if(Dictionary.contains(s.substring(j,i))){\n                        DP[i]=true;\n                        break;\n                    }\n                }\n            }\n        }\n        return DP[s.length()];\n    }\n}\n```\n\n","tags":["LeetCode"]},{"title":"LeetCode-91-解码方法","url":"/2020/09/27/LeetCode-91/","content":"\n\n\n### [91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)\n\n测试，一条包含字母 `A-Z` 的消息通过以下方式进行了编码：\n\n```\n'A' -> 1\n'B' -> 2\n...\n'Z' -> 26\n```\n\n给定一个只包含数字的**非空**字符串，请计算解码方法的总数。\n\n我的`LeetCode`笔记仓库：https://github.com/Waldenth/My-LeetCode\n\n<!-- more -->\n\n**示例 1:**\n\n```\n输入: \"12\"\n输出: 2\n解释: 它可以解码为 \"AB\"（1 2）或者 \"L\"（12）。\n```\n\n**示例 2:**\n\n```\n输入: \"226\"\n输出: 3\n解释: 它可以解码为 \"BZ\" (2 26), \"VF\" (22 6), 或者 \"BBF\" (2 2 6) 。\n```\n\n#### Dynamic Programming\n\n设`DP[i]`表示字符串`s[0...i]`的编码数量，考虑`DP[i]`和`DP[i-1],DP[i-2],DP[i-3]...`之间的联系，\n\n首先考虑`i`的一般情况，若`s[i]='0'`，那么其自身必然不能构成一个编码，必须和前面一个字符一起才可能组成`10,20`两个可能的编码，因此在`s[i]='0'`的情况下：\n\n1. ​\t`s[i-1]='2'or s[i-1]='1'`,此时`s[i-1],s[i]`一起构成一个字母编码,且只有这种情况，所以关系是`DP[i]=DP[i-2]`\n2.  `s[i-1]!='1'and'2'`,此时无法解码，最后一个`0`无法解码，`return 0`\n\n再考虑`'1'<=s[i]<='9'`的情况，其自身可以编码，也可能与前一个`s[i-1]`一起编码，但是有条件\n\n1. ​\t`s[i-1]=1`，此时一起编码对`s[i]`没有要求，`DP[i]=DP[i-1]+DP[i-2]`\n2. `s[i-1]=2`，此时一起编码有条件：\n   1. `'1'<=s[i]<='6'`，可以一起编码，`DP[i]=DP[i-1]+DP[i-2]`\n   2. `7<=s[i]<=9`，不可以一起编码，`DP[i]=DP[i-1]`\n\n再考虑更一般情况，此时最后一个字母不可能与前一个字母一起编码，`DP[i]=DP[i-1]`\n\n#### Boundary Condition\n\n一般情况考虑完，还要考虑特殊情况，前面的表达式要求`i-2>=0`，因此无法把`i=0,1,2`考虑进去，需要特殊考虑。\n\n\n\n1. `i=0`，当前字符串只有一个码，如果是`0`无法编码，返回0，否则`DP[0]=1`\n2. `i=1`，当前字符串有两个码，在`Dynamic Programming`表达式`DP[i]=DP[i-1]+DP[i-2]`中，将`DP[i-2]`退化成0，分析可得`i=1`在这种表达式的情况下，既可以一起编码又可以字符各自单独编码，因此是2，将表达式加入`(i>=2)?(DP[i-1]+DP[i-2]):2`即可。\n\n#### Java Code\n\n```java\nclass Solution {\n    public int numDecodings(String s) {\n        int length=s.length();\n        if(length==0)//空串\n            return 0;\n        int DP[]=new int [length];\n        if(s.charAt(0)=='0')//首数字0,无法匹配\n            return 0;\n        if(length==1)//长度1,非0\n            return 1;\n        DP[0]=1;\n        for(int i=1;i<length;i++){\n            if(s.charAt(i)=='0'){\n                if(s.charAt(i-1)=='1'||s.charAt(i-1)=='2'){\n                    DP[i]=(i>=2) ?(DP[i-2]):(1);\n                }else\n                    return 0;\n            }else if(s.charAt(i-1)=='1'){\n                DP[i]=(i>=2) ? (DP[i-1]+DP[i-2]):2;\n            }else if(s.charAt(i-1)=='2'){\n                if(s.charAt(i)<='6'&&s.charAt(i)>='1'){\n                    DP[i]=(i>=2)?(DP[i-1]+DP[i-2]):2;\n                }else{\n                    DP[i]=DP[i-1];\n                }\n            }else{\n                DP[i]=DP[i-1];\n            }\n        }\n        return DP[length-1];\n    }\n}\n```\n\n","tags":["LeetCode"]},{"title":"磁盘格式与数据恢复实验","url":"/2020/09/27/DiskFormatANDataRecover/","content":"\n## 实验1 磁盘格式与数据恢复\n\n### 1.1实验名称\n\n磁盘格式与数据恢复\n\n### 1.2实验目的\n\n1)    了解磁盘的物理和逻辑结构\n\n2)    熟悉FAT32文件系统\n\n3)    学会使用磁盘编辑软件\n\n4)    了解文件删除、格式化的基本原理\n\n5)    能够利用工具或者手工恢复被删除的文件\n\n<!-- more -->\n\n### 1.3实验步骤及内容\n\n**第一阶段：**\n\n熟悉WinHex的使用。\n\nn 熟悉磁盘工具的使用。\n\nn 利用WinHex查看物理磁盘和逻辑磁盘。\n\nn 了解WinHex中相关工具的用法。\n\n \n\n**第二阶段：**\n\nn 分析本地硬盘的主引导扇区\n\nn 利用磁盘编辑工具查看MBR磁盘分区并分析：\n\nn 主引导扇区由哪些部分组成？\n\nn 四个主分区项的内容各代表什么？\n\nn 分析主扩展分区表的结构。\n\nn 通过分区项来确定每个本地逻辑盘的位置以及大小，并画出本地硬盘的逻辑结构。\n\nn 每个本地盘的开始扇区位置，总扇区数，结束扇区位置，各扩展分区表扇区位置，保留空间数量。\n\nn  利用磁盘编辑工具查看GPT磁盘分区并分析\n\nn GPT分区结构与MBR的具体差异有哪些？\n\nn 主分区头所在扇区包括哪些重要内容，验证这些重要内容的有效性。\n\nn 通过分区节点分析自己硬盘的各分区信息。\n\n**第三阶段：**\n\nn  熟悉FAT32文件格式。\n\nn 用WinHex打开某个FAT32分区格式的逻辑盘。\n\nn 查看该逻辑盘的起始扇区，分析起始扇区中的相关字段（BPB:BIOS Parameter Block）。\n\nn 查看FAT1和FAT2的内容和大小。\n\nn 查看该逻辑盘的根目录区。\n\nn 查看某个文件的目录项结构和FAT链以及具体存储位置。\n\nn 在根目录下建立文本文件：test-学号后3位.txt，其中填充60K左右的文本字符保存（注意：先行存储其他数据使得该文件的首簇高位不为0）。\n\nn 查看该文件的目录项，对其进行分析，并得到该文件所在位置以及大小。\n\nn 查看首簇位置，并得到簇链表。通过簇链表查看该文件内容。\n\nn 记录首簇位置（14H-15H,1AH-1BH）和文件大小（1CH-1FH）。\n\n \n\n**第四阶段：**\n\nn 手工恢复被删除的文件\n\nn 删除前面所建立的文件。(del&shift+del)\n\nn 利用WinHex在该文件所在盘符查找该.txt文件的目录项。\n\nn 查看目录项的变化。\n\nn 利用该残余目录项来计算被删除的文件所在的位置。\n\nn 手工恢复该文件（文件名、首簇高位、簇链表修复）。\n\n\n\n**课后习题思考：**\n\nn   在磁盘分区过程中，用户提供了哪些信息？分析分区工具的工作原理。\n\nn  高级格式化与低级格式化的具体原理和区别是什么？\n\nn 查找资料，对NTFS分区的总体结构进行分析，尝试对NTFS下删除的文件进行手工恢复。\n\nn   用数据粉碎工具（如金山、360、Strongdisk等）粉碎指定文件，分析其数据粉碎原理。\n\nn  通过分区表看到的分区字节数为何与资源管理器中看到的分区字节数有差异？\n\nn   如果删除的文件是长文件名，如何恢复所有文件名。\n\n\n\n### 1.4实验关键过程、数据及其分析\n\n#### 1.4.1 WinHex的使用\n\n以管理员模式启动WinHex，在选项界面中选择要查看的磁盘，如图1.1所示\n\n​            ![image-20200926231839438](https://i.loli.net/2020/09/26/kvCuXMUqwQ49FD1.png)                       \n\n​               图**1.1** 启动WinHex\n\n\n\n在WinHex操作界面中，选择自己要查看的逻辑盘和物理盘，确定即可打开相应的磁盘查看，如图1.2所示 ，左上角显示的是磁盘的文件目录，左下角显示的是磁盘的数据区数据信息。\n\n​     ![image-20200926231848471](https://i.loli.net/2020/09/26/5pcERn2Ay6rdFbP.png)\n\n​                图**1.2** 利用WinHex查看磁盘\n\n  \n\n由于磁盘快照生成较久，选择更新快照。\n\n \n\n在WinHex中主要使用的工具是进入指定的偏移或地址。选择导航,可以选择相应的功能，如图1.3所示 \n\n​     ![image-20200926231858453](https://i.loli.net/2020/09/26/DEyxN73pnqhiQmK.png)\n\n​              图**1.3** WinHex导航工具的使用\n\n转到偏移量可以选择基地址以及偏移量跳转到自己想要到达的地址；跳至扇区可以通过扇区为单位进行跳转。文件记录功能主要用于文件恢复过程中，利用其跳转到簇链表相应的位置。\n\n在对磁盘进行修改之后，由于WinHex没有更新磁盘信息，需要重新对磁盘进行快照，如图1.4所示。\n\n ![image-20200926231911378](https://i.loli.net/2020/09/26/2NxfwuLUX7SkKZs.png)\n\n​               图**1.4** WinHex重新快照\n\n#### 1.4.2 分析本地硬盘的主引导扇区【GPT＋MBR】\n\n\n\n利用WinHex打开MBR分区形式的磁盘，如图2.1所示，从00开始的512个字节是硬盘的主引导扇区。\n\n ![image-20200926231923158](https://i.loli.net/2020/09/26/TirBOU1yCPbjchq.png)\n\n​               图**2.1** 查看主引导扇区\n\n主引导扇区是硬盘第一个扇区，它由主引导记录(MBR),硬盘主分区表(DPT)和引导扇区标记(ID)三部分组成。\n\n主引导记录MBR：从0至多占用的0x1BDH一共446个字节，存放系统主引导程序。\n\n硬盘主分区表DPT:占用64个字节，0x1BEH – Ox1FDH , 它有四个分区项，每个项16个字节，最后8=4+4个字节存放相对扇区地址和该分区占用的扇区数量。\n\n通过WinHex自带的分区表-模板，查看物理硬盘的结构，如图2.2所示\n\n \n\n​            ![image-20200926231929898](https://i.loli.net/2020/09/26/FLqvs8NZYUklRE6.png)\n\n图**2.2** 分区表模板查看\n\n\n\n可以看到，前1B8个字节是其引导代码，从1BE开始是硬盘分区表，最后以55AA结尾。每一个分区表项的长度是16个字节。如图2.3所示。\n\n ![image-20200926231937004](https://i.loli.net/2020/09/26/ID2Nmlb9Gx7Vjq6.png)\n\n​            图**2.3** 分区表地址数据\n\n以第一个分区为例，分区表从80 20开始，到0F 00结束。00 0F A0 00表示其占有的扇区数，00 00 08 00代表其起始扇区(16进制)。0x800=2048,这与分区信息是对应的，如图2.4所示。\n\n ![image-20200926231942449](https://i.loli.net/2020/09/26/LdG4KwltmkcYI91.png)\n\n​             图**2.4** 分区第一扇区地址\n\n \n\n下面根据WinHex中分区扇区数量计算分区大小并与Windows计算机磁盘管理进行验证。\n\n以E盘为例，根据图2.3，其具有0x00513800=5322752个扇区，一个扇区512字节，因此具有2661376KB=2599MB=2.53GB，与图2.4分区E是对应的。\n\n \n\n扩展分区：主分区表只支持4个分区项目，当分区更多时无法满足，因此需要扩展分区表EBR。要使用扩展分区，首先，主分区表中必须要有一个基本扩展分区项，用于指出所有扩展分区总体信息。所有的扩展逻辑盘全在这个基本扩展分区项指出的主扩展分区中。其结构如图2.5所示。\n\n ![image-20200926231950488](https://i.loli.net/2020/09/26/gVezuUsHtiBOCbZ.png)\n\n图**2.5** 扩展分区和逻辑盘\n\n\n\n查看GPT分区，首先添加一块硬盘，进入cmd，输入命令diskpart，显示挂载在主机上的磁盘，进入磁盘转换。输入命令将其转换为GPT分区格式\n\n ![image-20200926231957708](https://i.loli.net/2020/09/26/5ksNXwEJWKTO9qv.png)\n\n  图**2.6** 转换磁盘分区格式\n\n\n\n使用WinHex打开硬盘1，如图2.7所示\n\n ![image-20200926232005449](https://i.loli.net/2020/09/26/Jmgxs4LqiXvnhu5.png)\n\n  图**2.7** GPT磁盘信息\n\n利用WinHex自带的分区表模板，查看GPT磁盘的分区表信息，如图2.8所示\n\n​     ![image-20200926232036170](https://i.loli.net/2020/09/26/BJ1VLlEnogSQYjw.png)\n\n​                          图**2.8** GPT磁盘分区表\n\n可以看到从1BE-1CA是磁盘保护性的主引导记录MBR，从0x200=512开始是磁盘的分区表。从0x400=1024开始是CPT磁盘的第一个分区表项。\n\n分区表项中存储了对应分区的起始LBA，LBA即逻辑地址块，是GPT分区形式的基本单位，每一个LBA的大小也是512个字节。\n\n分区表项1中，起始LBA块是34，终止LBA块是65569，下面验证分区1的大小：\n\n由分区表项信息，分区1一共有65569-34+1=65536个LBA块，因此有32768KB=32MB，对比图2.7分区1信息，可以发现正确。\n\n \n\nGPT与MBR分区的具体差异：\n\n​    1、MBR分区表最多只能识别2TB左右的空间，大于2TB的容量将无法识别从而导致硬盘空间浪费；GPT分区表则能够识别2TB以上的硬盘空间。\n\n2、MBR分区表最多只能支持4个主分区或三个主分区+1个扩展分区(逻辑分区不限制)；GPT分区表在Windows系统下可以支持128个主分区。\n\n3、在MBR中，分区表的大小是固定的；在GPT分区表头中可自定义分区数量的最大值，也就是说GPT分区表的大小不是固定的。\n\n#### 1.4.3 FAT32文件系统格式分析\n\n\n\n用WinHex打开一个FAT32格式的逻辑盘，如图3.1所示\n\n ![image-20200926232049173](https://i.loli.net/2020/09/26/Fi4BEOPnSe7A3c2.png)\n\n​              图**3.1** FAT32磁盘\n\n \n\n通过WinHex自带的引导扇区模板，查看该逻辑盘的起始扇区，分析起始扇区中的相关字段，如图3.2所示。\n\n \n\n0-3是其固有的字段，从0xB开始，到0x20是该逻辑盘对应的BPB(BIOS Parameter Block，BIOS参数块)字段。通过BPB可以查看这个磁盘的基本信息。如每个扇区的字节数，这里可以看到是512字节，每个簇有8个扇区。\n\n \n\nFAT32 Selection是该FAT32文件系统的一个表，从表中可以看到每一个FAT它的扇区数是5183，最后在偏移量1FE处也是以55AA结尾。\n\n![image-20200926232058111](https://i.loli.net/2020/09/26/wKZADkpriBtHXYS.png)\n\n​               图**3.2** 引导扇区模板\n\n在FAT32文件系统的磁盘中，FAT1和FAT2是存储簇链表的地方，由于FAT区十分重要，故存放两个，作为备份。\n\n在根目录区，建立了每个文件的索引，并记录了每一个文件相关的信息。用WinHex模板打开根目录查看文件，如图3.3所示\n\n ![image-20200926232113509](https://i.loli.net/2020/09/26/TLaQ7J2qz5uvGDk.png)\n\n​                      图**3.3** 查看根目录\n\n本磁盘中存储了hello25.exe文件，通过根目录模板，可以查看它的文件名是HELLO25，扩展名是EXE，创建时间是9/22 23:55，簇高位号是0，文件大小是2560Bytes=2.5KB等等信息。\n\n   在根目录下建立文本文件：test-学号后3位.txt，其中填充60KB左右的文本字符保存。更新磁盘快照，利用WinHex查看txt文件的簇，在左上角文件管理中右键选择该文件，导航->列出的簇，并取消缩短连续簇链表，如图3.4所示。\n\n![image-20200926232216972](https://i.loli.net/2020/09/26/X3IHpRa7qVltNoJ.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图**3.4** 查看根目录\n\n可以看到txt文件的首簇号是506，总共用了13个簇来存储。根据Windows文件属性可以看到，文件实际大小是50.7KB，但是占用了52KB，而图3.4显示文件占用了13个簇，由前面的信息，本系统一个簇是8个扇区，4KB，13个簇正是52KB，这就是文件实际的占用大小。50.7KB文件需占用13个簇才可以存下。\n\n \n\n下面根据文件占用的簇跳转到文件内容的位置。在WinHex中选择导航->跳转到FAT记录->填写首簇号506，跳转到簇链表对应位置。由于是FAT32系统，簇链表中每个结点大小是4个字节，文件占用13个簇，在簇链表中便占据52个字节，如图3.5所示，高亮部分即txt文件的占用的簇链表。\n\n​\t\t\t\t\t\t\t\t ![image-20200926232234479](https://i.loli.net/2020/09/26/AGgKlyOqrDaTLZb.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图**3.5** 文件簇链表\n\n\n\n注意到簇链表首结点值是0x000001FB=507,而文件的首簇号是506，这是因为在FAT32文件系统中，FAT表是连续存储的，访问首簇号结点对应的值默认是首簇号+1.\n\n \n\n记录下文件的簇链表，在WinHex中选择导航->跳至扇区，填写簇506/507，可以发现跳转到txt文件存储处，如图3.6所示。\n\n​\t\t\t\t\t\t ![image-20200926232252109](https://i.loli.net/2020/09/26/l1hRGqpKba7WPS3.png)\t\t\n\n​                            \t\t\t\t\t\t\t\t\t\t\t\t图**3.6** 文件簇链表\n\n\n\n \n\n根据目录项的定义，一个目录项占据32个字节，00H-07H字节是文件的正名，1CH-1FH是文件的占据的字节大小，打开WinHex，利用模板跳转到test-001.txt的目录项所在的位置，如图3.7所示。\n\n![image-20200926232312698](https://i.loli.net/2020/09/26/SDBtVYF8qM7Ej9W.png)\t\t\n\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图**3.7** 查看目录项\n\n可以看到第1AH-1BH=26-27字节是(逆序)  01FA，14H-15H=20-21字节是 0000，组成的首簇号是0x000001FA=506，正是该文件之前查看的首簇号，说明观察正确。而1CH-1FH=28-31是文件占据的字节大小，0x00 00 CB 10=51984Byte=50.765625KB，与文件系统中显示的大小50.8KB保持一致。说明从目录项中正确读取到了文件信息。\n\n#### 1.4.4 手工恢复被删除的文件\n\n\n\n首先使用Del键进行回收站删除，重新建立磁盘快照。在WinHex中查看文件目录，可以看到事实上文件及其对应的数据仍然还存在，如图4.1所示。\n\n ![image-20200926232327821](https://i.loli.net/2020/09/26/RKHYTZeI3LSUbC7.png)\n\n​                    图**4.1** 回收站删除后查看文件\n\n跳转至目录表对应位置，如图4.2所示，\n\n ![image-20200926232335457](https://i.loli.net/2020/09/26/OfCKGvt6o3Raln2.png)\n\n​                      图**4.2** 回收站删除后查看目标表项\n\n \n\n将图4.2和图3.7进行对比，发现目录项首字节在文件删除后被进行了修改成E5，表示被删除标记。选择E5所在字节，右键编辑->填充选块，将E5随便修改成任意数据，选择文件->保存扇区，可以发现文件恢复，如图4.3所示，但是文件名会根据修改数据改变首字母。至此，完成了回收站文件删除后的文件恢复。\n\n ![image-20200926232344488](https://i.loli.net/2020/09/26/XGKcARIVZLi2leF.png)\n\n​                      图**4.3** 恢复文件\n\n再使用shift+delete删除文件EXP.TXT，转到目录项如图4.4所示\n\n ![image-20200926232352588](https://i.loli.net/2020/09/26/zLq9jHMxaudpf6h.png)\n\n​                         图**4.4 删除后目录项**\n\n可以看到目录项也被修改，首字节被修改为E5，首簇号高16位清0，但是复原后并不能打开文件，因为簇链表数据已经丢失.\n\n\n\n查看簇链表，如图4.5所示\n\n ![image-20200926232402349](https://i.loli.net/2020/09/26/SYKNyqFkOj2DdCb.png)\n\n​                               图**4.5**\n\n \n\n可以发现簇链表对应的位置已经全部清0，要恢复文件，必须恢复簇链表再修改目录项。因此现在根据其相邻的目录项来确定其首簇号。可以看到前一个目录项的首簇号是0x00040152，文件的字节大小是0x A00，占用一个簇，因此恢复文件的首簇号是0x00040153，因此依次将图4.5中的项目进行修复，如图4.6所示\n\n ![image-20200926232408684](https://i.loli.net/2020/09/26/vzi2YO3mdkuol6B.png)\n\n​                            图**4.6**\n\n将目录项被修改的首字节和首簇高位修复。如图4.7所示\n\n ![image-20200926232415456](https://i.loli.net/2020/09/26/u4Fkl5XHVBdiGLg.png)\n\n \n\n​                            图**4.7**\n\n保存，打开文件夹，发现文件恢复成功。如图4.8所示\n\n ![image-20200926232421687](https://i.loli.net/2020/09/26/cgeoaFbXxDirQ3W.png)\n\n​                          图**4.8**\n\n \n\n#### 1.4.5 课后习题思考\n\n在磁盘分区过程中，用户提供了要分区的大小，分区的文件格式，盘符等信息。利用分区大小，系统构建新的逻辑盘，利用指定的文件格式，对分区进行格式化。\n\n \n\n低级格式化就是将空白的磁盘划分出柱面和磁道,再将磁道划分为若干个扇区,每个扇区又划分出标识部分ID、间隔区GAP和数据区DATA等。可见,低级格式化是高级格式化之前的一件工作, 高级格式化就是清除硬盘上的数据、生成引导区信息、初始化FAT表、标注逻辑坏道等。\n\n \n\n数据粉碎一般会对文件所在的位置进行重复擦写，粉碎文件之后，利用winhex查看对应偏移量数据可以发现数据已经被完全改写。\n\n \n\n文件名过长时恢复文件后需要手工查看文件数据区的文件名进行恢复\n\n \n\n \n\n1、计算机是以二进制来记录数据的，所以单位从K到M再到G是以1024来进级的。而人们习惯了十进制，以1000来进级。这样造成了显示容量和实际一样。当然，也有些不良厂家以1000为进级计算标注容量，使实际容量缩水。\n\n2、硬盘在分区和格式化时会占用一定的存储空间来保存分区等一些信息，所以实际可用容量就会小于分区的容量。\n\n3、因为硬盘的分区一般都是按扇区为单位分的（每个扇区的大小一般从几KB到几百KB，不同硬盘和格式不完全相同），所以人为输入的分区容量不一定是扇区的整数倍，系统会自动取近似的容量来划分分区。\n\n### 1.5实验体会和拓展思考\n\n通过了解磁盘格式，使我对系统对于磁盘的管理有了全新的认识，之前我曾经以为磁盘分区与分类文件夹差不多，但是通过实验让我深刻理解了分区的机理和作用。对于簇链表的学习也使我理解了文件删除和恢复的机理，明白了恶意病毒破坏数据的手段。对于FAT32,NTFS等文件系统的学习使我了解到了不同文件系统各自的特点，以及在今后如何正确为自己的电脑设置合适的文件系统。\n\n通过学习磁盘格式与数据恢复，使我对如何攻击与防御恶意软件破坏数据指明了一条方向，也促使我今后提升对于文件保护的意识。而数据恢复实验可以帮助我在紧急情况下恢复自己的重要数据\n\n \n\n ","tags":["Windows","软件安全"]},{"title":"WinDbg操作-软件安全实验","url":"/2020/09/25/SoftwareSecurityWindbg_Experiment/","content":"在自己电脑上使用WinDbg解析hello25.exe程序运行时虚拟地址0x00403000h对应的物理地址（验证条件：物理地址与虚拟地址对应的数据应一致）\n\n<!-- more -->\n\n## 软件安全实验-WinDbg查看物理地址\n\n\n### basis\n\n64位系统下虚拟地址到物理地址的转换\n\n在64位体系中，实现了48位的虚拟地址，剩下的高16位用作符号扩展，要么全是0，要么全是1.\n\n与x86体系结构不同，x64下每级页表的寻址长度变成9位，因为页的大小仍然是4KB=$$2^{12}B$$，但是数据的大小却是64bit=8Byte=$$2^3 B$$，页每个数据是$$2^3 B$$，因此有$$2^9=512$$项，需要9位寻址。\n\n64位体系下，CPU将48位虚拟地址转换成物理地址有三种模型：\n\n1. $$4KB$$页面，使用PML4T,PDPT,PDT,PT四级转换结构\n2. $$2MB$$页面，使用PML4T,PDPT,PDT三级转换结构\n3. $$1GB$$页面，使用PML4T,PDPT二级转换结构\n\n一般讨论第一种.（个人PC一般$$4KB$$页面\n\n48位虚拟地址：\n\n```\n           |           |           |\t\t   |\n0000 0000 0|000 0000 00|00 0000 010|0 0000 0001| 0000 0000 0000\n-----------+-----------+-----------+-----------+----------------\n   PML4E\t\tPDPTE\t\tPDE\t\t\tPTE\t\t\t页内OFFSET\n```\n\n### WinDbg Setting\n\n\n#### Prepare Work\n\n建议用Windows10 64位标准系统，我用的是教育版，去MSDN I tell you上搜索磁力链接，离线到云盘或者下载器下载。\n\nKMS激活：开管理员`cmd`\n\n```bash\nslmgr /ipk NW6C2-QMPVW-D7KKK-3GKT6-VCFB2\n\nslmgr /skms kms.03k.org\n\nslmgr /ato\n```\n\n管理员`cmd`输入\n\n`bcdedit -debug on `命令；如果无法执行很有可能是bios设置了安全启动，需要进入bios将其关闭。\n要选择Debug Tools中的WinDbg x64而不是 x86，WinDbg要用管理员运行\n\n**网络开启全局代理**\n\n启动后`crtl+s`或者找到`symbol search path`按钮，输入：\n`srv*C:\\Symbols*https://msdl.microsoft.com/download/symbols`\n这个`C:\\symbols`就是自己从服务器下载到本地的符号表缓存文件夹,可以自己更改，之后软件就会根据这两个路径找符号表，第一次下载下来后，就可以直接在本地对应路径链接符号表了\n\n启动内核调试,如果不加载就输入`.reolad`执行，流量好几分钟不走再输入`!process`如果执行成功就没问题了,每次启动好像路径要重新设置一下，可参考\n\n每次启动WinDbg时需要确定`srv`是否配置正确。\n\nhttps://zhuanlan.zhihu.com/p/47771088\n\n#### Steps\n\n1. 运行测试程序，添加进程，`db 401000`，查看数据\n\n   ![image-20200922201025478](https://i.loli.net/2020/09/25/NokQGuJI4vfhTHO.png)\n\n2. 运行另一个**WinDbg**，启动本地内核调试，输入命令`process 0 0 Hello25.exe`，查看`DirBase(CR3)`![image-20200922201229684](https://i.loli.net/2020/09/25/sMCb8vIOJ6jzywc.png)\n\n3.  虚拟地址401000，写成48位标准形式是0x 000000 401000\n\n   ```\n   0000 0000 0|000 0000 00|00 0000 010|0 0000 0001| 0000 0000 0000\n   -----------+-----------+-----------+-----------+----------------\n      PML4E\t\tPDPTE\t\tPDE\t\t\tPTE\t\t\t页内OFFSET\n   ```\n\n   PML4E=PDPTE=0,\n\n   PDE=2\n\n   PTE=1\n\n   页内偏移=0\n\n   由于PML4E=0，上一级的12-35位提供下一级的物理基地址高24位，低12位补0，输入`!dq 39c45000+0*8`,\n\n   这里一个页项64bit=8字节，第0个页项，对应项字节地址(即首地址)即`+0*8`\n\n   ![image-20200922202933529](https://i.loli.net/2020/09/25/SgZpdFrVBclI7ms.png)\n\n4. PDPTE=0，输入`!dq 07e7e6000+0*8`\n\n   ![image-20200922203027885](https://i.loli.net/2020/09/25/QEUVWRDumPYXHij.png)\n\n5. PDE=2，输入`!dq 069ca7000+0x2*8`\n\n   ![image-20200922203141535](https://i.loli.net/2020/09/25/WJQaxIomzBSpwlN.png)\n\n6. PTE=1，输入`!dq 028968000+0x1*8`\n\n   ![image-20200922203305876](https://i.loli.net/2020/09/25/LuPGD4wOJcXSbTH.png)\n\n7. 页内偏移0，输入`!db 11a6be000+0`\n\n   ![image-20200922203947854](https://i.loli.net/2020/09/25/4bGEwgiYuUl1z6e.png)\n\n   比较第1步，成功访问相同数据。\n\n","tags":["Windows","软件安全"]},{"title":"JAVA 多文件运行的命令行操作","url":"/2020/09/25/JAVA_multifile_command/","content":"\n## JAVA 多文件运行的命令行操作\n\n\n\n如果有多个`.java`文件互相依赖，直接用`java {mainfile}.java`是无法运行的，而如果主文件设置是处于某个`package`中，不能在文件同级目录下运行.\n\n<!-- more -->\n\n### Web Info\n\n该如何解决呢？解决办法如下：\n\n1.由于是在运行阶段出现的问题，那么可能是环境变量配置不当的问题，即可能是`classpath`路径配置错误，而导致.class文件无法加载。那么此时你可以检查是否配置好`classpath`路径，一般来说`classpath`路径配置如下：\n\n`.;%java_home%\\lib;%java_home%\\lib\\tools.jar；` （注意前面的` .` 以及 `;` 缺一不可,点代表的是运行的当前路径）\n\n其中`.`表示当前路径，`;`表示分隔符。\n\n\n\n2.如果你试过了很多次，`classpath`也配置对了，依旧出现这个错误，注意你使用的测试代码，是否在某一个包名的下面；\n\n比如说如下测试代码：\n\n![img](https://i.loli.net/2020/09/25/dIsWtF3P7K49qSH.png)\n\n在文件所在的当前目录下，运行`javac TestPlusPlus.java`编译成功，生成`TestPlusPlus.class`文件，这个时\n\n候，你用`java TestPlusPlus`想运行程序，总会出现”找不到或无法加载主类“的错误。这个时候要注意，\n\n之所以找不到，是因为`TestPlusPlus`在HelloWorld包名的下面。\n\n解决办法：\n\n1.去掉` ”package HelloWorld;“` 重新用`javac `编译`TestPlusPlus.java`,再运行`java TestPlusPlus`就可以了。\n\n2.新建一个包名一样的文件夹，在本例中，为建立一个HelloWorld的文件夹，把`TestPlusPlus.java`文件移到该目录下。\n\n然后在HelloWorld文件夹的平级下，打开DOS命令窗口，运行`javac HelloWorld/TestPlusPlus.java`编译程序，\n\n运行`java HelloWorld/TestPlusPlus`(或者`java HelloWorld.TestPlusPlus`也可以)，则可以运行含有包名的java程序。\n\n\n\n**注意:包名不要含有'.'(点),' '(空格)等特殊符号，这样的话命令行无法判断包名与java程序名的分割点在哪里，从而还是找到或者无法加载主类。**\n\n**因此，命令`java HelloWorld/TestPlusPlus`只能这样写**，\n\n**不能**写成``java ./HelloWorld/TestPlusPlus``和`java /HelloWorld/TestPlusPlus`,因为空有一个`/`不知道是哪个目录，而`.`又不能加。另外，指明路径时最好不要用反斜杠`\\`\n\n```shell\njava charactor/Run.java  # YES,运行的.java文件(要先编译出.class)\njava charactor/Run\t\t#\tYES\t目标是.class\njava charactor.Run\t\t# YES\n\njava charactor\\Run.java\t#YES\t不好\njava charactor\\Run\t\t#NO\njava charactor.Run.java\t#NO,用.指引路径不要加.扩展名,会以为成一级目录\njava .charactor.Run\t\t#NO,当前是在charactor文件夹同级目录下,不要加点\n```\n\n\n\n### Why?：\n\njava程序运行class文件,对于有包名的类,java把包名当成文件夹处理.\"包名+类名\"相当于\"文件夹目录+类名\"来寻找类。\n\n```shell\njava charactor.Run\njava charactor/Run\n```\n\n**多文件要先编译**\n\n```shell\njavac .\\property\\*.java -encoding UTF-8\njava property.Item\n{java property/Item}\n```\n\n若编译好了一个包，可以在同级目录下编写`java`文件来`import`这个包\n\n![image-20200912155753020](https://i.loli.net/2020/09/25/7SypAFvck36qDHi.png)\n\n```java\nimport property.*;\npublic class test{\n    public static void main(String[]args){\n        Item i1=new LifePotion();\n        Item i2=new MagicPotion();\n        System.out.println(\"i1 是Item类型,执行effect:\");\n        i1.effect();\n        System.out.println(\"i2也是Item类型,执行effect:\");\n        i2.effect();\n    }\n}\n```\n\n编译，`classpath`默认就是当前目录，不要再设置，有中文需要加上后缀`-encoding UTF-8`\n\n```shell\n javac  .\\test.java -encoding UTF-8\n java   test\n```\n\n如果在别的地方写`.java`，需要设置`-cp` ，直接执行中文会乱码\n\n![image-20200912160535205](https://i.loli.net/2020/09/25/5nABpdjDgzMfyaS.png)\n\n```shell\njava -cp \".\\DT\" test.java\n```\n\n```shell\njavac -cp \".\\DT\" test.java\n```\n\n最好是写成\n\n`.\\DT\\;`\n\n`.\\DT;`\n\n重点是`;`\n\n编译后\n\n```shell\njava -cp \".\\DT\\;\" Test\n```\n\n对于.class文件来说，只需要指明包的路径即可；但是对于jar文件来说，必须要指定全路径即路径+文件名.jar的格式，不能只指定一个路径\n\n```shell\njavac -cp \"F:\\MyNotes\\How2J\\DT\\;\"  Test.java\njava -cp \"F:\\MyNotes\\How2J\\DT\\;\"  Test\n```\n\n","tags":["java"]},{"title":"C语言中的函数参数使用引用'&'和指针'*'","url":"/2020/09/24/&andPoint/","content":"\n# C语言的指针与引用\n\n**本文有误,C语言并不支持引用,这是C++的特性**\n\n我们知道指针是保存地址的变量，int a=10；int*p=&a；\n那么我们就建立了一个指针p变量指向int型数据a；\n指针的一个很常见的应用就是传入函数做形参对数据进行操作。\n我们知道仅仅向函数传入形参,函数执行完后不能对我们的main()实参进行修改的。如果要修改，那么指针是一个很重要的手段。可以说，没有指针，C语言的函数很多功能都实现不了。\n但是,C语言还有一种函数形参，姑且叫做'引用'，这个也是能够实现指针的一些功能的。\nint a=10；function(a)；//function（）声明是 int function(int &b)\n也能实现对main（）中a的修改\n但是它们之间有一定的区别。\n<!-- more -->\n## C语言的指针简介\n```\tc\nvoid swap_1(int a,int b)\n{\n    int t=a;\n    a=b;\n    b=t;\n    return;\n}\nvoid swap_2(int *a,int *b)\n{\n    int t=*a;\n    *a=*b;\n    *b=t;\n    return ;\n}\nint main()\n{\n\tint a=10;int b=20;\n\tswap_1(a,b);\n\tswap_2(&a,&b);\n\treturn 0;\n}\n```\n 1. **swap_1()无效，swap_2()有效**`swap_1(a,b);\n\tswap_2(&a,&b);` ，函数内部和传入函数的参数都是临时变量，**`swap_1(a,b)`仅仅传入了两个临时参数，对两个参数进行交换，但是函数结束后临时变量销毁，并没有改变**`main()`中的a和b；\n\t`swap_2(&a,&b)`却不同，函数声明中形式变量是指针，传入的是地址，函数的临时变量利用地址对a，b两个数据进行了操作。这样即使函数结束，临时变量销毁，a,b地址上的a,b还是被进行了交换；\n2. 需要注意的是，虽然函数使用指针对main()中的数据变量进行了修改，但是函数内部，指针也仍然是临时变量。当函数需要对数组进行扩展`realloc(),malloc()`时，使用这种指针临时变量是危险并且很容易出错的。\n3. \n\n\n## C语言引用简介\n\n我们知道，C语言的函数传入的一般都是作为临时变量使用的。这是初学者非常意外的事情。很多人初学C函数语法，都会写出`swap_1()`的数值函数，然而这个函数并没有实现之前预想的交换`main()`中的两个`int`型变量的值。\n解决这个问题，一种思路是使用指针，也就是定义&声明函数时指出形式参数是一个指针变量。这里在强调一下指针：\n`int* a`的意思是定义一个变量`a`，a是指向一个`int`型数据的指针。这个指针保存的数据是这个被指向的数据的地址。\n所以`int b=10;a=&b;`这样我们就让这个指针变量保存了b的地址，指针a也就指向了数据b。\n\n**但是**，指针刚开始的理解并不是那么直观，有没有一种能够和初学者想法一样的直接传入函数后操作就能够实现对`main()`等等其他模块内的数据进行操作的方法呢？**“引用”**就是一个解决方法\n```c\nvoid swap_3(int &a,int &b)\n{\n    int t=a;\n    a=b;\n    b=t;\n    return ;\n}\nint main()\n{\n\tint a=10;int b=20;\n\tswap_3(&a,&b);\n\tprintf(\"a=%d,b=%d\\n\",a,b);\n\treturn 0;\n}\n```\n![运行结果](https://img-blog.csdnimg.cn/20191218210928987.png)\n可以看到，函数`swap_3()`成功实现了交换，而且没有用到较为复杂的指针和地址，除了形参加上了`&`符号，几乎和新手想的一样，但是却成功了\n这种`return_value_name function_name(&parameter_list)`的定义与声明，传入的参数是一个实际参数的**引用**。\n引用实现了函数对传入参数的直接操纵。可以理解为,这里的函数引用，其实是对实际参数取了一个在函数内部的**别名**，函数内部使用这个别名直接对这个实际参数进行了处理。\n**注意，这一点是很重要的。因为当我们使用指针实现对数据在函数内进行修改时，这个指针也是一个临时变量，指针对指向的数据操纵后也就销毁了。如果我们在函数内想对一个数组指针扩大数组范围，使用临时变量的指针``realloc()``后，在离开函数后，其实这里的realloc()改变的是这个临时指针变量指向的内存空间。而离开函数后指针销毁，原来的实际指针指向的内存单元并没有也相应改变。这是危险的**\n\n\n## 指针&引用在C函数中实际应用一例\n\n*程序目标，设计一个链表节点初始化函数，要求对一个类型的指针赋予对应类型的一个内存空间，并把节点值赋值为data* \n\n**错误写法**\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct LNode\n{\n\tint data;\n\tstruct LNode*next;\n}LinkNode;\n\n\nvoid Init_LinkNode(LinkNode*n,int data)\n{\n\tn=(LinkNode*)malloc(sizeof(LinkNode));\n\tn->data=data;\n\tn->next=NULL;\n}\n\nint main()\n{\n\tLinkNode*L=NULL;\n\n\tInit_LinkNode(L,1);\n\n\tprintf(\"%d\\n\",L->data);\n\n\tfree(L);\n\treturn 0;\n}\n```\n![发生错误](https://img-blog.csdnimg.cn/20191218224256158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dhbGRlbnRo,size_16,color_FFFFFF,t_70)\n为什么会发生错误？\n**A：**这是一个非常典型的指针理解不到位造成的错误。事实上，`Init_LinkNode()`函数传入的指针变量`n`在函数中仍然是一个临时变量，这个临时变量`n`和`main()`中的L都指向NULL，传入函数后，临时变量获得了一块内存单元并进行处理，但是出函数后，这个临时指针变量销毁了。指向的处理化后的内存单元也没了。而L却仍然指向NULL,这就造成了错误。\n\n**正确写法1**\n```c\nvoid Init_LinkNode(LinkNode*&n,int data)\n{\n\tn=(LinkNode*)malloc(sizeof(LinkNode));\n\tn->data=data;\n\tn->next=NULL;\n}\n\n```\n![运行正确](https://img-blog.csdnimg.cn/20191218225013899.png)\n这里我们向函数中传入的是`LinkNode*&n`\n`int * &c = a;\t\t//这里c是一个引用，它是指针a的引用`\n区分技巧：在分析上面代码时，可以从变量标识符开始从右往左看，最靠近标识符的是变量的本质类型，而再往左即为对变量类型的进一步修饰。\n\n举例 ：\n\nint * & a;\n\n标识符a的左边紧邻的是&，证明a是一个引用变量，而再往左是*，可见a是一个指针的引用，再往左是int，可见a是一个指向int类型的指针的引用。\n————————————————\n版权声明：本文为CSDN博主「csu_zhengzy~」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/qq_18108083/article/details/84679104\n\n**正确写法2**\n既然传入的指针变量是临时变量，那可不可以传入指针变量的指针呢？\n```c\nvoid Init_LinkNode(LinkNode**n,int data)\n{\n\t*n=(LinkNode*)malloc(sizeof(LinkNode));\n\t(*n)->next=NULL;\n\t(*n)->data=data;\n}\n\nint main()\n{\n\tLinkNode*L;\n\n\tInit_LinkNode(&L,1);\n\n\tprintf(\"%d\\n\",L->data);\n\n\tsystem(\"PAUSE\");\n}\n```\n![Awesome!](https://img-blog.csdnimg.cn/20191218225730193.png)\n由于`*`运算优先级低于`->`加上括号\n我们得到了这个awesome的结果，向函数传入指针的指针，这个临时变量就可以操纵`main()`里面的指针了\n","tags":["C","C++"]},{"title":"C/cpp的小数IEEE-754","url":"/2020/09/24/IEEE-754/","content":"\n\n很多人对学python的爱好者diss的常见手段之一，就是让他们解释这个程序的结果\n```python\na=0.1+0.2\nprint(a)\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200119222726243.png)\n这其实就是涉及到计算机中小数的表示了.\n接下来，我们用最适合解释这种表示的C语言来介绍计算机中小数的表示，以及经典的IEEE-754标准。\n<!-- more -->\n## C中小数的表示\n\n学过C的都知道，.C中，小数一般都是被叫做浮点数，`int`表示的是**整型变量**，对应的就是`float`，被称作**浮点数**(英文float)，很多人就将其理解为C的小数变量表示。此外，C中还有一种浮点数形式`double`，熟悉概念的人应该知道，这是**双精度浮点数**的意思(英文double)\n它们两者之间的区别？一般的了解者可能会说，`double`比`float`表示小数时精度更高一些。的确是这样，但是我们怎样更加深入的理解，并解释上文python程序中这一个貌似有点奇怪的结果呢？我们先从一个简单C程序说起.\n**考虑到查阅资料和网页工具的方便性，使用Dev-c++，编译环境TDM-GCC 4.9.2 64bit**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200119223701687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dhbGRlbnRo,size_16,color_FFFFFF,t_70)\n如之前所述，可以看到，a变量为`float`型，也是4字节32bit，将其赋值0.3，打印小数8位，也出现了类似python程序的现象，出现了一个`1`，为什么好端端赋值0.3确打印了个1出来？这就涉及到二进制小数的表示了。\n首先说明，十进制表示法中，有一些数字是没法用有限位表示的，比如循环小数，无理数。\n同样，二进制表示法，也有小数没办法用有限位表示，而且，很多十进制可以轻松表达的小数，二进制表示却较复杂.\n 1. 0.75的二进制表示，0.11 ，二进制可以有限位精确表示\n 2. 然而0.3的二进制表示则是：`0.0 100 1100 1100 1100 1100 1100 1100110011001100110011001101....`事实上这么多位下来还是没有完全精确的表示0.3。而我们之前看到，a占据的内存单元只有32bit，甚至无法满足这个精度(由于IEEE-754标准)\n 那么这个32位的浮点数a怎么存储0.3，为什么打印小数点后8位是0.3000 0001呢？\n 经典的IEEE-754标准可以解释这个问题\n\n\n## IEEE-754 浮点标准 部分简介\n\n在计算机小数表示中，小数一般是科学计数法表述的.\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200119224953992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dhbGRlbnRo,size_16,color_FFFFFF,t_70)\n`float`又被称为单精度浮点表示，`double`是与之对应的双精度浮点表示。\n这里只介绍`float`，结构如上图上部，双精度与其类似，但是精度更高。后续可以自然理解。\n\n之所以叫做**浮点**，这其实是一个非常形象的描述\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200119231148576.png)\n小数点其实是可以运动的，根据指数m，小数点可以左移/右移 |m|位，以此来表示不同大小的\"小数\"。\n\n比如我们定义这样一个C变量\n```c\nfloat a=0.75;\n```\n那么,a可以简单写成二进制0.11，用二进制科学计数法表示也就是`1.1 x 2^-1`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200119225410853.png)\n\n有关IEEE-754:\n是20世纪80年代以来最广泛使用的浮点数运算标准，为许多CPU与浮点运算器所采用。这个标准定义了表示浮点数的格式（包括负零-0）与反常值（denormal number）），一些特殊数值（无穷（Inf）与非数值（NaN）），以及这些数值的“浮点数运算符”；它也指明了四种数值舍入规则和五种例外状况（包括例外发生的时机与处理方式）。\nIEEE 754规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现）。只有32位模式有强制要求，其他都是选择性的。大部分编程语言都有提供IEEE浮点数格式与算术，但有些将其列为非必需的。例如，IEEE 754问世之前就有的C语言，有包括IEEE算术，但不算作强制要求（C语言的float通常是指IEEE单精确度，而double是指双精确度）。\n该标准的全称为IEEE二进制浮点数算术标准（ANSI/IEEE Std 754-1985），又称IEC 60559:1989，微处理器系统的二进制浮点数算术（本来的编号是IEC 559:1989）。后来还有“与基数无关的浮点数”的“IEEE 854-1987标准”，有规定基数为2跟10的状况。最新标准是“ISO/IEC/IEEE FDIS 60559:2010”。\n\n另外，IEEE((美国)电气和电子工程师协会)的读法，I-E-E-E是一种方式，但其实口语中更广泛的是读作I triple E\n\n现在，按照上图，按照IEEE-754,我们这样存储0.75：\ns：符号位 0正1负，显然，这里是正数，为0\nexp：表示指数，30-23共8位，可表示0-255，在IEEE-754标准中，exp段可视为无符号数，但是并不是表示数字的指数，而是指数的`带偏阶的指数`。可表示的范围中，1-254部分，有一个偏阶bias，bias=2^(k-1) -1 k是exp段位数，因此单精度中bias=127(双精度是1023)\n科学计数法表示中的指数E=-1，加上偏阶bias，结果是126，所以exp段应该存储的是无符号数126，0111 1110\nfrac:这一段被称作**尾数**，也就是科学计数法中小数部分'0.1'，这里有一个现象，exp=1--254可表示的数字往往被称作**规格化数**，可以看到，小数点前的部分都是'1',所以，可以节省一位(因为知道规格化数肯定小数点前一位是1)，所以，IEEE-754标准规定，规格化数的有**前导位1**，尾数只要存储小数点后的数字就行了。小数点后是0.'1'，那么用23位尾数表示就是：\n(0.) `1000 0000 .....0000` （23位）\n\n**这里可以看到，浮点数的精度其实是靠尾数决定的，尾数位数越多，可表示的精度越高，这就是为什么有52位位数的double比有23位尾数的float精度高的原因**\n\n现在，根据IEEE-754规格化单精度浮点数标准，我们可以写出32位浮点数0.75在IEEE-754格式下的表示了:\n0--0111 1110--1000 0000 0000 0000 0000 000\n\n接着，我们还要填之前的一个坑:以上只是IEEE-754对**规格化数**的表示，规格化数exp段范围是只有1-254的。那么0和255呢？规定如下:\n\nexp=0时，如果尾数frac也为0，那么此时编码表示0，这就是\"机器零\"，因为机器无法表示比它更小的数了，便把它作为0\n\nexp=0,frac非0，这表示的是**非规格化数**，规格化数都是1.xxx * 2^xx ，单精度浮点数能够表示的最接近零的数绝对值是1.000..00 x 2 ^ -126,为了填补规格化数和机器零之间的\"距离\"， 就有了非规格化数。与规格化数不同，非规格化数没有前导为位1，也就是说，可以表示 0.xx * 2 ^ xx 。\n此外，非规格化数的偏阶bias也不再是127，而是126，也就是说，它表示的其实是0.xxx * 2 ^ -126  将它与规格化最小数1.000..00 x 2 ^ -126 比较，`填补规格化数和机器零之间的\"距离\"`\n这一解释就显得非常的形象了。\n\n此外，\nexp=255,frac=0时，表示无穷(溢出了)，(为了形成实数的拓扑闭集合)\nexp=255,frac非0，表示NaN,即不是数的意思，Not a Number,这里不再过多介绍。\n.\n.\n.\nDouble表示与float类似。不再赘述。而目前的最新标准中，新增了其他一些精度表示，比如半精度，其实也是与上述介绍类似的。\n\n\n## 对0.3000 0001的解释\n到现在为止，其实对浮点数的介绍已经不少了.现在尝试解释0.3000 0001的由来。\nfloat a=0.3,\n可知，0.3在二进制小数中不能通过有限精度表示的，\n0.3=0.0 100 1100 1100 1100 1100 1100 1100110011001100110011001101....\n根据IEEE-754,我们选取小数点后第一个非0数字开始：\n1 00110011001100110011001100110011001100110011001101...\n1作前导位，接着后24位是：0011 0011 0011 0011 0011 001 1 \n而单精度尾数段只有23位，进行舍入:\n注意看这里的最后一位是1，而不是0， 这里就采用了四舍五入的原则，回忆一下，在10进制中比如0.57四舍五入保留一位小数的结果是0.6，那就是因为第2位小数是7，超过了5所以进1位，  在二进制中就看下一位是1还是0，如果是1就进位。24位二进制串中的第24位为1，因此进位到23位。再进位，所以尾数是：\n0011 0011 0011 0011 0011 010\n转换为IEEE-754格式:\n0--0111 1101--0011 0011 0011 0011 0011 010\n这就是单精度float变量a对0.3的存储，我们读取它.\n1.0011 0011 0011 0011 0011 010 x 2^ 125-127=\n0.01 0011 0011 0011 0011 0011 010 \n转换为10进制:\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200119235800501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dhbGRlbnRo,size_16,color_FFFFFF,t_70)\n读取8位小数，0.3000 0001 1，四舍五入，就是0.3000 0001.\n当然，我们还可以验证9位小数，0.3000 00011 9，四舍五入结果应该是0.3000 00012，通过程序验证:\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200120000009393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dhbGRlbnRo,size_16,color_FFFFFF,t_70)\n程序结果完美符合我们的预测。\n\n此外，还想讨论几件事情，\nhttp://www.styb.cn/cms/ieee_754.php\n这个网站提供了IEEE-754转换功能，之前我也是认为正确的，但是在写这篇文章时意外感觉作者可能有了一个疏忽，就是忘记了尾数的舍入。\n0.3在该网站的结果是这样的:\n0--0111 1101--0011 0011 0011 0011 0011 001\n尾数对应段应该是0011 0011 0011 0011 0011 0011，但是作者似乎没有考虑舍入，而是直接截取了23位，这就造成结果是0.0100110011001100110011001\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200120000649263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dhbGRlbnRo,size_16,color_FFFFFF,t_70)\n无法解释本环境下的结果了。当然这只是我的想法，欢迎大家指正。\n除此之外，IEEE-754还可以解释一些浮点运算现象，比如一个大数加上一个较小的小数，结果会发现较小数\"没有加上去\",不过这些就涉及更复杂的保护，舍入，粘贴位的概念了，以后有机会可以再写写。\n","tags":["C","计算机组成原理"]},{"title":"Git教程","url":"/2020/09/24/HowtoUseGit/","content":"\n参考资料：https://www.liaoxuefeng.com/wiki/896043488029600\n\n<!-- more -->\n\n### 用户名\n\n安装完成后，还需要最后一步设置，在命令行输入：\n\n```\n$ git config --global user.name \"Your Name\"\n$ git config --global user.email \"email@example.com\"\n```\n\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。\n\n注意`git config`命令的`--global`参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。\n\n输入\n\n```shell\ngit config --list\n```\n\n可以查看配置的一些东西。可以看到`user.name` 和`user.email` 分别是什么\n\n**重命名**\n\n这边给出了`--repalce-all` 这个东西。\n\n然后我尝试着用\n\n```shell\n$ git config --global --replace-all user.email \"输入你的邮箱\" \n\n$ git config --global --replace-all user.name \"输入你的用户名\"\n```\n\n### 仓库初始化\n\n初始化一个Git仓库，使用`git init`命令，当前目录成为仓库.\n\n文件一定要放到`learngit`目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。\n\n和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。\n\n什么是版本库呢？版本库又名仓库，英文名**repository**，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。\n\n所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：\n\n```shell\n$ mkdir learngit\n$ cd learngit\n$ pwd\n/Users/michael/learngit\n```\n\n`pwd`命令用于显示当前目录。在我的Mac上，这个仓库位于`/Users/michael/learngit`。\n\n 如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。\n\n第二步，通过`git init`命令把这个目录变成Git可以管理的仓库：\n\n```shell\n$ git init\nInitialized empty Git repository in /Users/michael/learngit/.git/\n```\n\n瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个`.git`的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。\n\n如果你没有看到`.git`目录，那是因为这个目录默认是隐藏的，用`ls -ah`命令就可以看见。\n\n### 文件入库\n\n第一步，用命令`git add`告诉Git，把文件添加到仓库：\n\n```\n$ git add readme.txt\n```\n\n第二步，用命令`git commit`告诉Git，把文件提交到仓库：\n\n```\n$ git commit -m \"wrote a readme file\"\n```\n\n`-m`后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录\n\n为什么Git添加文件需要`add`，`commit`一共两步呢？因为`commit`可以一次提交很多文件，所以你可以多次`add`不同的文件\n\n```\n$ git add file1.txt\n$ git add file2.txt file3.txt\n$ git commit -m \"add 3 files.\"\n```\n\n### 查看日志和版本回退\n\n版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用`git log`命令查看：\n\n```shell\n$ git log\ncommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -> master)\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 21:06:15 2018 +0800\n\n    append GPL\n\ncommit e475afc93c209a690c39c13a46716e8fa000c366\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 21:03:36 2018 +0800\n\n    add distributed\n\ncommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 20:59:18 2018 +0800\n\n    wrote a readme file\n```\n\n`git log`命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是`append GPL`，上一次是`add distributed`，最早的一次是`wrote a readme file`。\n\n如果嫌输出信息太多，看得眼花缭乱的，可以试试加上`--pretty=oneline`参数\n\n```shell\n$ git log --pretty=oneline\n1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -> master) append GPL\ne475afc93c209a690c39c13a46716e8fa000c366 add distributed\neaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file\n```\n\n首先，Git必须知道当前版本是哪个版本，在Git中，用`HEAD`表示当前版本，也就是最新的提交`1094adb...`（注意我的提交ID和你的肯定不一样），上一个版本就是`HEAD^`，上上一个版本就是`HEAD^^`，当然往上100个版本写100个`^`比较容易数不过来，所以写成`HEAD~100`。\n\n现在，我们要把当前版本`append GPL`回退到上一个版本`add distributed`，就可以使用`git reset`命令：\n\n```shell\n$ git reset --hard HEAD^\nHEAD is now at e475afc add distributed\n```\n\n最新的那个版本`append GPL`已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？\n\n办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个`append GPL`的`commit id`是`1094adb...`，于是就可以指定回到未来的某个版本：\n\n```shell\n$ git reset --hard 1094a\nHEAD is now at 83b0afe append GPL\n```\n\n版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了.\n\n现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的`commit id`怎么办？\n\n在Git中，总是有后悔药可以吃的。当你用`$ git reset --hard HEAD^`回退到`add distributed`版本时，再想恢复到`append GPL`，就必须找到`append GPL`的commit id。Git提供了一个命令`git reflog`用来记录你的每一次命令：\n\n```\n$ git reflog\ne475afc HEAD@{1}: reset: moving to HEAD^\n1094adb (HEAD -> master) HEAD@{2}: commit: append GPL\ne475afc HEAD@{3}: commit: add distributed\neaadf4e HEAD@{4}: commit (initial): wrote a readme file\n```\n\n终于舒了口气，从输出可知，`append GPL`的commit id是`1094adb`，现在，你又可以乘坐时光机回到未来了\n\n#### 小结\n\n现在总结一下：\n\n- `HEAD`指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令`git reset --hard commit_id`。\n- 穿梭前，用`git log`可以查看提交历史，以便确定要回退到哪个版本。\n- 要重返未来，用`git reflog`查看命令历史，以便确定要回到未来的哪个版本。\n- \n\n### 工作区（Working Directory）\n\n就是你在电脑里能看到的目录，比如我的`learngit`文件夹就是一个工作区：\n\n#### Stage 暂存区\n\n![git-stage-after-commit](https://i.loli.net/2020/09/25/Cf6eVF5nbraBxJW.jpg)\n\n\n\n**每次修改，如果不用`git add`到暂存区(stage)，那就不会加入到`commit`中**\n\n**如果在git add 文件之后，commit之前，在工作区中对该文件进行修改，commit时会将该次修改一起提交**\n\n\n\n命令`git checkout -- readme.txt`意思就是，把`readme.txt`文件在工作区的修改全部撤销，这里有两种情况：\n\n一种是`readme.txt`自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n\n一种是`readme.txt`已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n\n总之，就是让这个文件回到最近一次`git commit`或`git add`时的状态。\n\n**`git checkout`其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。**\n\n#### 小结\n\n场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令`git checkout -- file`。\n\n场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令`git reset HEAD `，就回到了场景1，第二步按场景1操作。(还没有提交commit，回到当前版本就可以丢弃暂存区修改)\n\n场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考[版本回退](https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192)一节，不过前提是没有推送到远程库\n\n### 删除文件\n\n在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件`test.txt`到Git并且提交\n\n```\ngit add test.txt\n```\n\n一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用`rm`命令删了\n\n这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，`git status`命令会立刻告诉你哪些文件被删除了\n\n现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令`git rm`删掉，并且`git commit`：\n\n```\ngit rm test.txt\nrm 'test.txt'\n```\n\n现在，文件就从版本库中被删除了。\n\n另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：\n\n```\n$ git checkout -- test.txt\n```\n\n`git checkout`其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。\n\n**删除了所有文件**\n\n```shell\ngit rm *\n```\n\n **注意：从来没有被添加到版本库（暂存区stage+master）就被删除的文件，是无法恢复的！**\n\n#### 小结\n\n命令`git rm`用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失**最近一次提交后你修改的内容**。\n\n\n\n**注意！！！**\n\n如果直接用文件管理器删除了文件或者文件夹，直接`git add`再`git commit`就行，无需执行`git -rm`确认\n\n\n\n### 关于文件夹\n\n**删除**\n\n```powershell\ngit  rm  {要删除的文件夹}  -r -f  \n```\n\n**创建**\n\n```shell\nmkdir {}\n```\n\n#### rm指令\n\nLinux `rm` （英文全拼：remove）命令用于删除一个文件或者目录。\n\n语法\n\n```\nrm [options] name...\n```\n\n**参数**：\n\n- -i 删除前逐一询问确认。\n- -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。\n- -r 将目录及以下之档案亦逐一删除。\n\n**实例** \n\n删除文件可以直接使用`rm`命令，若删除目录则必须配合选项\"`-r`\"，例如：\n\n```\n# rm  test.txt \nrm：是否删除 一般文件 \"test.txt\"? y  \n# rm  homework  \nrm: 无法删除目录\"homework\": 是一个目录  \n# rm  -r  homework  \nrm：是否删除 目录 \"homework\"? y \n```\n\n**删除当前目录下的所有文件及目录，命令行为：**\n\n```\nrm  -r  * \n```\n\n文件一旦通过rm命令删除，则无法恢复，所以必须格外小心地使用该命令。\n\n**删除当前目录下的所有文件及目录，并且是直接删除，无需逐一确认命令行为：**\n\n```\nrm  -rf  要删除的文件名或目录\n```\n\n### 远程仓库\n\n显示所有远程仓库：\n\n```shell\ngit remote -v\n```\n\n添加远程版本库：`shortname `为本地的版本库\n\n```shell\ngit remote add [shortname] [url]\n```\n\n其他相关命令：\n\n```shell\ngit remote rm name  # 删除远程仓库\ngit remote rename old_name new_name  # 修改仓库名\n```\n\n```shell\n# 提交到 Github\n$ git remote add origin git@github.com:tianqixin/runoob-git-test.git\n$ git push -u origin master\n```\n\n#### 删除远程仓库\n\n删除远程仓库你可以使用命令：\n\n```shell\ngit remote rm [别名]\n```\n\n#### 实例\n\n```shell\n$ git remote -v\norigin    git@github.com:tianqixin/runoob-git-test.git (fetch)\norigin    git@github.com:tianqixin/runoob-git-test.git (push)\n\n# 添加仓库 origin2\n$ git remote add origin2 git@github.com:tianqixin/runoob-git-test.git\n\n$ git remote -v\norigin    git@github.com:tianqixin/runoob-git-test.git (fetch)\norigin    git@github.com:tianqixin/runoob-git-test.git (push)\norigin2    git@github.com:tianqixin/runoob-git-test.git (fetch)\norigin2    git@github.com:tianqixin/runoob-git-test.git (push)\n\n# 删除仓库 origin2\n$ git remote rm origin2\n$ git remote -v\norigin    git@github.com:tianqixin/runoob-git-test.git (fetch)\norigin    git@github.com:tianqixin/runoob-git-test.git (push)\n```\n\n### SSH密钥配置\n\n```shell\ncd ~/.ssh\n```\n\n**如果之前有密钥且不用了**\n\n```shell\nrm  id_rsa\nrm  id_rsa.pub\n```\n\n**生成**\n\n```shell\n ssh-keygen -t rsa -C \"waldenth@outlook.com\"\n```\n\n**.pub是公钥**\n\n```shell\ncat id_rsa.pub\n```\n\n**VPN下如果SSH被拒绝访问Github，使用HTTPS**\n\n```shell\ngit remote add LeetCodeNote-https https://github.com/Waldenth/My-LeetCode.git\ngit push [-u] LeetCodeNote-https master\n```\n\n### 删除本地仓库\n\n**删除仓库，就是需要删除仓库文件夹下隐藏的 .git 文件夹！！！**\n\n进入项目所在目录，打开git bash，开始删除本地仓库：\n\n显示所有本地分支（初始化时只有一个master分支）\n\n```shell\n$ git branch\n```\n\n初始化本地版本库（重新初始化一次，可以忽略）\n\n```shell\n$ git init\n```\n\n找到目录下隐藏的 .git\n\n```shell\n$ ls -ah\n```\n\n删除 .git\n\n```shell\n$ rm -rf .git\n```\n\n1. 可以看到master分支已经删除\n\n```shell\n$ ls -a\n```\n\n### 创建与合并分支\n\n在[版本回退](https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192)里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即`master`分支。`HEAD`严格来说不是指向提交，而是指向`master`，`master`才是指向提交的，所以，`HEAD`指向的就是当前分支。\n\n一开始的时候，`master`分支是一条线，Git用`master`指向最新的提交，再用`HEAD`指向`master`，就能确定当前分支，以及当前分支的提交点：\n\n![git-br-initial](https://i.loli.net/2020/09/25/dCUe7BbsTvw93ip.png)\n\n每次提交，`master`分支都会向前移动一步，这样，随着你不断提交，`master`分支的线也越来越长。\n\n？这条圆圈线就是仓库版本线\n\n当我们创建新的分支，例如`dev`时，Git新建了一个指针叫`dev`，指向`master`相同的提交，再把`HEAD`指向`dev`，就表示当前分支在`dev`上：\n\n![git-br-create](https://i.loli.net/2020/09/25/7lV1FsgO2HDdWqx.png)\n\n你看，Git创建一个分支很快，因为除了增加一个`dev`指针，改改`HEAD`的指向，工作区的文件都没有任何变化！\n\n不过，从现在开始，对工作区的修改和提交就是针对`dev`分支了，比如新提交一次后，`dev`指针往前移动一步，而`master`指针不变：\n\n![git-br-dev-fd](assets/l.png)\n\n假如我们在`dev`上的工作完成了，就可以把`dev`合并到`master`上。Git怎么合并呢？最简单的方法，就是直接把`master`指向`dev`的当前提交，就完成了合并：\n\n![git-br-ff-merge](https://i.loli.net/2020/09/25/k9XHoNQmR4UZf3F.png)\n\n所以Git合并分支也很快！就改改指针，工作区内容也不变！\n\n合并完分支后，甚至可以删除`dev`分支。删除`dev`分支就是把`dev`指针给删掉，删掉后，我们就剩下了一条`master`分支：\n\n![git-br-rm](https://i.loli.net/2020/09/25/LXUN45BQvqIeaVO.png)\n\n真是太神奇了，你看得出来有些提交是通过分支完成的吗？\n\n#### 分支实战\n\n下面开始实战。\n\n首先，我们创建`dev`分支，然后切换到`dev`分支：\n\n```shell\n$ git checkout -b dev\nSwitched to a new branch 'dev'\n```\n\n`git checkout`命令加上`-b`参数表示创建并切换，相当于以下两条命令：\n\n```shell\n$ git branch dev\n$ git checkout dev\nSwitched to branch 'dev'\n```\n\n然后，用`git branch`命令查看当前分支：\n\n```shell\n$ git branch\n* dev\n  master\n```\n\n`git branch`命令会列出所有分支，当前分支前面会标一个`*`号。\n\n然后，我们就可以在`dev`分支上正常提交，比如对`readme.txt`做个修改，加上一行：\n\n```\nCreating a new branch is quick.\n```\n\n然后提交：\n\n```shell\n$ git add readme.txt \n$ git commit -m \"branch test\"\n[dev b17d20e] branch test\n 1 file changed, 1 insertion(+)\n```\n\n现在，`dev`分支的工作完成，我们就可以切换回`master`分支：\n\n```shell\n$ git checkout master\nSwitched to branch 'master'\n```\n\n切换回`master`分支后，再查看一个`readme.txt`文件，刚才添加的内容不见了！因为那个提交是在`dev`分支上，而`master`分支此刻的提交点并没有变：\n\n![git-br-on-master](https://i.loli.net/2020/09/25/NdFYXhQEvcOe2bp.png)\n\n#### 合并分支到当前分支merge\n\n现在，我们把`dev`分支的工作成果合并到`master`分支上：\n\n```shell\n$ git merge dev\nUpdating d46f35e..b17d20e\nFast-forward\n readme.txt | 1 +\n 1 file changed, 1 insertion(+)\n```\n\n`git merge`命令用于合并指定分支到当前分支。合并后，再查看`readme.txt`的内容，就可以看到，和`dev`分支的最新提交是完全一样的。\n\n注意到上面的`Fast-forward`信息，Git告诉我们，这次合并是“快进模式”，也就是直接把`master`指向`dev`的当前提交，所以合并速度非常快。\n\n当然，也不是每次合并都能`Fast-forward`，我们后面会讲其他方式的合并。\n\n**删除分支**，合并完成后，就可以放心地删除`dev`分支了：\n\n```shell\n$ git branch -d dev\nDeleted branch dev (was b17d20e).\n```\n\n删除后，查看`branch`，就只剩下`master`分支了：\n\n```shell\n$ git branch\n* master\n```\n\n因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在`master`分支上工作效果是一样的，但过程更安全。\n\n#### 新分支的文件\n\n新分支的初始文件默认是在创建时基于的原来的分支基础上的，若要让新分支为空，直接在新分支下删除所有文件并提交，这样新分支就是空了。\n\n#### 用switch切换分支\n\n我们注意到切换分支使用`git checkout `，而前面讲过的撤销修改则是`git checkout -- `，同一个命令，有两种作用，确实有点令人迷惑。\n\n实际上，切换分支这个动作，用`switch`更科学。因此，最新版本的Git提供了新的`git switch`命令来切换分支：\n\n创建并切换到新的`dev`分支，可以使用：\n\n```shell\n$ git switch -c dev\n```\n\n直接切换到已有的`master`分支，可以使用：\n\n```shell\n$ git switch master\n```\n\n使用新的`git switch`命令，比`git checkout`要更容易理解。\n\n#### 小结\n\nGit鼓励大量使用分支：\n\n查看分支：`git branch`\n\n创建分支：`git branch `\n\n切换分支：`git checkout `或者`git switch `\n\n创建+切换分支：`git checkout -b `或者`git switch -c `\n\n合并某分支到当前分支：`git merge `\n\n删除分支：`git branch -d `\n\n### 解决冲突\n\n人生不如意之事十之八九，合并分支往往也不是一帆风顺的。\n\n准备新的`feature1`分支，继续我们的新分支开发：\n\n```shell\n$ git switch -c feature1\nSwitched to a new branch 'feature1'\n```\n\n修改`readme.txt`最后一行，改为：\n\n```shell\nCreating a new branch is quick AND simple.\n```\n\n在`feature1`分支上提交：\n\n```shell\n$ git add readme.txt\n\n$ git commit -m \"AND simple\"\n[feature1 14096d0] AND simple\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n切换到`master`分支：\n\n```shell\n$ git switch master\nSwitched to branch 'master'\nYour branch is ahead of 'origin/master' by 1 commit.\n  (use \"git push\" to publish your local commits)\n```\n\nGit还会自动提示我们当前`master`分支比远程的`master`分支要超前1个提交。\n\n在`master`分支上把`readme.txt`文件的最后一行改为：\n\n```shell\nCreating a new branch is quick & simple.\n```\n\n提交：\n\n```shell\n$ git add readme.txt \n$ git commit -m \"& simple\"\n[master 5dc6824] & simple\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n现在，`master`分支和`feature1`分支各自都分别有新的提交，变成了这样：\n\n![git-br-feature1](https://i.loli.net/2020/09/25/1JpdcNOH9VaMqsg.png)\n\n这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：\n\n```shell\n$ git merge feature1\nAuto-merging readme.txt\nCONFLICT (content): Merge conflict in readme.txt\nAutomatic merge failed; fix conflicts and then commit the result.\n```\n\n果然冲突了！Git告诉我们，`readme.txt`文件存在冲突，必须手动解决冲突后再提交。`git status`也可以告诉我们冲突的文件：\n\n```powershell\n$ git status\nOn branch master\nYour branch is ahead of 'origin/master' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\nYou have unmerged paths.\n  (fix conflicts and run \"git commit\")\n  (use \"git merge --abort\" to abort the merge)\n\nUnmerged paths:\n  (use \"git add <file>...\" to mark resolution)\n\n\tboth modified:   readme.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\n我们可以直接查看readme.txt的内容：\n\n```shell\nGit is a distributed version control system.\nGit is free software distributed under the GPL.\nGit has a mutable index called stage.\nGit tracks changes of files.\n<<<<<<< HEAD\nCreating a new branch is quick & simple.\n=======\nCreating a new branch is quick AND simple.\n>>>>>>> feature1\n```\n\nGit用`<<<<<<<`，`=======`，`>>>>>>>`标记出不同分支的内容，我们修改如下后保存：\n\n```\nCreating a new branch is quick and simple.\n```\n\n再提交：\n\n```shell\n$ git add readme.txt \n$ git commit -m \"conflict fixed\"\n[master cf810e4] conflict fixed\n```\n\n现在，`master`分支和`feature1`分支变成了下图所示：\n\n![git-br-conflict-merged](https://i.loli.net/2020/09/25/GVUhwe5PIapzmBn.png)\n\n用带参数的`git log`也可以看到分支的合并情况：\n\n```shell\n$ git log --graph --pretty=oneline --abbrev-commit\n*   cf810e4 (HEAD -> master) conflict fixed\n|\\  \n| * 14096d0 (feature1) AND simple\n* | 5dc6824 & simple\n|/  \n* b17d20e branch test\n* d46f35e (origin/master) remove test.txt\n* b84166e add test.txt\n* 519219b git tracks changes\n* e43a48b understand how stage works\n* 1094adb append GPL\n* e475afc add distributed\n* eaadf4e wrote a readme file\n```\n\n最后，删除`feature1`分支：\n\n```shell\n$ git branch -d feature1\nDeleted branch feature1 (was 14096d0).\n```\n\n工作完成。\n\n#### 小结\n\n当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。\n\n解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。\n\n用`git log --graph`命令可以看到分支合并图。\n\n### 分支管理策略\n\n通常，合并分支时，如果可能，Git会用`Fast forward`模式，但这种模式下，删除分支后，会丢掉分支信息。\n\n如果要强制禁用`Fast forward`模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\n\n下面我们实战一下`--no-ff`方式的`git merge`：\n\n首先，仍然创建并切换`dev`分支：\n\n```shell\n$ git switch -c dev\nSwitched to a new branch 'dev'\n```\n\n修改readme.txt文件，并提交一个新的commit：\n\n```shell\n$ git add readme.txt \n$ git commit -m \"add merge\"\n[dev f52c633] add merge\n 1 file changed, 1 insertion(+)\n```\n\n现在，我们切换回`master`：\n\n```shell\n$ git switch master\nSwitched to branch 'master'\n```\n\n准备合并`dev`分支，请注意`--no-ff`参数，表示禁用`Fast forward`：\n\n```shell\n$ git merge --no-ff -m \"merge with no-ff\" dev\nMerge made by the 'recursive' strategy.\n readme.txt | 1 +\n 1 file changed, 1 insertion(+)\n```\n\n因为本次合并要创建一个新的commit，所以加上`-m`参数，把commit描述写进去。\n\n合并后，我们用`git log`看看分支历史：\n\n```\n$ git log --graph --pretty=oneline --abbrev-commit\n*   e1e9c68 (HEAD -> master) merge with no-ff\n|\\  \n| * f52c633 (dev) add merge\n|/  \n*   cf810e4 conflict fixed\n...\n```\n\n可以看到，不使用`Fast forward`模式，merge后就像这样：\n\n![git-no-ff-mode](https://i.loli.net/2020/09/25/tOYM2iskC5Pl3La.png)\n\n### Bug分支\n\n------\n\n软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。\n\n当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支`issue-101`来修复它，但是，等等，当前正在`dev`上进行的工作还没有提交：\n\n```shell\n$ git status\nOn branch dev\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n\tnew file:   hello.py\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   readme.txt\n```\n\n并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？\n\n幸好，Git还提供了一个`stash`功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：\n\n```shell\n$ git stash\nSaved working directory and index state WIP on dev: f52c633 add merge\n```\n\n现在，用`git status`查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。\n\n首先确定要在哪个分支上修复bug，假定需要在`master`分支上修复，就从`master`创建临时分支：\n\n```shell\n$ git checkout master\nSwitched to branch 'master'\nYour branch is ahead of 'origin/master' by 6 commits.\n  (use \"git push\" to publish your local commits)\n\n$ git checkout -b issue-101\nSwitched to a new branch 'issue-101'\n```\n\n现在修复bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交：\n\n```shell\n$ git add readme.txt \n$ git commit -m \"fix bug 101\"\n[issue-101 4c805e2] fix bug 101\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n修复完成后，切换到`master`分支，并完成合并，最后删除`issue-101`分支：\n\n```shell\n$ git switch master\nSwitched to branch 'master'\nYour branch is ahead of 'origin/master' by 6 commits.\n  (use \"git push\" to publish your local commits)\n\n$ git merge --no-ff -m \"merged bug fix 101\" issue-101\nMerge made by the 'recursive' strategy.\n readme.txt | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到`dev`分支干活了！\n\n```\n$ git switch dev\nSwitched to branch 'dev'\n\n$ git status\nOn branch dev\nnothing to commit, working tree clean\n```\n\n工作区是干净的，刚才的工作现场存到哪去了？用`git stash list`命令看看：\n\n```shell\n$ git stash list\nstash@{0}: WIP on dev: f52c633 add merge\n```\n\n工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：\n\n一是用`git stash apply`恢复，但是恢复后，stash内容并不删除，你需要用`git stash drop`来删除；\n\n另一种方式是用`git stash pop`，恢复的同时把stash内容也删了：\n\n```shell\n$ git stash pop\nOn branch dev\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n\tnew file:   hello.py\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   readme.txt\n\nDropped refs/stash@{0} (5d677e2ee266f39ea296182fb2354265b91b3b2a)\n```\n\n再用`git stash list`查看，就看不到任何stash内容了：\n\n```shell\n$ git stash list\n```\n\n你可以多次stash，恢复的时候，先用`git stash list`查看，然后恢复指定的stash，用命令：\n\n```shell\n$ git stash apply stash@{0}\n```\n\n\n\n在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。\n\n那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？\n\n有木有更简单的方法？\n\n有！\n\n同样的bug，要在dev上修复，我们只需要把`4c805e2 fix bug 101`这个提交所做的修改“复制”到dev分支。注意：我们只想复制`4c805e2 fix bug 101`这个提交所做的修改，并不是把整个master分支merge过来。\n\n为了方便操作，Git专门提供了一个`cherry-pick`命令，让我们能复制一个特定的提交到当前分支：\n\n```shell\n$ git branch\n* dev\n  master\n$ git cherry-pick 4c805e2\n[master 1d4b803] fix bug 101\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\nGit自动给dev分支做了一次提交，注意这次提交的commit是`1d4b803`，它并不同于master的`4c805e2`，因为这两个commit只是改动相同，但确实是两个不同的commit。用`git cherry-pick`，我们就不需要在dev分支上手动再把修bug的过程重复一遍。\n\n有些聪明的童鞋会想了，既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要`git stash`命令保存现场，才能从dev分支切换到master分支。\n\n#### 小结\n\n修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\n\n当手头工作没有完成时，先把工作现场`git stash`一下，然后去修复bug，修复后，再`git stash pop`，回到工作现场；\n\n在master分支上修复的bug，想要合并到当前dev分支，可以用`git cherry-pick `命令，把bug提交的修改“复制”到当前分支，避免重复劳动。\n\n### Feature分支\n\n------\n\n软件开发中，总有无穷无尽的新的功能要不断添加进来。\n\n添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。\n\n现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。\n\n于是准备开发：\n\n```shell\n$ git switch -c feature-vulcan\nSwitched to a new branch 'feature-vulcan'\n```\n\n5分钟后，开发完毕：\n\n```\n$ git add vulcan.py\n\n$ git status\nOn branch feature-vulcan\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n\tnew file:   vulcan.py\n\n$ git commit -m \"add feature vulcan\"\n[feature-vulcan 287773e] add feature vulcan\n 1 file changed, 2 insertions(+)\n create mode 100644 vulcan.py\n```\n\n切回`dev`，准备合并：\n\n```shell\n$ git switch dev\n```\n\n一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。\n\n但是！\n\n就在此时，接到上级命令，因经费不足，新功能必须取消！\n\n虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：\n\n```shell\n$ git branch -d feature-vulcan\nerror: The branch 'feature-vulcan' is not fully merged.\nIf you are sure you want to delete it, run 'git branch -D feature-vulcan'.\n```\n\n销毁失败。Git友情提醒，`feature-vulcan`分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的`-D`参数。。\n\n现在我们强行删除：\n\n```shell\n$ git branch -D feature-vulcan\nDeleted branch feature-vulcan (was 287773e).\n```\n\n终于删除成功！\n\n#### 小结\n\n开发一个新feature，最好新建一个分支；\n\n如果要丢弃一个没有被合并过的分支，可以通过`git branch -D `强行删除。\n\n\n\n### 多人协作\n\n------\n\n当你从远程仓库克隆时，实际上Git自动把本地的`master`分支和远程的`master`分支对应起来了，并且，远程仓库的默认名称是`origin`。\n\n要查看远程库的信息，用`git remote`：\n\n```shell\n$ git remote\norigin\n```\n\n或者，用`git remote -v`显示更详细的信息：\n\n```shell\n$ git remote -v\norigin  git@github.com:michaelliao/learngit.git (fetch)\norigin  git@github.com:michaelliao/learngit.git (push)\n```\n\n上面显示了可以抓取和推送的`origin`的地址。如果没有推送权限，就看不到push的地址。\n\n#### 推送分支\n\n推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：\n\n```shell\n$ git push origin master\n```\n\n如果要推送其他分支，比如`dev`，就改成：\n\n```shell\n$ git push origin dev\n```\n\n但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？\n\n- `master`分支是主分支，因此要时刻与远程同步；\n- `dev`分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；\n- bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；\n- feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。\n\n总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！\n\n#### 抓取分支\n\n多人协作时，大家都会往`master`和`dev`分支上推送各自的修改。\n\n现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：\n\n```shell\n$ git clone git@github.com:michaelliao/learngit.git\nCloning into 'learngit'...\nremote: Counting objects: 40, done.\nremote: Compressing objects: 100% (21/21), done.\nremote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0\nReceiving objects: 100% (40/40), done.\nResolving deltas: 100% (14/14), done.\n```\n\n当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的`master`分支。不信可以用`git branch`命令看看：\n\n```shell\n$ git branch\n* master\n```\n\n现在，你的小伙伴要在`dev`分支上开发，就必须创建远程`origin`的`dev`分支到本地，于是他用这个命令创建本地`dev`分支：\n\n**命令表明创建远程`origin`的`dev`分支到本地,如果要pull还需建立链接(下文)**\n\n```shell\n$ git checkout -b dev origin/dev\n```\n\n现在，他就可以在`dev`上继续修改，然后，时不时地把`dev`分支`push`到远程：\n\n```shell\n$ git add env.txt\n\n$ git commit -m \"add env\"\n[dev 7a5e5dd] add env\n 1 file changed, 1 insertion(+)\n create mode 100644 env.txt\n\n$ git push origin dev\nCounting objects: 3, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (2/2), done.\nWriting objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nTo github.com:michaelliao/learngit.git\n   f52c633..7a5e5dd  dev -> dev\n```\n\n\n\n你的小伙伴已经向`origin/dev`分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：\n\n```shell\n$ cat env.txt\nenv\n\n$ git add env.txt\n\n$ git commit -m \"add new env\"\n[dev 7bd91f1] add new env\n 1 file changed, 1 insertion(+)\n create mode 100644 env.txt\n\n$ git push origin dev\nTo github.com:michaelliao/learngit.git\n ! [rejected]        dev -> dev (non-fast-forward)\nerror: failed to push some refs to 'git@github.com:michaelliao/learngit.git'\nhint: Updates were rejected because the tip of your current branch is behind\nhint: its remote counterpart. Integrate the remote changes (e.g.\nhint: 'git pull ...') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\n```\n\n推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用`git pull`把最新的提交从`origin/dev`抓下来，然后，在本地合并，解决冲突，再推送：\n\n```shell\n$ git pull\nThere is no tracking information for the current branch.\nPlease specify which branch you want to merge with.\nSee git-pull(1) for details.\n\n    git pull <remote> <branch>\n\nIf you wish to set tracking information for this branch you can do so with:\n\n    git branch --set-upstream-to=origin/<branch> dev\n```\n\n`git pull`也失败了，**原因是没有指定本地`dev`分支与远程`origin/dev`分支的链接**，根据提示，设置`dev`和`origin/dev`的链接：\n\n```shell\n$ git branch --set-upstream-to=origin/dev dev\nBranch 'dev' set up to track remote branch 'dev' from 'origin'.\n```\n\n再pull：\n\n```shell\n$ git pull\nAuto-merging env.txt\nCONFLICT (add/add): Merge conflict in env.txt\nAutomatic merge failed; fix conflicts and then commit the result.\n```\n\n这回`git pull`成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的[解决冲突](http://www.liaoxuefeng.com/wiki/896043488029600/900004111093344)完全一样。解决后，提交，再push：\n\n```shell\n$ git commit -m \"fix env conflict\"\n[dev 57c53ab] fix env conflict\n\n$ git push origin dev\nCounting objects: 6, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (4/4), done.\nWriting objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.\nTotal 6 (delta 0), reused 0 (delta 0)\nTo github.com:michaelliao/learngit.git\n   7a5e5dd..57c53ab  dev -> dev\n```\n\n\n\n因此，多人协作的工作模式通常是这样：\n\n1. 首先，可以试图用`git push origin `推送自己的修改；\n2. 如果推送失败，则因为远程分支比你的本地更新，需要先用`git pull`试图合并；\n3. 如果合并有冲突，则解决冲突，并在本地提交；\n4. 没有冲突或者解决掉冲突后，再用`git push origin `推送就能成功！\n\n如果`git pull`提示`no tracking information`，则说明本地分支和远程分支的链接关系没有创建，用命令`git branch --set-upstream-to  origin/`。\n\n这就是多人协作的工作模式，一旦熟悉了，就非常简单。\n\n#### 小结\n\n- 查看远程库信息，使用`git remote -v`；\n- 本地新建的分支如果不推送到远程，对其他人就是不可见的；\n- 从本地推送分支，使用`git push origin branch-name`，如果推送失败，先用`git pull`抓取远程的新提交；\n- 在本地创建和远程分支对应的分支，使用`git checkout -b branch-name origin/branch-name`，本地和远程分支的名称最好一致；\n- 建立本地分支和远程分支的关联，使用`git branch --set-upstream branch-name origin/branch-name`；\n- 从远程抓取分支，使用`git pull`，如果有冲突，要先处理冲突。\n\n### 远程分支\n\n查看一下现在的分支状态:\n\n```shell\n$ git branch\n* dbg_lichen_star\n  master\n  release\n```\n\n星号(*)表示当前所在分支。现在的状态是成功创建的新的分支并且已经切换到新分支上。\n\n**创建远程分支**\n\n把新建的本地分支push到远程服务器，远程分支与本地分支同名（当然可以随意起名）：\n\n```shell\n$ git push origin dbg_lichen_star:dbg_lichen_star\n$ git push learnGit-https dev\n```\n\n\n使用`git branch -a`查看所有分支，会看到`remotes/origin/dbg_lichen_star`这个远程分支，说明新建远程分支成功。\n\n**删除远程分支**\n我比较喜欢的简单方式，推送一个空分支到远程分支，其实就相当于删除远程分支：\n\n```shell\n$ git push origin :dbg_lichen_star\n```\n\n\n也可以使用：\n\n```shell\n$ git push origin --delete dbg_lichen_star\n```\n\n\n这两种方式都可以删除指定的远程分支","tags":["git"]},{"title":"JAVA制作包","url":"/2020/09/24/JAVA_build_package/","content":"\n\n\n## 将自己的java库打包成.jar并供给调用\n\n以改良print工程为例.\n\n### build package\n\n**编写**\n\n在文件夹下建立自己的java库存放的文件夹`./mypackage`\n\n在`./mypackge`下分别写自己的库函数和类等。\n\n```java\n// ./mypackage/myprint.java\npackage mypackage;\npublic class myprint{\n    public static void println(String args){\n        System.out.println(args);\n    }\n}\n```\n\n`package mypackage`表示该编译单元是名为`mypackage`的类库的一部分，以后打包之后若其他程序想要import并调用此包必须通过`import mypackge.{xx.}*`来实现，若类在`./mypackage/branch1`下，则要改写为\n\n```java\npackage mypackage.branch1;\n```\n\n用`.`表示一级目录.\n\n<!-- more -->\n\n**编译**\n\n在类目录下通过`javac {yourfilename}.java`进行编译,生成`.class`文件等\n\n**打包**\n\n回到`mypackage`的同级目录下对`mypackage`打包，打包成`.jar`文件，jar命令详解可参考：https://www.cnblogs.com/chenjfblog/p/10164967.html\n\n命令`jar cvf {youjarname}.jar mypackage(你的包目录)`\n\n生成的`.jar`作为包，加入java虚拟机的`classpath`中,为防止污染,`classpath`可在每次启动`java`时选定，参考https://www.liaoxuefeng.com/wiki/1252599548343744/1260466914339296\n\n默认的`classpath`是`.\\`表示当前路径，可以把`-cp`写为`-cp .; {...};`，一般最好是加上`.;`再加自己指定的其他路径，应该先应该把当前路径算上。\n\n**利用jar包运行.java程序**\n\n假设打包文件名`myprint.jar`，现在编写`testPack.java`程序\n\n```java\nimport mypackage.*;\npublic class testPack{\n    public static void main(String[]args){\n        myprint  printtest=new myprint();\n        printtest.println(\"Hello World!\");\n    }\n}\n```\n\n把`.jar,.java`放到同一目录下，运行命令：\n\n`java -cp \".\\myprint.jar\" testPack.java`\n\n最好是加上`;`号\n\n`java -cp \".\\How2J\\JAR\\property.jar;\" Test.java`\n\n即可.\n\n不编译直接运行，如果`.jar`在其他地方，设置绝对路径即可：\n\n` java -cp \"D:\\mytool.jar[;]\" .\\HelloWorld.java`\n\n如果编译再运行\n\n`javac -cp \".\\How2J\\JAR\\property.jar;\" Test.java`\n\n编译后的`.class`运行方式是\n\n`java -cp \".\\How2J\\JAR\\property.jar;\" Test`\n\n```\n├─CSApp\n├─ThinkingInJava\n│  ├─chapter1-ObjectIntroduction\n│  ├─chapter2-EverythingIsObject\n│  │  └─Documentation\n│  │      ├─1\n│  │      ├─2\n│  │      └─3\n│  └─chapter3-Operators\n├─LeetCode笔记\n│  ├─assets\n│  └─code\n├─CLRS\n├─dataStructure\n└─How2J\n    ├─InterfaceANDentends\n    │  ├─charactor\n    │  └─property\n    ├─assets\n    ├─DT\n    │  └─property\n    └─JAR\n```\n\n对于.class文件来说，只需要指明包的路径即可；但是对于jar文件来说，必须要指定全路径即路径+文件名的格式，不能只指定一个路径","tags":["java"]},{"title":"GCC 编译命令","url":"/2020/09/24/HowtoUseGCC/","content":"\n[TOC]\n\n## 编译命令\n\n```shell\ngcc  -{...}  -o -{outputfilename} - {....}\n```\n\n`-o`参数是用来指定输出文件名称的，默认是`a.out`，有多个参数时没有顺序要求.\n\n### 四个阶段\n\n`.c`文件转换为可执行文件在`gcc`下分为**预处理、编译、汇编、链接**4个阶段。\n\n注意`.c`文件可以根据参数直接进行到当前参数的阶段。\n\n<!-- more -->\n\n#### 预处理 -E\n\n根据文件所有`#`开头的命令，修改原程序，比如include头文件，把头文件内容加到当前文件对应位置，通常输出文件的扩展名是`.i`\n\n**预处理参数 -E (大写)**\n\n```shell\ngcc -E  file.c -o file.i\ngcc -E .\\helloworld.c -o hellloworld.i #windows10\n```\n\n要指定输出文件名，否则可能直接在shell中把文件打印出来而不生成`.i`文件\n\n#### 编译阶段 -S/s\n\n编译器将文本文件翻译成一个当前平台的汇编语言程序，文件扩展名一般是`.s`\n\n**编译参数 -S/s**\n\n并不要求当前的输入文件是预处理的`.i`，也可以从`.c`直接进行\n\n```shell\ngcc -S file.? -o file.s\ngcc -S .\\helloworld.c -o hellloworld.s\ngcc -S .\\helloworld.i -o helloworld.s\n```\n\n#### 汇编阶段 -C/c\n\n汇编器将`.s`的汇编语言文件程序翻译成机器语言的指令文件，并打包成一个**可重定位目标程序**，生成的文件扩展名是`.o`，这是一个二进制文件，`.o`文件可以供其他`.o`程序连接\n\n**汇编参数 -C/c**\n\n```shell\ngcc -c file.? -o file.o\ngcc -c .\\helloworld.i -o helloworld.o\ngcc -c .\\helloworld.c -o helloworld.o\n#...\n```\n\n#### 链接阶段\n\n在编译过程中，除非使用了`-E、-S、-C`选项（或者编译出错阻止了完整的编译过程）否则最后的步骤都是链接。\n\n直接使用`gcc`即可，事实上如果不加以上参数，`gcc`会直接把`.c`执行到这一阶段生成可执行文件，但是注意如果需要和额外的`.o`文件链接需要在命令中写明.\n\n```shell\ngcc -o helloworld helloworld.c\nPS F:\\MyNotes\\GCC_make> .\\helloworld.exe\n> hello world!\ngcc -o helloworld helloworld.o\n```\n\n貌似不能用`.s`的汇编语言文件作为输入\n\n\n\n#### 多文件编译\n\n编译只需要将`.c`文件作为输入\n\n**分开编译**\n\n注意`.o`文件仍然是不可执行的，需要和依赖的其他`.o`进行链接，如果已经生成了其他的依赖的第三方`.o`，可以用\n\n```shell\ng++ .\\main.o .\\compute.o .\\setProperty.o -o test\n```\n\n生成可执行的`test`文件，这样只有修改了的文件才会重新冲重新汇编成`.o`\n\n也可以把所有`.c/.cpp`一起编译\n\n```shell\ng++ -o test .\\compute.cpp .\\main.cpp .\\setProperty.cpp\n```\n\n但是可能会出错。\n\n\n\n#### 链接到外部库\n\n` -L` 指定库的路径 `-l` 指定需连接的库名 `-I`指定第一个头文件目录\n\n```shell\ngcc -o hello hello.c -I /home/hello/include -L /home/hello/lib -lworld\n```\n\n上面这句表示在编译`hello.c`时：\n\n\n\n大写`I`: `-I /home/hello/include`表示将`/home/hello/include`目录作为第一个寻找头文件的目录，寻找的顺序是：`/home/hello/include-->/usr/include-->/usr/local/include`\n\n\n\n就拿数学库来说，他的库名是m，他的库文件名是libm.so，很容易看出，把库文件名的头`lib`和尾`.so`去掉就是库名了。\n\n**.so和.a**\n\n动态库(.so)\n\n静态库(.a) \n\n静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库。编译之后程序文件大，但加载快，隔离性也好。 动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在。多个应用程序可以使用同一个动态库，启动多个应用程序的时候，只需要将动态库加载到内存一次即可。\n\n\n\n好了现在我们知道怎么得到库名了，比如我们自已要用到一个第三方提供的库名字叫libtest.so，那么我们只要把libtest.so拷贝到`/usr/lib`里，编译时加上`-l test`参数，我们就能用上libtest.so库了（当然要用libtest.so库里的函数，我们还需要与libtest.so配套的头文件）。\n\n**不在主目录里**\n\n放在`/lib`和`/usr/lib`和`/usr/local/lib`里的库直接用-`l`参数就能链接了，但如果库文件没放在这三个目录里，而是放在其他目录里，这时我们只用`-l`参数的话，链接还是会出错，出错信息大概是：`“/usr/bin/ld: cannot find -lxxx”`，也就是链接程序**ld**在那3个目录里找不到`libxxx.so`\n\n这时另外一个参数`-L`就派上用场了，比如常用的`X11`的库，它放在`/usr/X11R6/lib`目录下，我们编译时就要用`-L /usr/X11R6/lib` `-l X11`参数，-L参数跟着的是库文件所在的目录名。\n\n再比如我们把`libtest.so`放在`/aaa/bbb/ccc`目录下，那链接参数就是`-L /aaa/bbb/ccc -l test`\n\n\n\n#### 安装apue.h   （静态库.a）\n\n1. 下载: `[src.3e.tar.gz](http://www.apuebook.com/src.3e.tar.gz)`\n2. 解压:` tar xvf src.3e.tar.gz`\n3. 安装相应库:` sudo apt-get install libbsd-dev`\n4. 进入到apue.3e目录，执行: make\n5. `cp ./include/apue.h  /usr/include/`\n6. `cp ./lib/libapue.a  /usr/local/lib/`\n7. 编译时链接到相应库: `gcc -o 1-3 1-3.c -l apue`，这里把`.h .a`都放到了`/use/local`下，不需要`-L`\n\n命令`cp`即copy，\n\n```\ncp [options] source dest\n```\n\n","tags":["C","C++","编译"]},{"title":"Hello World","url":"/2020/09/24/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n#### command\n\n```bash\n$ hexo clean\n$ hexo g\n$ hexo d\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","tags":["Help"]}]