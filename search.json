[{"title":"WinDbg操作-软件安全实验","url":"/2022/11/05/SoftwareSecurityWindbg_Experiment/","content":"在自己电脑上使用WinDbg解析hello25.exe程序运行时虚拟地址0x00403000h对应的物理地址（验证条件：物理地址与虚拟地址对应的数据应一致）\n\n<!-- more -->\n\n## WinDbg查看物理地址\n\n\n### basis\n\n64位系统下虚拟地址到物理地址的转换\n\n在64位体系中，实现了48位的虚拟地址，剩下的高16位用作符号扩展，要么全是0，要么全是1.\n\n与x86体系结构不同，x64下每级页表的寻址长度变成9位，因为页的大小仍然是4KB=$$2^{12}B$$，但是数据的大小却是64bit=8Byte=$$2^3 B$$，页每个数据是$$2^3 B$$，因此有$$2^9=512$$项，需要9位寻址。\n\n64位体系下，CPU将48位虚拟地址转换成物理地址有三种模型：\n\n1. $$4KB$$页面，使用PML4T,PDPT,PDT,PT四级转换结构\n2. $$2MB$$页面，使用PML4T,PDPT,PDT三级转换结构\n3. $$1GB$$页面，使用PML4T,PDPT二级转换结构\n\n一般讨论第一种.（个人PC一般$$4KB$$页面\n\n48位虚拟地址：\n\n```\n           |           |           |\t\t   |\n0000 0000 0|000 0000 00|00 0000 010|0 0000 0001| 0000 0000 0000\n-----------+-----------+-----------+-----------+----------------\n   PML4E\t\tPDPTE\t\tPDE\t\t\tPTE\t\t\t页内OFFSET\n```\n\n### WinDbg Setting\n\n\n#### Prepare Work\n\n建议用Windows10 64位标准系统，我用的是教育版，去MSDN I tell you上搜索磁力链接，离线到云盘或者下载器下载。\n\nKMS激活：开管理员`cmd`\n\n```bash\nslmgr /ipk NW6C2-QMPVW-D7KKK-3GKT6-VCFB2\n\nslmgr /skms kms.03k.org\n\nslmgr /ato\n```\n\n管理员`cmd`输入\n\n`bcdedit -debug on `命令；如果无法执行很有可能是bios设置了安全启动，需要进入bios将其关闭。\n要选择Debug Tools中的WinDbg x64而不是 x86，WinDbg要用管理员运行\n\n**网络开启全局代理**\n\n启动后`crtl+s`或者找到`symbol search path`按钮，输入：\n`srv*C:\\Symbols*https://msdl.microsoft.com/download/symbols`\n这个`C:\\symbols`就是自己从服务器下载到本地的符号表缓存文件夹,可以自己更改，之后软件就会根据这两个路径找符号表，第一次下载下来后，就可以直接在本地对应路径链接符号表了\n\n启动内核调试,如果不加载就输入`.reolad`执行，流量好几分钟不走再输入`!process`如果执行成功就没问题了,每次启动好像路径要重新设置一下，可参考\n\n每次启动WinDbg时需要确定`srv`是否配置正确。\n\nhttps://zhuanlan.zhihu.com/p/47771088\n\n#### Steps\n\n1. 运行测试程序，添加进程，`db 401000`，查看数据\n\n   ![image-20200922201025478](https://i.loli.net/2020/09/25/NokQGuJI4vfhTHO.png)\n\n2. 运行另一个**WinDbg**，启动本地内核调试，输入命令`process 0 0 Hello25.exe`，查看`DirBase(CR3)`![image-20200922201229684](https://i.loli.net/2020/09/25/sMCb8vIOJ6jzywc.png)\n\n3.  虚拟地址401000，写成48位标准形式是0x 000000 401000\n\n   ```\n   0000 0000 0|000 0000 00|00 0000 010|0 0000 0001| 0000 0000 0000\n   -----------+-----------+-----------+-----------+----------------\n      PML4E\t\tPDPTE\t\tPDE\t\t\tPTE\t\t\t页内OFFSET\n   ```\n\n   PML4E=PDPTE=0,\n\n   PDE=2\n\n   PTE=1\n\n   页内偏移=0\n\n   由于PML4E=0，上一级的12-35位提供下一级的物理基地址高24位，低12位补0，输入`!dq 39c45000+0*8`,\n\n   这里一个页项64bit=8字节，第0个页项，对应项字节地址(即首地址)即`+0*8`\n\n   ![image-20200922202933529](https://i.loli.net/2020/09/25/SgZpdFrVBclI7ms.png)\n\n4. PDPTE=0，输入`!dq 07e7e6000+0*8`\n\n   ![image-20200922203027885](https://i.loli.net/2020/09/25/QEUVWRDumPYXHij.png)\n\n5. PDE=2，输入`!dq 069ca7000+0x2*8`\n\n   ![image-20200922203141535](https://i.loli.net/2020/09/25/WJQaxIomzBSpwlN.png)\n\n6. PTE=1，输入`!dq 028968000+0x1*8`\n\n   ![image-20200922203305876](https://i.loli.net/2020/09/25/LuPGD4wOJcXSbTH.png)\n\n7. 页内偏移0，输入`!db 11a6be000+0`\n\n   ![image-20200922203947854](https://i.loli.net/2020/09/25/4bGEwgiYuUl1z6e.png)\n\n   比较第1步，成功访问相同数据。\n\n","tags":["Windows","软件安全"]},{"title":"C/cpp的小数IEEE-754","url":"/2022/11/05/IEEE-754/","content":"\n\n很多人对学python的爱好者diss的常见手段之一，就是让他们解释这个程序的结果\n```python\na=0.1+0.2\nprint(a)\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200119222726243.png)\n这其实就是涉及到计算机中小数的表示了.\n接下来，我们用最适合解释这种表示的C语言来介绍计算机中小数的表示，以及经典的IEEE-754标准。\n<!-- more -->\n## C中小数的表示\n\n学过C的都知道，.C中，小数一般都是被叫做浮点数，`int`表示的是**整型变量**，对应的就是`float`，被称作**浮点数**(英文float)，很多人就将其理解为C的小数变量表示。此外，C中还有一种浮点数形式`double`，熟悉概念的人应该知道，这是**双精度浮点数**的意思(英文double)\n它们两者之间的区别？一般的了解者可能会说，`double`比`float`表示小数时精度更高一些。的确是这样，但是我们怎样更加深入的理解，并解释上文python程序中这一个貌似有点奇怪的结果呢？我们先从一个简单C程序说起.\n**考虑到查阅资料和网页工具的方便性，使用Dev-c++，编译环境TDM-GCC 4.9.2 64bit**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200119223701687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dhbGRlbnRo,size_16,color_FFFFFF,t_70)\n如之前所述，可以看到，a变量为`float`型，也是4字节32bit，将其赋值0.3，打印小数8位，也出现了类似python程序的现象，出现了一个`1`，为什么好端端赋值0.3确打印了个1出来？这就涉及到二进制小数的表示了。\n首先说明，十进制表示法中，有一些数字是没法用有限位表示的，比如循环小数，无理数。\n同样，二进制表示法，也有小数没办法用有限位表示，而且，很多十进制可以轻松表达的小数，二进制表示却较复杂.\n 1. 0.75的二进制表示，0.11 ，二进制可以有限位精确表示\n 2. 然而0.3的二进制表示则是：`0.0 100 1100 1100 1100 1100 1100 1100110011001100110011001101....`事实上这么多位下来还是没有完全精确的表示0.3。而我们之前看到，a占据的内存单元只有32bit，甚至无法满足这个精度(由于IEEE-754标准)\n 那么这个32位的浮点数a怎么存储0.3，为什么打印小数点后8位是0.3000 0001呢？\n 经典的IEEE-754标准可以解释这个问题\n\n\n## IEEE-754 浮点标准 部分简介\n\n在计算机小数表示中，小数一般是科学计数法表述的.\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200119224953992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dhbGRlbnRo,size_16,color_FFFFFF,t_70)\n`float`又被称为单精度浮点表示，`double`是与之对应的双精度浮点表示。\n这里只介绍`float`，结构如上图上部，双精度与其类似，但是精度更高。后续可以自然理解。\n\n之所以叫做**浮点**，这其实是一个非常形象的描述\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200119231148576.png)\n小数点其实是可以运动的，根据指数m，小数点可以左移/右移 |m|位，以此来表示不同大小的\"小数\"。\n\n比如我们定义这样一个C变量\n```c\nfloat a=0.75;\n```\n那么,a可以简单写成二进制0.11，用二进制科学计数法表示也就是`1.1 x 2^-1`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200119225410853.png)\n\n有关IEEE-754:\n是20世纪80年代以来最广泛使用的浮点数运算标准，为许多CPU与浮点运算器所采用。这个标准定义了表示浮点数的格式（包括负零-0）与反常值（denormal number）），一些特殊数值（无穷（Inf）与非数值（NaN）），以及这些数值的“浮点数运算符”；它也指明了四种数值舍入规则和五种例外状况（包括例外发生的时机与处理方式）。\nIEEE 754规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现）。只有32位模式有强制要求，其他都是选择性的。大部分编程语言都有提供IEEE浮点数格式与算术，但有些将其列为非必需的。例如，IEEE 754问世之前就有的C语言，有包括IEEE算术，但不算作强制要求（C语言的float通常是指IEEE单精确度，而double是指双精确度）。\n该标准的全称为IEEE二进制浮点数算术标准（ANSI/IEEE Std 754-1985），又称IEC 60559:1989，微处理器系统的二进制浮点数算术（本来的编号是IEC 559:1989）。后来还有“与基数无关的浮点数”的“IEEE 854-1987标准”，有规定基数为2跟10的状况。最新标准是“ISO/IEC/IEEE FDIS 60559:2010”。\n\n另外，IEEE((美国)电气和电子工程师协会)的读法，I-E-E-E是一种方式，但其实口语中更广泛的是读作I triple E\n\n现在，按照上图，按照IEEE-754,我们这样存储0.75：\ns：符号位 0正1负，显然，这里是正数，为0\nexp：表示指数，30-23共8位，可表示0-255，在IEEE-754标准中，exp段可视为无符号数，但是并不是表示数字的指数，而是指数的`带偏阶的指数`。可表示的范围中，1-254部分，有一个偏阶bias，bias=2^(k-1) -1 k是exp段位数，因此单精度中bias=127(双精度是1023)\n科学计数法表示中的指数E=-1，加上偏阶bias，结果是126，所以exp段应该存储的是无符号数126，0111 1110\nfrac:这一段被称作**尾数**，也就是科学计数法中小数部分'0.1'，这里有一个现象，exp=1--254可表示的数字往往被称作**规格化数**，可以看到，小数点前的部分都是'1',所以，可以节省一位(因为知道规格化数肯定小数点前一位是1)，所以，IEEE-754标准规定，规格化数的有**前导位1**，尾数只要存储小数点后的数字就行了。小数点后是0.'1'，那么用23位尾数表示就是：\n(0.) `1000 0000 .....0000` （23位）\n\n**这里可以看到，浮点数的精度其实是靠尾数决定的，尾数位数越多，可表示的精度越高，这就是为什么有52位位数的double比有23位尾数的float精度高的原因**\n\n现在，根据IEEE-754规格化单精度浮点数标准，我们可以写出32位浮点数0.75在IEEE-754格式下的表示了:\n0--0111 1110--1000 0000 0000 0000 0000 000\n\n接着，我们还要填之前的一个坑:以上只是IEEE-754对**规格化数**的表示，规格化数exp段范围是只有1-254的。那么0和255呢？规定如下:\n\nexp=0时，如果尾数frac也为0，那么此时编码表示0，这就是\"机器零\"，因为机器无法表示比它更小的数了，便把它作为0\n\nexp=0,frac非0，这表示的是**非规格化数**，规格化数都是1.xxx * 2^xx ，单精度浮点数能够表示的最接近零的数绝对值是1.000..00 x 2 ^ -126,为了填补规格化数和机器零之间的\"距离\"， 就有了非规格化数。与规格化数不同，非规格化数没有前导为位1，也就是说，可以表示 0.xx * 2 ^ xx 。\n此外，非规格化数的偏阶bias也不再是127，而是126，也就是说，它表示的其实是0.xxx * 2 ^ -126  将它与规格化最小数1.000..00 x 2 ^ -126 比较，`填补规格化数和机器零之间的\"距离\"`\n这一解释就显得非常的形象了。\n\n此外，\nexp=255,frac=0时，表示无穷(溢出了)，(为了形成实数的拓扑闭集合)\nexp=255,frac非0，表示NaN,即不是数的意思，Not a Number,这里不再过多介绍。\n.\n.\n.\nDouble表示与float类似。不再赘述。而目前的最新标准中，新增了其他一些精度表示，比如半精度，其实也是与上述介绍类似的。\n\n\n## 对0.3000 0001的解释\n到现在为止，其实对浮点数的介绍已经不少了.现在尝试解释0.3000 0001的由来。\nfloat a=0.3,\n可知，0.3在二进制小数中不能通过有限精度表示的，\n0.3=0.0 100 1100 1100 1100 1100 1100 1100110011001100110011001101....\n根据IEEE-754,我们选取小数点后第一个非0数字开始：\n1 00110011001100110011001100110011001100110011001101...\n1作前导位，接着后24位是：0011 0011 0011 0011 0011 001 1 \n而单精度尾数段只有23位，进行舍入:\n注意看这里的最后一位是1，而不是0， 这里就采用了四舍五入的原则，回忆一下，在10进制中比如0.57四舍五入保留一位小数的结果是0.6，那就是因为第2位小数是7，超过了5所以进1位，  在二进制中就看下一位是1还是0，如果是1就进位。24位二进制串中的第24位为1，因此进位到23位。再进位，所以尾数是：\n0011 0011 0011 0011 0011 010\n转换为IEEE-754格式:\n0--0111 1101--0011 0011 0011 0011 0011 010\n这就是单精度float变量a对0.3的存储，我们读取它.\n1.0011 0011 0011 0011 0011 010 x 2^ 125-127=\n0.01 0011 0011 0011 0011 0011 010 \n转换为10进制:\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200119235800501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dhbGRlbnRo,size_16,color_FFFFFF,t_70)\n读取8位小数，0.3000 0001 1，四舍五入，就是0.3000 0001.\n当然，我们还可以验证9位小数，0.3000 00011 9，四舍五入结果应该是0.3000 00012，通过程序验证:\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200120000009393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dhbGRlbnRo,size_16,color_FFFFFF,t_70)\n程序结果完美符合我们的预测。\n\n此外，还想讨论几件事情，\nhttp://www.styb.cn/cms/ieee_754.php\n这个网站提供了IEEE-754转换功能，之前我也是认为正确的，但是在写这篇文章时意外感觉作者可能有了一个疏忽，就是忘记了尾数的舍入。\n0.3在该网站的结果是这样的:\n0--0111 1101--0011 0011 0011 0011 0011 001\n尾数对应段应该是0011 0011 0011 0011 0011 0011，但是作者似乎没有考虑舍入，而是直接截取了23位，这就造成结果是0.0100110011001100110011001\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200120000649263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dhbGRlbnRo,size_16,color_FFFFFF,t_70)\n无法解释本环境下的结果了。当然这只是我的想法，欢迎大家指正。\n除此之外，IEEE-754还可以解释一些浮点运算现象，比如一个大数加上一个较小的小数，结果会发现较小数\"没有加上去\",不过这些就涉及更复杂的保护，舍入，粘贴位的概念了，以后有机会可以再写写。\n","tags":["计算机组成原理","C"]},{"title":"海康威视SDK开发","url":"/2022/11/05/HikVisionSDK/","content":"\n## demo测试运行\n\ndemo和动态连接库分为Linux和Windows版本,其中Windows使用Visual Studio构建工程,\nLinux下使用Ubuntu,但是要注意参考makefile编写\n\n<!-- more -->\n\n### 平台：Windows 64\n\nVisual Studio 2019\n\n#### demo运行\n....\n....\n#### 接口测试\n....\n....\n### 平台：Linux 64\n\nUbuntu + g++ + makefile\n\n#### demo运行\n....\n....\n#### 接口测试\n....\n....\n\n\n\n### RTSP链接格式\n\nHikvision \tRTSP 直播流：rtsp://admin:abcd1234@192.168.31.167:554/h264/ch1/sub/av_stream\n\t\t     \t\t\t\t\t\t\t\t  rtsp://admin:abcd1234@192.168.31.167:554/Streaming/Channels/101?transportmode=unicast\n  \t\t\t\t\tRTSP 回放流：rtsp://admin:abcd1234@192.168.31.167:554/streaming/tracks/101?starttime=20210509t122832z&endtime=20210509t125205z","tags":["C++"]},{"title":"Hello World","url":"/2022/11/05/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n#### command\n\n```bash\n$ hexo clean\n$ hexo g\n$ hexo d\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","tags":["Help"]},{"title":"磁盘格式与数据恢复实验","url":"/2022/11/05/DiskFormatANDataRecover/","content":"\n## 实验1 磁盘格式与数据恢复\n\n### 1.1实验名称\n\n磁盘格式与数据恢复\n\n### 1.2实验目的\n\n1)    了解磁盘的物理和逻辑结构\n\n2)    熟悉FAT32文件系统\n\n3)    学会使用磁盘编辑软件\n\n4)    了解文件删除、格式化的基本原理\n\n5)    能够利用工具或者手工恢复被删除的文件\n\n<!-- more -->\n\n### 1.3实验步骤及内容\n\n**第一阶段：**\n\n熟悉WinHex的使用。\n\nn 熟悉磁盘工具的使用。\n\nn 利用WinHex查看物理磁盘和逻辑磁盘。\n\nn 了解WinHex中相关工具的用法。\n\n \n\n**第二阶段：**\n\nn 分析本地硬盘的主引导扇区\n\nn 利用磁盘编辑工具查看MBR磁盘分区并分析：\n\nn 主引导扇区由哪些部分组成？\n\nn 四个主分区项的内容各代表什么？\n\nn 分析主扩展分区表的结构。\n\nn 通过分区项来确定每个本地逻辑盘的位置以及大小，并画出本地硬盘的逻辑结构。\n\nn 每个本地盘的开始扇区位置，总扇区数，结束扇区位置，各扩展分区表扇区位置，保留空间数量。\n\nn  利用磁盘编辑工具查看GPT磁盘分区并分析\n\nn GPT分区结构与MBR的具体差异有哪些？\n\nn 主分区头所在扇区包括哪些重要内容，验证这些重要内容的有效性。\n\nn 通过分区节点分析自己硬盘的各分区信息。\n\n**第三阶段：**\n\nn  熟悉FAT32文件格式。\n\nn 用WinHex打开某个FAT32分区格式的逻辑盘。\n\nn 查看该逻辑盘的起始扇区，分析起始扇区中的相关字段（BPB:BIOS Parameter Block）。\n\nn 查看FAT1和FAT2的内容和大小。\n\nn 查看该逻辑盘的根目录区。\n\nn 查看某个文件的目录项结构和FAT链以及具体存储位置。\n\nn 在根目录下建立文本文件：test-学号后3位.txt，其中填充60K左右的文本字符保存（注意：先行存储其他数据使得该文件的首簇高位不为0）。\n\nn 查看该文件的目录项，对其进行分析，并得到该文件所在位置以及大小。\n\nn 查看首簇位置，并得到簇链表。通过簇链表查看该文件内容。\n\nn 记录首簇位置（14H-15H,1AH-1BH）和文件大小（1CH-1FH）。\n\n \n\n**第四阶段：**\n\nn 手工恢复被删除的文件\n\nn 删除前面所建立的文件。(del&shift+del)\n\nn 利用WinHex在该文件所在盘符查找该.txt文件的目录项。\n\nn 查看目录项的变化。\n\nn 利用该残余目录项来计算被删除的文件所在的位置。\n\nn 手工恢复该文件（文件名、首簇高位、簇链表修复）。\n\n\n\n**课后习题思考：**\n\nn   在磁盘分区过程中，用户提供了哪些信息？分析分区工具的工作原理。\n\nn  高级格式化与低级格式化的具体原理和区别是什么？\n\nn 查找资料，对NTFS分区的总体结构进行分析，尝试对NTFS下删除的文件进行手工恢复。\n\nn   用数据粉碎工具（如金山、360、Strongdisk等）粉碎指定文件，分析其数据粉碎原理。\n\nn  通过分区表看到的分区字节数为何与资源管理器中看到的分区字节数有差异？\n\nn   如果删除的文件是长文件名，如何恢复所有文件名。\n\n\n\n### 1.4实验关键过程、数据及其分析\n\n#### 1.4.1 WinHex的使用\n\n以管理员模式启动WinHex，在选项界面中选择要查看的磁盘，如图1.1所示\n\n​            ![image-20200926231839438](https://i.loli.net/2020/09/26/kvCuXMUqwQ49FD1.png)                       \n\n​               图**1.1** 启动WinHex\n\n\n\n在WinHex操作界面中，选择自己要查看的逻辑盘和物理盘，确定即可打开相应的磁盘查看，如图1.2所示 ，左上角显示的是磁盘的文件目录，左下角显示的是磁盘的数据区数据信息。\n\n​     ![image-20200926231848471](https://i.loli.net/2020/09/26/5pcERn2Ay6rdFbP.png)\n\n​                图**1.2** 利用WinHex查看磁盘\n\n  \n\n由于磁盘快照生成较久，选择更新快照。\n\n \n\n在WinHex中主要使用的工具是进入指定的偏移或地址。选择导航,可以选择相应的功能，如图1.3所示 \n\n​     ![image-20200926231858453](https://i.loli.net/2020/09/26/DEyxN73pnqhiQmK.png)\n\n​              图**1.3** WinHex导航工具的使用\n\n转到偏移量可以选择基地址以及偏移量跳转到自己想要到达的地址；跳至扇区可以通过扇区为单位进行跳转。文件记录功能主要用于文件恢复过程中，利用其跳转到簇链表相应的位置。\n\n在对磁盘进行修改之后，由于WinHex没有更新磁盘信息，需要重新对磁盘进行快照，如图1.4所示。\n\n ![image-20200926231911378](https://i.loli.net/2020/09/26/2NxfwuLUX7SkKZs.png)\n\n​               图**1.4** WinHex重新快照\n\n#### 1.4.2 分析本地硬盘的主引导扇区【GPT＋MBR】\n\n\n\n利用WinHex打开MBR分区形式的磁盘，如图2.1所示，从00开始的512个字节是硬盘的主引导扇区。\n\n ![image-20200926231923158](https://i.loli.net/2020/09/26/TirBOU1yCPbjchq.png)\n\n​               图**2.1** 查看主引导扇区\n\n主引导扇区是硬盘第一个扇区，它由主引导记录(MBR),硬盘主分区表(DPT)和引导扇区标记(ID)三部分组成。\n\n主引导记录MBR：从0至多占用的0x1BDH一共446个字节，存放系统主引导程序。\n\n硬盘主分区表DPT:占用64个字节，0x1BEH – Ox1FDH , 它有四个分区项，每个项16个字节，最后8=4+4个字节存放相对扇区地址和该分区占用的扇区数量。\n\n通过WinHex自带的分区表-模板，查看物理硬盘的结构，如图2.2所示\n\n \n\n​            ![image-20200926231929898](https://i.loli.net/2020/09/26/FLqvs8NZYUklRE6.png)\n\n图**2.2** 分区表模板查看\n\n\n\n可以看到，前1B8个字节是其引导代码，从1BE开始是硬盘分区表，最后以55AA结尾。每一个分区表项的长度是16个字节。如图2.3所示。\n\n ![image-20200926231937004](https://i.loli.net/2020/09/26/ID2Nmlb9Gx7Vjq6.png)\n\n​            图**2.3** 分区表地址数据\n\n以第一个分区为例，分区表从80 20开始，到0F 00结束。00 0F A0 00表示其占有的扇区数，00 00 08 00代表其起始扇区(16进制)。0x800=2048,这与分区信息是对应的，如图2.4所示。\n\n ![image-20200926231942449](https://i.loli.net/2020/09/26/LdG4KwltmkcYI91.png)\n\n​             图**2.4** 分区第一扇区地址\n\n \n\n下面根据WinHex中分区扇区数量计算分区大小并与Windows计算机磁盘管理进行验证。\n\n以E盘为例，根据图2.3，其具有0x00513800=5322752个扇区，一个扇区512字节，因此具有2661376KB=2599MB=2.53GB，与图2.4分区E是对应的。\n\n \n\n扩展分区：主分区表只支持4个分区项目，当分区更多时无法满足，因此需要扩展分区表EBR。要使用扩展分区，首先，主分区表中必须要有一个基本扩展分区项，用于指出所有扩展分区总体信息。所有的扩展逻辑盘全在这个基本扩展分区项指出的主扩展分区中。其结构如图2.5所示。\n\n ![image-20200926231950488](https://i.loli.net/2020/09/26/gVezuUsHtiBOCbZ.png)\n\n图**2.5** 扩展分区和逻辑盘\n\n\n\n查看GPT分区，首先添加一块硬盘，进入cmd，输入命令diskpart，显示挂载在主机上的磁盘，进入磁盘转换。输入命令将其转换为GPT分区格式\n\n ![image-20200926231957708](https://i.loli.net/2020/09/26/5ksNXwEJWKTO9qv.png)\n\n  图**2.6** 转换磁盘分区格式\n\n\n\n使用WinHex打开硬盘1，如图2.7所示\n\n ![image-20200926232005449](https://i.loli.net/2020/09/26/Jmgxs4LqiXvnhu5.png)\n\n  图**2.7** GPT磁盘信息\n\n利用WinHex自带的分区表模板，查看GPT磁盘的分区表信息，如图2.8所示\n\n​     ![image-20200926232036170](https://i.loli.net/2020/09/26/BJ1VLlEnogSQYjw.png)\n\n​                          图**2.8** GPT磁盘分区表\n\n可以看到从1BE-1CA是磁盘保护性的主引导记录MBR，从0x200=512开始是磁盘的分区表。从0x400=1024开始是CPT磁盘的第一个分区表项。\n\n分区表项中存储了对应分区的起始LBA，LBA即逻辑地址块，是GPT分区形式的基本单位，每一个LBA的大小也是512个字节。\n\n分区表项1中，起始LBA块是34，终止LBA块是65569，下面验证分区1的大小：\n\n由分区表项信息，分区1一共有65569-34+1=65536个LBA块，因此有32768KB=32MB，对比图2.7分区1信息，可以发现正确。\n\n \n\nGPT与MBR分区的具体差异：\n\n​    1、MBR分区表最多只能识别2TB左右的空间，大于2TB的容量将无法识别从而导致硬盘空间浪费；GPT分区表则能够识别2TB以上的硬盘空间。\n\n2、MBR分区表最多只能支持4个主分区或三个主分区+1个扩展分区(逻辑分区不限制)；GPT分区表在Windows系统下可以支持128个主分区。\n\n3、在MBR中，分区表的大小是固定的；在GPT分区表头中可自定义分区数量的最大值，也就是说GPT分区表的大小不是固定的。\n\n#### 1.4.3 FAT32文件系统格式分析\n\n\n\n用WinHex打开一个FAT32格式的逻辑盘，如图3.1所示\n\n ![image-20200926232049173](https://i.loli.net/2020/09/26/Fi4BEOPnSe7A3c2.png)\n\n​              图**3.1** FAT32磁盘\n\n \n\n通过WinHex自带的引导扇区模板，查看该逻辑盘的起始扇区，分析起始扇区中的相关字段，如图3.2所示。\n\n \n\n0-3是其固有的字段，从0xB开始，到0x20是该逻辑盘对应的BPB(BIOS Parameter Block，BIOS参数块)字段。通过BPB可以查看这个磁盘的基本信息。如每个扇区的字节数，这里可以看到是512字节，每个簇有8个扇区。\n\n \n\nFAT32 Selection是该FAT32文件系统的一个表，从表中可以看到每一个FAT它的扇区数是5183，最后在偏移量1FE处也是以55AA结尾。\n\n![image-20200926232058111](https://i.loli.net/2020/09/26/wKZADkpriBtHXYS.png)\n\n​               图**3.2** 引导扇区模板\n\n在FAT32文件系统的磁盘中，FAT1和FAT2是存储簇链表的地方，由于FAT区十分重要，故存放两个，作为备份。\n\n在根目录区，建立了每个文件的索引，并记录了每一个文件相关的信息。用WinHex模板打开根目录查看文件，如图3.3所示\n\n ![image-20200926232113509](https://i.loli.net/2020/09/26/TLaQ7J2qz5uvGDk.png)\n\n​                      图**3.3** 查看根目录\n\n本磁盘中存储了hello25.exe文件，通过根目录模板，可以查看它的文件名是HELLO25，扩展名是EXE，创建时间是9/22 23:55，簇高位号是0，文件大小是2560Bytes=2.5KB等等信息。\n\n   在根目录下建立文本文件：test-学号后3位.txt，其中填充60KB左右的文本字符保存。更新磁盘快照，利用WinHex查看txt文件的簇，在左上角文件管理中右键选择该文件，导航->列出的簇，并取消缩短连续簇链表，如图3.4所示。\n\n![image-20200926232216972](https://i.loli.net/2020/09/26/X3IHpRa7qVltNoJ.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图**3.4** 查看根目录\n\n可以看到txt文件的首簇号是506，总共用了13个簇来存储。根据Windows文件属性可以看到，文件实际大小是50.7KB，但是占用了52KB，而图3.4显示文件占用了13个簇，由前面的信息，本系统一个簇是8个扇区，4KB，13个簇正是52KB，这就是文件实际的占用大小。50.7KB文件需占用13个簇才可以存下。\n\n \n\n下面根据文件占用的簇跳转到文件内容的位置。在WinHex中选择导航->跳转到FAT记录->填写首簇号506，跳转到簇链表对应位置。由于是FAT32系统，簇链表中每个结点大小是4个字节，文件占用13个簇，在簇链表中便占据52个字节，如图3.5所示，高亮部分即txt文件的占用的簇链表。\n\n​\t\t\t\t\t\t\t\t ![image-20200926232234479](https://i.loli.net/2020/09/26/AGgKlyOqrDaTLZb.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图**3.5** 文件簇链表\n\n\n\n注意到簇链表首结点值是0x000001FB=507,而文件的首簇号是506，这是因为在FAT32文件系统中，FAT表是连续存储的，访问首簇号结点对应的值默认是首簇号+1.\n\n \n\n记录下文件的簇链表，在WinHex中选择导航->跳至扇区，填写簇506/507，可以发现跳转到txt文件存储处，如图3.6所示。\n\n​\t\t\t\t\t\t ![image-20200926232252109](https://i.loli.net/2020/09/26/l1hRGqpKba7WPS3.png)\t\t\n\n​                            \t\t\t\t\t\t\t\t\t\t\t\t图**3.6** 文件簇链表\n\n\n\n \n\n根据目录项的定义，一个目录项占据32个字节，00H-07H字节是文件的正名，1CH-1FH是文件的占据的字节大小，打开WinHex，利用模板跳转到test-001.txt的目录项所在的位置，如图3.7所示。\n\n![image-20200926232312698](https://i.loli.net/2020/09/26/SDBtVYF8qM7Ej9W.png)\t\t\n\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图**3.7** 查看目录项\n\n可以看到第1AH-1BH=26-27字节是(逆序)  01FA，14H-15H=20-21字节是 0000，组成的首簇号是0x000001FA=506，正是该文件之前查看的首簇号，说明观察正确。而1CH-1FH=28-31是文件占据的字节大小，0x00 00 CB 10=51984Byte=50.765625KB，与文件系统中显示的大小50.8KB保持一致。说明从目录项中正确读取到了文件信息。\n\n#### 1.4.4 手工恢复被删除的文件\n\n\n\n首先使用Del键进行回收站删除，重新建立磁盘快照。在WinHex中查看文件目录，可以看到事实上文件及其对应的数据仍然还存在，如图4.1所示。\n\n ![image-20200926232327821](https://i.loli.net/2020/09/26/RKHYTZeI3LSUbC7.png)\n\n​                    图**4.1** 回收站删除后查看文件\n\n跳转至目录表对应位置，如图4.2所示，\n\n ![image-20200926232335457](https://i.loli.net/2020/09/26/OfCKGvt6o3Raln2.png)\n\n​                      图**4.2** 回收站删除后查看目标表项\n\n \n\n将图4.2和图3.7进行对比，发现目录项首字节在文件删除后被进行了修改成E5，表示被删除标记。选择E5所在字节，右键编辑->填充选块，将E5随便修改成任意数据，选择文件->保存扇区，可以发现文件恢复，如图4.3所示，但是文件名会根据修改数据改变首字母。至此，完成了回收站文件删除后的文件恢复。\n\n ![image-20200926232344488](https://i.loli.net/2020/09/26/XGKcARIVZLi2leF.png)\n\n​                      图**4.3** 恢复文件\n\n再使用shift+delete删除文件EXP.TXT，转到目录项如图4.4所示\n\n ![image-20200926232352588](https://i.loli.net/2020/09/26/zLq9jHMxaudpf6h.png)\n\n​                         图**4.4 删除后目录项**\n\n可以看到目录项也被修改，首字节被修改为E5，首簇号高16位清0，但是复原后并不能打开文件，因为簇链表数据已经丢失.\n\n\n\n查看簇链表，如图4.5所示\n\n ![image-20200926232402349](https://i.loli.net/2020/09/26/SYKNyqFkOj2DdCb.png)\n\n​                               图**4.5**\n\n \n\n可以发现簇链表对应的位置已经全部清0，要恢复文件，必须恢复簇链表再修改目录项。因此现在根据其相邻的目录项来确定其首簇号。可以看到前一个目录项的首簇号是0x00040152，文件的字节大小是0x A00，占用一个簇，因此恢复文件的首簇号是0x00040153，因此依次将图4.5中的项目进行修复，如图4.6所示\n\n ![image-20200926232408684](https://i.loli.net/2020/09/26/vzi2YO3mdkuol6B.png)\n\n​                            图**4.6**\n\n将目录项被修改的首字节和首簇高位修复。如图4.7所示\n\n ![image-20200926232415456](https://i.loli.net/2020/09/26/u4Fkl5XHVBdiGLg.png)\n\n \n\n​                            图**4.7**\n\n保存，打开文件夹，发现文件恢复成功。如图4.8所示\n\n ![image-20200926232421687](https://i.loli.net/2020/09/26/cgeoaFbXxDirQ3W.png)\n\n​                          图**4.8**\n\n \n\n#### 1.4.5 课后习题思考\n\n在磁盘分区过程中，用户提供了要分区的大小，分区的文件格式，盘符等信息。利用分区大小，系统构建新的逻辑盘，利用指定的文件格式，对分区进行格式化。\n\n \n\n低级格式化就是将空白的磁盘划分出柱面和磁道,再将磁道划分为若干个扇区,每个扇区又划分出标识部分ID、间隔区GAP和数据区DATA等。可见,低级格式化是高级格式化之前的一件工作, 高级格式化就是清除硬盘上的数据、生成引导区信息、初始化FAT表、标注逻辑坏道等。\n\n \n\n数据粉碎一般会对文件所在的位置进行重复擦写，粉碎文件之后，利用winhex查看对应偏移量数据可以发现数据已经被完全改写。\n\n \n\n文件名过长时恢复文件后需要手工查看文件数据区的文件名进行恢复\n\n \n\n \n\n1、计算机是以二进制来记录数据的，所以单位从K到M再到G是以1024来进级的。而人们习惯了十进制，以1000来进级。这样造成了显示容量和实际一样。当然，也有些不良厂家以1000为进级计算标注容量，使实际容量缩水。\n\n2、硬盘在分区和格式化时会占用一定的存储空间来保存分区等一些信息，所以实际可用容量就会小于分区的容量。\n\n3、因为硬盘的分区一般都是按扇区为单位分的（每个扇区的大小一般从几KB到几百KB，不同硬盘和格式不完全相同），所以人为输入的分区容量不一定是扇区的整数倍，系统会自动取近似的容量来划分分区。\n\n### 1.5实验体会和拓展思考\n\n通过了解磁盘格式，使我对系统对于磁盘的管理有了全新的认识，之前我曾经以为磁盘分区与分类文件夹差不多，但是通过实验让我深刻理解了分区的机理和作用。对于簇链表的学习也使我理解了文件删除和恢复的机理，明白了恶意病毒破坏数据的手段。对于FAT32,NTFS等文件系统的学习使我了解到了不同文件系统各自的特点，以及在今后如何正确为自己的电脑设置合适的文件系统。\n\n通过学习磁盘格式与数据恢复，使我对如何攻击与防御恶意软件破坏数据指明了一条方向，也促使我今后提升对于文件保护的意识。而数据恢复实验可以帮助我在紧急情况下恢复自己的重要数据\n\n \n\n ","tags":["Windows","软件安全"]},{"title":"CMU15-721-Lecture02笔记","url":"/2022/11/05/CMU15-721-Lec02-In-Memory-Databases/","content":"## Lec-02 In-memory Databases \n\n[video](https://www.bilibili.com/video/BV1Y7411o7GN?p=2)\n\n## Disk-oriented DBMS(面向磁盘的数据库)\n\n- 数据主要是在**非易失性存储器**中(HDD,SSD),以页或者帧(Page or Frame)为单位做存储\n\n- 使用在内存中的**缓存池(Buffer Pool)**来将磁盘数据导入内存并在内存中处理，缓存来自磁盘的page\n\n- **槽(slot)** , 数据库的数据存储结构是通过表空间（table space）->段(segment)->区（或者簇extends)->页（page)进行管理, 其中页是最小管理单元，而数据库表的记录在页内保持有序的方法就是**槽(slot)管理**，以MySQL为例分析：\n\n  - Innodb是多条记录对应一个槽，而槽的作用就是用来在页面内进行数据搜索的，因为查找一条数据时，是用B+tree来保证通过树形结构找到一个记录所在的页，而在页内部真正找到这条记录是通过槽来完成的\n\n  - 在页内部，Innodb划分出一个区域比如10byte，作为槽的区域（当然槽的区域根据使用的大小是可以变化的），一个槽占用2byte。那么现在可以将这个槽看作是长度大小为5的数组。\n\n  - 当我们将一条数据记录写入数据库时，通过数据库的Innodb最终决定写入在这个页内。那么写在这个页的哪里呢？形象的理解就是这个页，就相当于一张A4纸；数据记录就是一条信息，我们写的时候就是从上到下，从左至右的方法去写。Innodb的写入方式基本上也是这样的写入方式，但是这其中有很多问题需要数据库去解决。其中就是写入后数据记录的顺序问题。\n\n  - 模拟数据的写入过程：\n    1.写入第1条记录1，该记录在页内偏移量为120，长度为100，则slot[0]=120;\n    2.写入第2条记录10，该记录在页内偏移量为220，长度为100，则slot[1]=220;\n    3.写入第3条记录5，该记录在页内偏移量为320，长度为100，此时需要移动slot的内容，则slot[1]=320;slot[2]=220;\n\n  - 这样通过 slot的有序性，就保证了写入页内的数据记录的有序性。上面说过，Innodb的槽是多条记录对应一个slot。对于innodb它页内记录通过双向链表相互联接。\n\n    - slot[0]=120对应记录1的偏移量，而记录1有指向记录2的指针，记录2有指向记录3的指针；\n    - slot[1]=420对应记录4的偏移量（这里假设每条记录长度为100），记录4有指向记录5的指针，记录5的指向记录6的指针\n    - 后面的槽依次类推。slot[2]管理7，8，9三条记录；slot[3]管理10，11，12三条记录；slot[4]管理13，14，15三条记录；\n\n<!-- more -->\n    \n\n### Buffer Pool Issue（缓冲池）\n\n由于引入了缓冲池，磁盘型DB完整过程如下：\n\n- 完整查询过程：\n\n  1.从数据库索引中查找对应记录的**Page ID**和**slot(数据库页的槽)**，如果索引的节点没有加载到内存中，需要从磁盘中加载\n\n  2.去页表中查询该Page是否已经加载到内存\n\n  3.如果没有的话，从磁盘中找到该页，并且复制到缓存池的一帧中(frame)\n\n  4.如果缓存池没有空的frame，则按一定替换原则evict某页(LRU,FIFO,CLOCK)，并且还要更新page table\n\n  5.如果page是dirty的即被修改过，就需要把对应修改后的内容写回磁盘中\n\n  ![image-20211005210919847](https://gitee.com/waldenth/blogimage/raw/master/img/image-20211005210919847.png)\n\n- 这种架构的坏处：\n\n  Every tuple access has to go through the buffer pool manager regardless of whether that data will always be in memory.\n\n  无论查询元组是否在内存中都需要去buffer pool中查找\n\n  \n\n### Concurrency Control Issue（并发控制）\n\n面向磁盘的数据库假定**在尝试访问没有加载到内存的数据的时候，事务会“stall(抛锚，熄火)”**\n\n当然系统为了提高性能会允许一个事务stall的时候同时执行其他事务，靠上锁来实现ACID。(原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）)\n\n锁存储在in-memory的一个hash-table，叫lock manager,避免锁数据被swap到磁盘上，**All the info about lock is in memory!**，所有关于锁的信息全部在内存中！\n\n\n\n### Logging & Recovery Issue （日志与恢复）\n\n- 事务提交前，把修改写入**Write-Ahead-Log(WAL)**，WAL包含undo log 和 redo log\n- 每一个log entry（日志项）包含事务修改前后数据的镜像\n- The DBMS flushes WAL pages to disk separately from corresponding modified database pages, so it takes extra work to keep track of what log record is responsible for what page，DBMS将WAL页面从相应的修改过的数据库页面分别刷新到磁盘，因此需要额外的工作来跟踪日志记录负责哪个页面\n- 在事务提交之前，必须将所有修改刷新到WAL。\n- 需要维护log record是负责哪一个page的信息（利用LSN Log Sequence Number）\n\n### 开销比较\n\n如果不考虑disk flushing,面向磁盘数据库开销主要花费在：\n\nBUFFER POOL 34%\n\nLATCHING 14% (隔离的是线程,保证并发线程操作临界资源的正确性)\n\nLOCKING 16% (隔离的是事务，一般锁住的是数据库的表，行)\n\nLOGGING 12% \n\nB-TREE KEYS 16% 索引查找时间\n\nCPU 7% \n\n## In-memory DBMS(面向内存的数据库)\n\n背景：DRAM的发展，价格和容量足以把整个数据库的数据都存储到内存中\n\n这时候磁盘IO不再是数据库性能的瓶颈,而需要考虑以下可以优化的性能瓶颈\n\n- Locking/Latching：\n\n  - lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。此外，lock，正如在大多数数据库中一样，是有死锁机制的。\n  - latch一般称为闩锁（轻量级锁），因为其要求锁定的时间必须非常短。\n\n  ![20201207103106902](https://gitee.com/waldenth/blogimage/raw/master/img/20201207103106902.png)\n\n- Cache-line misses，cache命中\n\n- Pointer chasing，指针追踪\n\n- Predicate evaluation，谓词运算\n\n- Data movement and copying，数据移动和复制\n\n- Networking ，网络通信\n\n因为所有数据都在内存中，因此不会存在脏页，也不需要维护undo log信息，也不需要LSN机制\n\n\n\n### 与面向磁盘数据库的一些不同\n\n- Data Organization\n\n  1.从索引Index中查找数据指针所在的Block ID与Offset\n\n  2.根据Block ID与Offset找到数据指针的内存地址,指针存储在Fixed-Length Data Blocks(固定长度数据块)中\n\n  3.根据这个64-bits指针去Variable-Length Data Blocks(可变长度数据块)去寻找真正的数据\n\n![微信截图_20200426204351](https://gitee.com/waldenth/blogimage/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200426204351.png)\n\n\n- Indexes\n\n  In-memory DBMS并不会记录索引的更新。数据库再重启时，当所有数据加载到内存之后直接在内存中重建这个索引。\n\n- Query Processing\n\n  由于数据都在内存中，随机访问的速度并不比顺序访问要差\n\n- Logging & Revocery\n\n  1.仍然需要维护WAL，即修改数据库之前,把修改记录写入WAL然后同步到内存中\n\n  2.使用组提交来提交WAL，分摊fsync系统调用的开销\n\n  3.也可以使用更轻量级的logging策略，只存储redo信息\n\n- Concurrency control——提供原子性与隔离性\n\n  在面向磁盘的数据库中，锁是存放在另外一个内存中的hash表，与数据记录本身是分开来存储的。因为记录是可能被swap到外存。\n\n  而在IMDB中，由于数据记录一直在内存中，不会swap到外存，因此可以把记录有关的锁的信息与记录一起保存。\n\n  所以尝试取锁的效率=尝试获得数据的效率\n\n  瓶颈在于：多个事务同时尝试访问某个数据，只有一个事务能抢到锁\n\n  如果用mutex实现的话性能太慢，建议用CAS来保证这里的同步\n\n### CAS\n\n```c++\n__sync_bool_compare_and_swap(&M, 20, 30);\n```\n\n当且仅当M地址代表的值等于20的时候，把M地址所在的值设为30。否则失败，因为不等于的话说明这个值肯定被别的线程修改了\n\n### 并发控制\n\n接下来的会详细讨论并发控制的一些策略：\n\n#### 悲观策略——2 PHASE LOCKING 两段锁协议\n\n操作数据之前一定先抢锁\n\n2PL解决死锁两种策略：\n\n- 1.死锁探测\n\n  维护一个队列，队列存放着拿着锁的事务，一个后台线程周期性扫这个队列的事务，看哪些事务在运行，哪些stall，这就可以找到发生死锁的事务。\n\n- 2.死锁预防\n\n  在分配锁之前看有没有其他事务已经拿到这把锁，如果这个事务拿不了锁：\n\n  1）等待\n\n  2）自杀\n\n  3）杀死另外一个拿锁的事务\n\n#### 乐观策略——Timestamp Ordering 时间戳排序\n\n操作数据不抢锁，事务提交的时候比较时间戳，以时间为序，按每个transaction的时间来排谁先执行\n\n参考资料：[CMU Database Systems - Timestamp Ordering Concurrency Control - fxjwind - 博客园 (cnblogs.com)](https://www.cnblogs.com/fxjwind/p/11114136.html)\n\n##### Basic T/O Protocol\n\n首先每个txn(事务，Transaction)需要有一个独一无二的timestamp，这个在单机很容易实现；其次，Timestamp必须是单调递增的，最后，不同的schema会选择在不同的时间给txn打上timestamp，可能是txn刚到的时候，也可能是txn执行完的时候。\n\n**txn是transaction的简写，ts为timestamp**\n\n每一个事务txn都会分配一个时间戳，每一个记录的头部维护上一次事务操作的时间戳。然后事务对时间戳进行操作的时候，比较现在事务的时间戳与记录头部当前的时间戳。\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/312753-20190626115738779-1763049586.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n以课程案列，首先，给每个object加上读时间戳和写时间戳，表示最后一次读写该对象的时间，如图，对象A,B分别加上读写时间戳，均为10000，然后对图中事务txn的每个读写操作进行时间戳比对\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/image-20211005214323198.png\" alt=\"image-20211005214323198\" style=\"zoom: 33%;\" />\n\n\n\n- 读Object操作：拿**当前事务ts**和**Object的写ts**比较，如果Object的写ts比较新，那么读需要abort，因为，你不能读一个未来的值\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/image-20211005214627964.png\" alt=\"image-20211005214627964\" style=\"zoom:50%;\" />\n\n可以看到，案例txn中READ(A)首先将本事务ts=10001对象A的写ts=10000比较，本txn的ts更新，因此READ(A)操作合法，并将对象A的读时间戳更新为$max(R-ts(A),ts(txn))$,这里将A读ts改为10001\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/312753-20190626120512358-23562664.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/image-20211005215134735.png\" alt=\"image-20211005215134735\" style=\"zoom: 50%;\" />\n\n写Object操作：要同时将本txn的ts和该对象的读、写ts进行比较，比较对象写是因为你不能用过去的值覆盖未来的值，比较对象读是因为如果有未来的txn读过这个值，你就不能再更新。**即事务txn的时间戳要大于对象的读和写时间戳才可以进行操作**，操作后，需要更新对象的写时间戳\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/image-20211005215251726.png\" alt=\"image-20211005215251726\" style=\"zoom:50%;\" />\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/312753-20190626120535298-1569553780.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n课程案例中，假设本txn在省略号部分处理其他事情，无读写操作，此时另一个时间戳为10005的txn进行了对对象A的写操作，A的写ts修改为10005，当本txn其他事情完成，继续后续另一个的WRITE(A)操作时：\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/image-20211005215739487.png\" alt=\"image-20211005215739487\" style=\"zoom:50%;\" />\n\n进行ts比较，此时txn ts=10001< Object A write ts=10005，操作不合法，事务无法提交，处理失败，回滚\n\n##### 乐观并发控制\n\n```\n1. Read Phase: Transaction’s copy tuples accessed to private work space to ensure repeatable reads, and\nkeep track of read/write sets.\n\n2. Validation Phase: When the transaction invokes COMMIT, the DBMS checks if it conflicts with other\ntransactions. Parallel validation means that each transaction must check the read/write set of other\ntransactions that are trying to validate at the same time. Each transaction has to acquire locks for its\nwrite set records in some global order. Original OCC uses serial validation.\nThe DBMS can proceed with the validation in two directions:\n? Backward Validation: Check whether the committing transaction intersects its read/write sets\nwith those of any transactions that have already committed.\n? Forward Validation: Check whether the committing transaction intersects its read/write sets with\nany active transactions that have not yet committed.\n\n3. Write Phase: The DBMS propagates the changes in the transactions write set to the database and\nmakes them visible to other transactions’ items. As each record is updated, the transaction releases\nthe lock acquired during the Validation Phase\n```\n\n具体可以参考slides的过程\n\n##### 时间戳的分配策略\n\n- 基于互斥量：并发性能低\n- 原子加操作:   CAS操作去维护一个全局计数器\n- 批量原子加操作\n- 硬件CLOCK:  Intel CPU only\n- 硬件计数器: 尚未有硬件实现\n\n#### 并发控制的性能瓶颈\n\n- Lock Thrashing 锁抖动\n\n  Each transaction waits longer to acquire locks, causing other transaction to wait longer to acquire\n  locks.\n\n  Can measure this phenomenon by removing deadlock detection/prevention overhead. \n\n  solution： force txns to acquire locks in primary key order\n\n- Memory Allocation 内存分配\n\n  Copying data on every read/write access slows down the DBMS because of contention on the memory\n  controller.\n\n  Default libc malloc is slow. Never use it \n\n- Timestamp Allocation 时间戳分配\n\n","tags":["database"]},{"title":"微机原理-第三章-内存储器习题","url":"/2022/11/05/80X86-chapter3-Memory/","content":"\n### 3.8\n\n#### 3.8.1\n\n$512\\times 1b$的RAM芯片表示其有512个数据地址，每个数据1bit，要组成$16K\\times 8b$的存储矩阵，需要\n$$\n\\frac{16K}{512}\\times\\frac{8b}{1b}=32\\times8=256\n$$\n个RAM芯片，为保证实现每个数据8bit，需要分组，一组由8个$512\\times 1b$RAM芯片组成，为保证有$16K$个数据地址，每组只有512个地址，因此需要32组。\n\nRAM芯片数：256\n\n片内地址位数：$log_2{512}=9$\n\n片选地址位数(芯片选择端)：$log_2{\\frac{16K}{512}}=5$\n\n<!-- more -->\n\n#### 3.8.2\n\nRAM芯片数：$\\frac{16K}{1024}\\times\\frac{1b}{8b}=16\\times8=128$\n\n片内地址位数：$log_2{1024}=10$\n\n片选地址位数(芯片选择端)：$log_2{16}=4$\n\n#### 3.8.3\n\nRAM芯片数：$\\frac{16K}{2K}\\times\\frac{8b}{4b}=8\\times2=16$\n\n片内地址位数：$log_2{2K}=11$\n\n片选地址位数(芯片选择端)：3\n\n#### 3.8.4\n\nRAM芯片数：$\\frac{16K}{8K}\\times\\frac{8b}{8b}=2$\n\n片内地址位数：$log_2{8K}=13$\n\n片选地址位数(芯片选择端)：1\n\n### 3.14\n\nRAM芯片数：$\\frac{16K}{4k}\\times\\frac{8b}{1b}=4\\times8=32$\n\n片内寻址位数：$log_2{4K}=12$，因此低12位$A_0 - A_{11}$作为片内寻址\n\n片选地址位数：$14-12=2$，$A_{12},A_{13}$作为片选信号\n\n### 3.17\n\n采用字结构方式组织\n\n 2764为$8K\\times 8$结构，13根地址线，8根数据线\n\n* 字结构方式：一个字节的8位制作在一块芯片上，选中芯片可一次性读/写8位信息，封装时引线较多。例如：1K的存储器芯片由128×8组成，访问它要7根地址线和8根数据线。\n* 位结构方式：1个芯片内的基本单元作不同字的同一位，8位由8块芯片组成。优点是芯片封装时引线少，例如： 1 K存储器芯片由1024×1组成，访问它要10根地址线和1根数据线。\n\n由题干，地址区域为`00000H`至`0000 0111 1111 1111 1111H`，因此$A_{19}-A_{15}$为0，用$A_{19}-A_{17}$经过负与门产生$G_1$，$A_{16}$产生${G2}^- A^-$，$A_{15}$产生${G2}^- B^-$，$A_{14}-A_{13}$经过74LS138产生片选信号送至4个芯片，$A_0-A{12}$作为地址线\n\n![image-20200928174748637](https://i.loli.net/2020/09/28/qIPTkhexXAzcjGs.png)","tags":["计算机组成原理"]},{"title":"CSAPP Bomb Lab","url":"/2022/11/05/bomblabProcedure/","content":"\n## Bomb Lab Procedure\n\nThis is an x86-64 bomb for self-study students. \n\n**ATTENTION:**\nif `gdb` says its authority  not enough, \n`sudo su`\n`chmod 777 bomb `\n\n#### 准备工作\n\n首先使用`Linux objdump`工具反汇编保存bomb二进制文件的反汇编代码bomb.asm\n\n```bash\nobjdump -d bomb > bomb.asm\n```\n\n再开启`gdb`调试bomb二进制文件\n\n```bash\ngdb bomb\n```\n\n**注意**\n\n`gdb run`可能会提示权限不够，要修改成可读可写可执行，输入命令\n\n```bash\nsudo su;\nchomd 777 bomb\n```\n\n#### 查看代码\n\n##### C 代码\n\n首先查看`.c`代码，由于缺少头文件和其他文件，只能查看`bomb`的整体逻辑\n\n这一段起始代码是尝试进行读文件操作，大概意识是拆除炸弹可以把所有的炸弹密钥字符串写入一个文档，然后将路径作为参数传递给`bomb`启动执行，如果没有传递参数，那么炸弹密钥通过命令行读取\n\n```c\nint main(int argc, char *argv[])\n{\n    char *input; //源代码38行\n\n    /* Note to self: remember to port this bomb to Windows and put a \n     * fantastic GUI on it. */\n\n    /* When run with no arguments, the bomb reads its input lines \n     * from standard input. */\n    if (argc == 1) {  \n\tinfile = stdin;\n    } \n\n    /* When run with one argument <file>, the bomb reads from <file> \n     * until EOF, and then switches to standard input. Thus, as you \n     * defuse each phase, you can add its defusing string to <file> and\n     * avoid having to retype it. */\n    else if (argc == 2) {\n\tif (!(infile = fopen(argv[1], \"r\"))) {\n\t    printf(\"%s: Error: Couldn't open %s\\n\", argv[0], argv[1]);\n\t    exit(8);\n\t}\n    }\n\n    /* You can't call the bomb with more than 1 command line argument. */\n    else {\n\tprintf(\"Usage: %s [<input_file>]\\n\", argv[0]);\n\texit(8);\n    }\n```\n\n下面这一段是初始化炸弹` initialize_bomb();`想必是一个初始化函数，然后打印开始提示信息\n\n```c\n/* Do all sorts of secret stuff that makes the bomb harder to defuse. */ //66行\n    initialize_bomb();\n\n    printf(\"Welcome to my fiendish little bomb. You have 6 phases with\\n\");\n    printf(\"which to blow yourself up. Have a nice day!\\n\");\n```\n\n主体部分，程序分为6个phase，每一个都需要你输入一行字符串，然后对应调用phase_n()函数进行判断是否触发炸弹\n\n```c\n/* Hmm...  Six phases must be more secure than one phase! */  //72\n    input = read_line();             /* Get input                   */\n    phase_1(input);                  /* Run the phase               */\n    phase_defused();                 /* Drat!  They figured it out!\n\t\t\t\t      * Let me know how they did it. */\n    printf(\"Phase 1 defused. How about the next one?\\n\");\n\n    /* The second phase is harder.  No one will ever figure out\n     * how to defuse this... */\n    input = read_line();\n    phase_2(input);\n    phase_defused();\n    printf(\"That's number 2.  Keep going!\\n\");\n\n    /* I guess this is too easy so far.  Some more complex code will\n     * confuse people. */\n    input = read_line();\n    phase_3(input);\n    phase_defused();\n    printf(\"Halfway there!\\n\");\n\n    /* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */\n    input = read_line();\n    phase_4(input);\n    phase_defused();\n    printf(\"So you got that one.  Try this one.\\n\");\n    \n    /* Round and 'round in memory we go, where we stop, the bomb blows! */\n    input = read_line();\n    phase_5(input);\n    phase_defused();\n    printf(\"Good work!  On to the next...\\n\");\n\n    /* This phase will never be used, since no one will get past the\n     * earlier ones.  But just in case, make this one extra hard. */\n    input = read_line();\n    phase_6(input);\n    phase_defused();\n\n    /* Wow, they got it!  But isn't something... missing?  Perhaps\n     * something they overlooked?  Mua ha ha ha ha! */\n    \n    return 0;\n```\n\n##### 反汇编代码\n\n先定位到main\n\n```asm\n0000000000400da0 <main>:\n  400da0:\t53                   \tpush   %rbx\n  400da1:\t83 ff 01             \tcmp    $0x1,%edi\n  400da4:\t75 10                \tjne    400db6 <main+0x16>\n  400da6:\t48 8b 05 9b 29 20 00 \tmov    0x20299b(%rip),%rax        # 603748 <stdin@@GLIBC_2.2.5>\n  400dad:\t48 89 05 b4 29 20 00 \tmov    %rax,0x2029b4(%rip)        # 603768 <infile>\n  400db4:\teb 63                \tjmp    400e19 <main+0x79>\n  400db6:\t48 89 f3             \tmov    %rsi,%rbx\n  400db9:\t83 ff 02             \tcmp    $0x2,%edi\n  400dbc:\t75 3a                \tjne    400df8 <main+0x58>\n  400dbe:\t48 8b 7e 08          \tmov    0x8(%rsi),%rdi\n  400dc2:\tbe b4 22 40 00       \tmov    $0x4022b4,%esi\n  400dc7:\te8 44 fe ff ff       \tcallq  400c10 <fopen@plt>\n  400dcc:\t48 89 05 95 29 20 00 \tmov    %rax,0x202995(%rip)        # 603768 <infile>\n  400dd3:\t48 85 c0             \ttest   %rax,%rax\n  400dd6:\t75 41                \tjne    400e19 <main+0x79>\n  400dd8:\t48 8b 4b 08          \tmov    0x8(%rbx),%rcx\n  400ddc:\t48 8b 13             \tmov    (%rbx),%rdx\n  400ddf:\tbe b6 22 40 00       \tmov    $0x4022b6,%esi\n  400de4:\tbf 01 00 00 00       \tmov    $0x1,%edi\n  400de9:\te8 12 fe ff ff       \tcallq  400c00 <__printf_chk@plt>\n  400dee:\tbf 08 00 00 00       \tmov    $0x8,%edi\n  400df3:\te8 28 fe ff ff       \tcallq  400c20 <exit@plt>\n  400df8:\t48 8b 16             \tmov    (%rsi),%rdx\n  400dfb:\tbe d3 22 40 00       \tmov    $0x4022d3,%esi\n  400e00:\tbf 01 00 00 00       \tmov    $0x1,%edi\n  400e05:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400e0a:\te8 f1 fd ff ff       \tcallq  400c00 <__printf_chk@plt>\n  400e0f:\tbf 08 00 00 00       \tmov    $0x8,%edi\n  400e14:\te8 07 fe ff ff       \tcallq  400c20 <exit@plt>\n  400e19:\te8 84 05 00 00       \tcallq  4013a2 <initialize_bomb>;初始化炸弹\n  \n  \n  ;gdb调试信息：\n  ;(gdb) print (char*)(0x402338)\n  ;$1 = 0x402338 \"Welcome to my fiendish little bomb. You have 6 phases with\"\n  400e1e:\tbf 38 23 40 00       \tmov    $0x402338,%edi\n  400e23:\te8 e8 fc ff ff       \tcallq  400b10 <puts@plt>\n  ;gdb) print (char*)(0x402378)\n  ;$2 = 0x402378 \"which to blow yourself up. Have a nice day!\"\n  400e28:\tbf 78 23 40 00       \tmov    $0x402378,%edi\n  400e2d:\te8 de fc ff ff       \tcallq  400b10 <puts@plt>;打印提示信息\n  ; edi(第一参数寄存器)存放要打印的字符串的地址，通过callq  400b10 <puts@plt>打印\n  ;=========================================================================\n  ;下面一段就是一个炸弹,炸弹先调用read_line,然后将返回的地址传递给phase_n函数，\n  ;如果输入的不正确那么就会执行爆炸函数输出bomb!\n  ;\n  ;\n  ;; 获取输入字符串,rax返回值是字符串地址\n  400e32:\te8 67 06 00 00       \tcallq  40149e <read_line>\n  ;; 获取的输入字符串地址赋给rdi\n  400e37:\t48 89 c7             \tmov    %rax,%rdi\n  400e3a:\te8 a1 00 00 00       \tcallq  400ee0 <phase_1>\n  400e3f:\te8 80 07 00 00       \tcallq  4015c4 <phase_defused>\n  400e44:\tbf a8 23 40 00       \tmov    $0x4023a8,%edi\n  400e49:\te8 c2 fc ff ff       \tcallq  400b10 <puts@plt>\n  \n  \n  400e4e:\te8 4b 06 00 00       \tcallq  40149e <read_line>\n  400e53:\t48 89 c7             \tmov    %rax,%rdi\n  400e56:\te8 a1 00 00 00       \tcallq  400efc <phase_2>\n  400e5b:\te8 64 07 00 00       \tcallq  4015c4 <phase_defused>\n  400e60:\tbf ed 22 40 00       \tmov    $0x4022ed,%edi\n  400e65:\te8 a6 fc ff ff       \tcallq  400b10 <puts@plt>\n  \n  \n  400e6a:\te8 2f 06 00 00       \tcallq  40149e <read_line>\n  400e6f:\t48 89 c7             \tmov    %rax,%rdi\n  400e72:\te8 cc 00 00 00       \tcallq  400f43 <phase_3>\n  400e77:\te8 48 07 00 00       \tcallq  4015c4 <phase_defused>\n  400e7c:\tbf 0b 23 40 00       \tmov    $0x40230b,%edi\n  400e81:\te8 8a fc ff ff       \tcallq  400b10 <puts@plt>\n  \n  \n  400e86:\te8 13 06 00 00       \tcallq  40149e <read_line>\n  400e8b:\t48 89 c7             \tmov    %rax,%rdi\n  400e8e:\te8 79 01 00 00       \tcallq  40100c <phase_4>\n  400e93:\te8 2c 07 00 00       \tcallq  4015c4 <phase_defused>\n  400e98:\tbf d8 23 40 00       \tmov    $0x4023d8,%edi\n  400e9d:\te8 6e fc ff ff       \tcallq  400b10 <puts@plt>\n  \n  \n  400ea2:\te8 f7 05 00 00       \tcallq  40149e <read_line>\n  400ea7:\t48 89 c7             \tmov    %rax,%rdi\n  400eaa:\te8 b3 01 00 00       \tcallq  401062 <phase_5>\n  400eaf:\te8 10 07 00 00       \tcallq  4015c4 <phase_defused>\n  400eb4:\tbf 1a 23 40 00       \tmov    $0x40231a,%edi\n  400eb9:\te8 52 fc ff ff       \tcallq  400b10 <puts@plt>\n  \n  \n  400ebe:\te8 db 05 00 00       \tcallq  40149e <read_line>\n  400ec3:\t48 89 c7             \tmov    %rax,%rdi\n  400ec6:\te8 29 02 00 00       \tcallq  4010f4 <phase_6>\n  400ecb:\te8 f4 06 00 00       \tcallq  4015c4 <phase_defused>\n  400ed0:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400ed5:\t5b                   \tpop    %rbx\n  400ed6:\tc3                   \tretq   \n  400ed7:\t90                   \tnop\n  400ed8:\t90                   \tnop\n  400ed9:\t90                   \tnop\n  400eda:\t90                   \tnop\n  400edb:\t90                   \tnop\n  400edc:\t90                   \tnop\n  400edd:\t90                   \tnop\n  400ede:\t90                   \tnop\n  400edf:\t90                   \tnop\n```\n\n查看`read_line`\n\n```asm\n000000000040149e <read_line>:\n  40149e:\t48 83 ec 08          \tsub    $0x8,%rsp\n  4014a2:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  4014a7:\te8 4d ff ff ff       \tcallq  4013f9 <skip>\n  4014ac:\t48 85 c0             \ttest   %rax,%rax\n  4014af:\t75 6e                \tjne    40151f <read_line+0x81>\n  4014b1:\t48 8b 05 90 22 20 00 \tmov    0x202290(%rip),%rax        # 603748 <stdin@@GLIBC_2.2.5>\n  4014b8:\t48 39 05 a9 22 20 00 \tcmp    %rax,0x2022a9(%rip)        # 603768 <infile>\n  4014bf:\t75 14                \tjne    4014d5 <read_line+0x37>\n  4014c1:\tbf d5 25 40 00       \tmov    $0x4025d5,%edi\n  4014c6:\te8 45 f6 ff ff       \tcallq  400b10 <puts@plt>\n  4014cb:\tbf 08 00 00 00       \tmov    $0x8,%edi\n  4014d0:\te8 4b f7 ff ff       \tcallq  400c20 <exit@plt>\n  4014d5:\tbf f3 25 40 00       \tmov    $0x4025f3,%edi\n  4014da:\te8 01 f6 ff ff       \tcallq  400ae0 <getenv@plt>\n  \n  4014df:\t48 85 c0             \ttest   %rax,%rax\n  ; rax为零则跳转到4014ee,否则edi清零并callq  400c20 <exit@plt>\n  4014e2:\t74 0a                \tje     4014ee <read_line+0x50>\n  4014e4:\tbf 00 00 00 00       \tmov    $0x0,%edi\n  4014e9:\te8 32 f7 ff ff       \tcallq  400c20 <exit@plt>\n  \n  4014ee:\t48 8b 05 53 22 20 00 \tmov    0x202253(%rip),%rax        # 603748 <stdin@@GLIBC_2.2.5>\n  4014f5:\t48 89 05 6c 22 20 00 \tmov    %rax,0x20226c(%rip)        # 603768 <infile>\n  4014fc:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401501:\te8 f3 fe ff ff       \tcallq  4013f9 <skip>\n  401506:\t48 85 c0             \ttest   %rax,%rax\n  401509:\t75 14                \tjne    40151f <read_line+0x81>\n  40150b:\tbf d5 25 40 00       \tmov    $0x4025d5,%edi\n  401510:\te8 fb f5 ff ff       \tcallq  400b10 <puts@plt>\n  401515:\tbf 00 00 00 00       \tmov    $0x0,%edi\n  40151a:\te8 01 f7 ff ff       \tcallq  400c20 <exit@plt>\n  40151f:\t8b 15 3b 22 20 00    \tmov    0x20223b(%rip),%edx        # 603760 <num_input_strings>\n  401525:\t48 63 c2             \tmovslq %edx,%rax\n  401528:\t48 8d 34 80          \tlea    (%rax,%rax,4),%rsi\n  40152c:\t48 c1 e6 04          \tshl    $0x4,%rsi\n  401530:\t48 81 c6 80 37 60 00 \tadd    $0x603780,%rsi\n  401537:\t48 89 f7             \tmov    %rsi,%rdi\n  40153a:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  40153f:\t48 c7 c1 ff ff ff ff \tmov    $0xffffffffffffffff,%rcx\n  401546:\tf2 ae                \trepnz scas %es:(%rdi),%al\n  401548:\t48 f7 d1             \tnot    %rcx\n  40154b:\t48 83 e9 01          \tsub    $0x1,%rcx\n  40154f:\t83 f9 4e             \tcmp    $0x4e,%ecx\n  ;ecx有符号小于等于0x4e则跳转到40159a(引爆炸弹的下一条指令处)\n  401552:\t7e 46                \tjle    40159a <read_line+0xfc> \n  \n  401554:\tbf fe 25 40 00       \tmov    $0x4025fe,%edi\n  401559:\te8 b2 f5 ff ff       \tcallq  400b10 <puts@plt>\n  40155e:\t8b 05 fc 21 20 00    \tmov    0x2021fc(%rip),%eax        # 603760 <num_input_strings>\n  401564:\t8d 50 01             \tlea    0x1(%rax),%edx\n  401567:\t89 15 f3 21 20 00    \tmov    %edx,0x2021f3(%rip)        # 603760 <num_input_strings>\n  40156d:\t48 98                \tcltq   \n  40156f:\t48 6b c0 50          \timul   $0x50,%rax,%rax\n  401573:\t48 bf 2a 2a 2a 74 72 \tmovabs $0x636e7572742a2a2a,%rdi\n  40157a:\t75 6e 63 \n  40157d:\t48 89 b8 80 37 60 00 \tmov    %rdi,0x603780(%rax)\n  401584:\t48 bf 61 74 65 64 2a \tmovabs $0x2a2a2a64657461,%rdi\n  40158b:\t2a 2a 00 \n  40158e:\t48 89 b8 88 37 60 00 \tmov    %rdi,0x603788(%rax)\n  401595:\te8 a0 fe ff ff       \tcallq  40143a <explode_bomb> ;引爆炸弹\n  40159a:\t83 e9 01             \tsub    $0x1,%ecx\n  40159d:\t48 63 c9             \tmovslq %ecx,%rcx\n  4015a0:\t48 63 c2             \tmovslq %edx,%rax\n  4015a3:\t48 8d 04 80          \tlea    (%rax,%rax,4),%rax\n  4015a7:\t48 c1 e0 04          \tshl    $0x4,%rax\n  4015ab:\tc6 84 01 80 37 60 00 \tmovb   $0x0,0x603780(%rcx,%rax,1)\n  4015b2:\t00 \n  4015b3:\t83 c2 01             \tadd    $0x1,%edx\n  4015b6:\t89 15 a4 21 20 00    \tmov    %edx,0x2021a4(%rip)        # 603760 <num_input_strings>\n  4015bc:\t48 89 f0             \tmov    %rsi,%rax\n  4015bf:\t48 83 c4 08          \tadd    $0x8,%rsp\n  4015c3:\tc3                   \tretq   \n```\n\n`strings_not_equal`函数\n\n```asm\n0000000000401338 <strings_not_equal>:\n  401338:\t41 54                \tpush   %r12\n  40133a:\t55                   \tpush   %rbp \n  40133b:\t53                   \tpush   %rbx ; rbp,rbx压栈,说明该函数要使用\n  ; 分别赋值rdi,rsi,说明匹配的字符串地址应该在rdi,rsi处\n  40133c:\t48 89 fb             \tmov    %rdi,%rbx ;\n  40133f:\t48 89 f5             \tmov    %rsi,%rbp \n  \n  401342:\te8 d4 ff ff ff       \tcallq  40131b <string_length>\n  401347:\t41 89 c4             \tmov    %eax,%r12d\n  40134a:\t48 89 ef             \tmov    %rbp,%rdi\n  40134d:\te8 c9 ff ff ff       \tcallq  40131b <string_length>\n  401352:\tba 01 00 00 00       \tmov    $0x1,%edx\n  401357:\t41 39 c4             \tcmp    %eax,%r12d\n  40135a:\t75 3f                \tjne    40139b <strings_not_equal+0x63>\n  40135c:\t0f b6 03             \tmovzbl (%rbx),%eax\n  40135f:\t84 c0                \ttest   %al,%al\n  401361:\t74 25                \tje     401388 <strings_not_equal+0x50>\n  401363:\t3a 45 00             \tcmp    0x0(%rbp),%al\n  401366:\t74 0a                \tje     401372 <strings_not_equal+0x3a>\n  401368:\teb 25                \tjmp    40138f <strings_not_equal+0x57>\n  40136a:\t3a 45 00             \tcmp    0x0(%rbp),%al\n  40136d:\t0f 1f 00             \tnopl   (%rax)\n  401370:\t75 24                \tjne    401396 <strings_not_equal+0x5e>\n  401372:\t48 83 c3 01          \tadd    $0x1,%rbx\n  401376:\t48 83 c5 01          \tadd    $0x1,%rbp\n  40137a:\t0f b6 03             \tmovzbl (%rbx),%eax\n  40137d:\t84 c0                \ttest   %al,%al\n  40137f:\t75 e9                \tjne    40136a <strings_not_equal+0x32>\n  401381:\tba 00 00 00 00       \tmov    $0x0,%edx\n  401386:\teb 13                \tjmp    40139b <strings_not_equal+0x63>\n  401388:\tba 00 00 00 00       \tmov    $0x0,%edx\n  40138d:\teb 0c                \tjmp    40139b <strings_not_equal+0x63>\n  40138f:\tba 01 00 00 00       \tmov    $0x1,%edx\n  401394:\teb 05                \tjmp    40139b <strings_not_equal+0x63>\n  401396:\tba 01 00 00 00       \tmov    $0x1,%edx\n  40139b:\t89 d0                \tmov    %edx,%eax\n  40139d:\t5b                   \tpop    %rbx\n  40139e:\t5d                   \tpop    %rbp\n  40139f:\t41 5c                \tpop    %r12\n  4013a1:\tc3                   \tretq   \n```\n\n\n\n#### 第一个炸弹\n\n```asm\n0000000000400ee0 <phase_1>:\n  400ee0:\t48 83 ec 08          \tsub    $0x8,%rsp ;申请8字节栈空间\n  ;给寄存器esi(rsi低32位)赋值,应该是一个地址,esi(rsi)是第二个参数寄存器\n  400ee4:\tbe 00 24 40 00       \tmov    $0x402400,%esi ;\n  ;调用匹配字符串函数\n  400ee9:\te8 4a 04 00 00       \tcallq  401338 <strings_not_equal>\n  ;测试匹配函数结束后的eax(返回值rax低32位)寄存器值,若0,栈复原退出,否则调用炸弹爆炸函数\n  400eee:\t85 c0                \ttest   %eax,%eax\n  400ef0:\t74 05                \tje     400ef7 <phase_1+0x17>\n  400ef2:\te8 43 05 00 00       \tcallq  40143a <explode_bomb>\n  400ef7:\t48 83 c4 08          \tadd    $0x8,%rsp\n  400efb:\tc3                   \tretq   \n```\n\n结合phase1的代码\n\n```asm\n ;; 获取输入字符串,rax返回值是字符串地址\n  400e32:\te8 67 06 00 00       \tcallq  40149e <read_line>\n  ;; 获取的输入字符串地址赋给rdi\n  400e37:\t48 89 c7             \tmov    %rax,%rdi\n  400e3a:\te8 a1 00 00 00       \tcallq  400ee0 <phase_1>\n  400e3f:\te8 80 07 00 00       \tcallq  4015c4 <phase_defused>\n  400e44:\tbf a8 23 40 00       \tmov    $0x4023a8,%edi \n  400e49:\te8 c2 fc ff ff       \tcallq  400b10 <puts@plt>\n```\n\n`read_line`函数会将读入字符串地址存放在`rdi `和`rsi`中，`strings_not_equa`l函数会使用`edi`和`esi`中的值当做两个字符址，并且判断他们是否相等，相等返回0\n\n`edi`存放的是`callq  400b10 <puts@plt>`要打印的信息的地址，用gdb调试\n\n```bash\n(gdb) print (char*)(0x4023a8)\n$3 = 0x4023a8 \"Phase 1 defused. How about the next one?\"\n```\n\n可见打印的是成功拆除的信息。因此，炸弹1的整体逻辑就是\n\n```mermaid\ngraph LR\nA[开始] --> B[ 函数readline ]\n     B--> C(rdi=&输入字符串<br>rsi=&密钥字符串) --> D{string_not_equal}\n     D--> |返回0| E[puts success info]\n     D--> |返回非0| F[bomb_explode]\n```\n\n于是，重点在于找到给`rsi`赋地址的语句，这个地址存储的就是密钥字符串\n\n```asm\n0000000000400ee0 <phase_1>:\n  400ee0:\t48 83 ec 08          \tsub    $0x8,%rsp ;申请8字节栈空间\n  ;给寄存器esi(rsi低32位)赋值,应该是一个地址,esi(rsi)是第二个参数寄存器\n  400ee4:\tbe 00 24 40 00       \tmov    $0x402400,%esi ; rsi赋地址语句\n```\n\n`esi`是`rsi`的低32位，400ee4给`esi`赋值就是给`rsi`赋值为密钥字符串地址\n\n`gdb`调试\n\n```bash\n(gdb) print (char*) (0x402400)\n$7 = 0x402400 \"Border relations with Canada have never been better.\"\n```\n\n第一个炸弹的密钥就是**\"Border relations with Canada have never been better.\"**\n\n#### 第二个炸弹\n\n查看`phase_2`代码\n\n```asm\n0000000000400efc <phase_2>:\n  400efc:\t55                   \tpush   %rbp\n  400efd:\t53                   \tpush   %rbx ; rbx rbp压栈，要被调用\n  400efe:\t48 83 ec 28          \tsub    $0x28,%rsp ; 申请0x28=40字节栈帧\n  400f02:\t48 89 e6             \tmov    %rsp,%rsi ; 将rsp值赋给rsi\n  ;根据函数名,应该是读入六个数\n  400f05:\te8 52 05 00 00       \tcallq  40145c <read_six_numbers>\n  \n  400f0a:\t83 3c 24 01          \tcmpl   $0x1,(%rsp); 查栈顶元素是否是1,\n  \t\t\t\t\t\t\t\t\t\t\t\t\t  ; 由下文分析可知phase_2栈顶存储的是第一个输入的值\n  \t\t\t\t\t\t\t\t\t\t\t\t\t  ; 因此密钥第一个数字必定是1\n  400f0e:\t74 20                \tje     400f30 <phase_2+0x34>;是1，跳转到400f30进行首轮哨兵初始化等操作,不是则引爆炸弹\n  400f10:\te8 25 05 00 00       \tcallq  40143a <explode_bomb> ;引爆炸弹\n  400f15:\teb 19                \tjmp    400f30 <phase_2+0x34> \n  \n  ;取出rbx-4处的值赋给eax\n  400f17:\t8b 43 fc             \tmov    -0x4(%rbx),%eax\n  400f1a:\t01 c0                \tadd    %eax,%eax; eax=2*eax\n  ;比较eax*2和rbx处的值,注意:eax是rbx-4处的值，即将rbx和前一个数的两倍比较\n  400f1c:\t39 03                \tcmp    %eax,(%rbx)\n  ; rbx和前一个数的两倍相等则跳转\n  400f1e:\t74 05                \tje     400f25 <phase_2+0x29> \n  ; 不相等引爆炸弹\n  400f20:\te8 15 05 00 00       \tcallq  40143a <explode_bomb>\n  ; rbx=rbx+4\n  400f25:\t48 83 c3 04          \tadd    $0x4,%rbx\n  ; 将rbx和rbp比较\n  ;将加4后的值和rbp比较，\n  ;注意rbp是rsp+24 (400f30代码),而rsp是第一个数，一个数四个字节。那么rbp就应该是\n  ;后那个数后面那个地址，即rbp是个循环哨兵\n  400f29:\t48 39 eb             \tcmp    %rbp,%rbx\n  ; 不相等跳转回rbx-4，继续取rbx前一个数的两倍与其比较\n  400f2c:\t75 e9                \tjne    400f17 <phase_2+0x1b>\n  ; 相等则直接跳转出去\n  400f2e:\teb 0c                \tjmp    400f3c <phase_2+0x40>\n  \n  400f30:\t48 8d 5c 24 04       \tlea    0x4(%rsp),%rbx ;将rsp+4存到rbx\n  400f35:\t48 8d 6c 24 18       \tlea    0x18(%rsp),%rbp ; 将rsp +24 存到rbp\n  ; 无条件跳回去,取rbx前一个数的两倍与其比较\n  400f3a:\teb db                \tjmp    400f17 <phase_2+0x1b> \n  \n  400f3c:\t48 83 c4 28          \tadd    $0x28,%rsp\n  400f40:\t5b                   \tpop    %rbx\n  400f41:\t5d                   \tpop    %rbp\n  400f42:\tc3                   \tretq   \n```\n\n查看`read_six_number`代码\n\n内部调用了`sscanf` 这个函数（功能是从一个字符串中读取一定格式的数据，和 `scanf` 一样，除了 `scanf` 是从标准输入流中读取）。参数顺序分别是，待读取内容的字符串(`rdi`)、用于格式读取的格式化字符串(`rsi`)，还有各个变量读取后存放的地址(`rdx`)。返回读到的有效数据个数\n\n- `%rdx`由 `%rsi` 给出，`%rsi` 又由 `phrase2` 的 `%rsp` 给出，所以 `phrase2` 中的 `%rsp` 地址处存放 `sscanf` 中第1个输入的值。\n\n```asm\n000000000040145c <read_six_numbers>:\n  40145c:\t48 83 ec 18          \tsub    $0x18,%rsp ; 申请0x18=24字节栈帧\n  401460:\t48 89 f2             \tmov    %rsi,%rdx; rdx=rsi\n  401463:\t48 8d 4e 04          \tlea    0x4(%rsi),%rcx; rcx=rsi+4\n  \n  ;                                       \trax=rsi+0x14\n  401467:\t48 8d 46 14          \tlea    0x14(%rsi),%rax\n  40146b:\t48 89 44 24 08       \tmov    %rax,0x8(%rsp);将rax存入rsp+8处\n  ;此时栈\n  ;| ......... |  <- rsi,rdx \n  ;|  返回地址  |\n  ;|           |\n  ;|  rsi+0x14 |\n  ;|           |  <- rsp\n  \n  401470:\t48 8d 46 10          \tlea    0x10(%rsi),%rax; rax=rsi+0x10\n  401474:\t48 89 04 24          \tmov    %rax,(%rsp); 将rax存入rsp处\n  ;此时栈\n  ;| ......... |  <- rsi,rdx \n  ;|  返回地址  |\n  ;|           |\n  ;|  rsi+0x14 |\n  ;|  rsi+0x10 |  <- rsp\n  401478:\t4c 8d 4e 0c          \tlea    0xc(%rsi),%r9\n  40147c:\t4c 8d 46 08          \tlea    0x8(%rsi),%r8\n  \n  \n  ;将rsi赋值为0x4025c3\n  401480:\tbe c3 25 40 00       \tmov    $0x4025c3,%esi\n  401485:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  ;调用了scanf\n  40148a:\te8 61 f7 ff ff       \tcallq  400bf0 <__isoc99_sscanf@plt>\n  \n  \n  40148f:\t83 f8 05             \tcmp    $0x5,%eax\n  ; eax 大于5 跳转到401499准备返回,否则调用爆炸函数,eax存放的应该是读到的数字个数\n  401492:\t7f 05                \tjg     401499 <read_six_numbers+0x3d>\n  401494:\te8 a1 ff ff ff       \tcallq  40143a <explode_bomb>\n  ; 释放栈帧，返回\n  401499:\t48 83 c4 18          \tadd    $0x18,%rsp\n  40149d:\tc3                   \tretq   \n```\n\n- `%rcx`，`phrase2` 中的 `%rsp+0x4` 处存放第2个值\n- `%r8`，`phrase2` 中的 `%rsp+0x8` 存放第3个值\n- `%r9`，`phrase2` 中的 `%rsp+0xc` 存放第4个值\n\n- 第5个、第6个值所在的地址需要通过压栈传参，参数的入栈顺序是从右至左。可知，`phrase2` 中的 `%rsp+0x10` 存放第五个值、`phrase2` 中的 `%rsp+0x14` 存放第六个值。第六个值先入栈，更加靠近栈底（高地址）。\n\n打印0x4025c3处的值\n\n```bash\n(gdb) x /4wd 0x4025c3\n0x4025c3:\t622879781\t1680154724\t543434016\t622879781\n```\n\n乱七八糟，尝试用字符串打印\n\n```asm\n(gdb) print (char*)0x4025c3\n$5 = 0x4025c3 \"%d %d %d %d %d %d\"\n```\n\n这说明`sscanf`读取的确实是6个数字。可以确定，第2个炸弹的密钥是**1 2 4 8 16 32**\n\n#### 第三个炸弹\n\n查看`phase_3`代码\n\n```asm\n0000000000400f43 <phase_3>:\n  400f43:\t48 83 ec 18          \tsub    $0x18,%rsp\n  400f47:\t48 8d 4c 24 0c       \tlea    0xc(%rsp),%rcx ; rcx存储接受输入的第2个数字的地址\n  400f4c:\t48 8d 54 24 08       \tlea    0x8(%rsp),%rdx ; rdx 是sscanf接受输入字符串的地址,为rsp+8\n  \n  400f51:\tbe cf 25 40 00       \tmov    $0x4025cf,%esi ;esi(rsi)为sscanf的第二个参数,输入格式\n  400f56:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400f5b:\te8 90 fc ff ff       \tcallq  400bf0 <__isoc99_sscanf@plt> ; 又调用sscanf获取输入\n  \n```\n\n代码开头就调用了`sscanf`，所以这个函数前面一定会有一个字符串常量存储需要读取的数据格式，函数的第二个参数用`rsi(esi)`存储，`400f51:`处代码告诉了`esi`的字符串首地址是`0x4025cf`，\n\n使用`gdb`调试\n\n```bash\n(gdb) print (char*) 0x4025cf\n$1 = 0x4025cf \"%d %d\"\n```\n\n确定这个炸弹的输入是两个数字\n\n继续查看代码，发现其`cmp,jmp`等跳转指令很多，而且极其的有规律，猜测是个switch语句\n\n```asm\n  400f60:\t83 f8 01             \tcmp    $0x1,%eax ; eax与1比较,应该是返回值sscanf返回读到的2数据个数\n  ; eax大于1 跳转L1,否则触发爆炸,因为密钥是2个数字,小于等于1个有效数据肯定错误\n  400f63:\t7f 05                \tjg     400f6a <phase_3+0x27>\n  400f65:\te8 d0 04 00 00       \tcallq  40143a <explode_bomb>\n  ; L1, 结合上文代码,这是比较ssacnf获取的第一个输入数据和0x7的大小\n  400f6a:\t83 7c 24 08 07       \tcmpl   $0x7,0x8(%rsp)\n  ; 无符号大于7跳转到L2爆炸\n  400f6f:\t77 3c                \tja     400fad <phase_3+0x6a>\n  ; 无符号小于等于7, 将eax赋值为sscanf获取的第一个输入\n  400f71:\t8b 44 24 08          \tmov    0x8(%rsp),%eax\n  ; 间接跳转, 跳转到 (0x402470+%rax*8)内存数据表示的地址,这是switch典型代码,0x402470存储的应该是一个跳转表\n  400f75:\tff 24 c5 70 24 40 00 \tjmpq   *0x402470(,%rax,8)\n  ; 跳转表元素的每个数据应该是下面的一段,进行一次mov操作,修改eax值后统一跳转到400fbe处\n  ; case1\n  400f7c:\tb8 cf 00 00 00       \tmov    $0xcf,%eax\n  400f81:\teb 3b                \tjmp    400fbe <phase_3+0x7b>\n  ; case2\n  400f83:\tb8 c3 02 00 00       \tmov    $0x2c3,%eax\n  400f88:\teb 34                \tjmp    400fbe <phase_3+0x7b>\n  ; case3\n  400f8a:\tb8 00 01 00 00       \tmov    $0x100,%eax\n  400f8f:\teb 2d                \tjmp    400fbe <phase_3+0x7b>\n  ; case4\n  400f91:\tb8 85 01 00 00       \tmov    $0x185,%eax\n  400f96:\teb 26                \tjmp    400fbe <phase_3+0x7b>\n  ; case5\n  400f98:\tb8 ce 00 00 00       \tmov    $0xce,%eax\n  400f9d:\teb 1f                \tjmp    400fbe <phase_3+0x7b>\n  ; case6\n  400f9f:\tb8 aa 02 00 00       \tmov    $0x2aa,%eax\n  400fa4:\teb 18                \tjmp    400fbe <phase_3+0x7b>\n  ; case7\n  400fa6:\tb8 47 01 00 00       \tmov    $0x147,%eax\n  400fab:\teb 11                \tjmp    400fbe <phase_3+0x7b>\n  ; L2 触发爆炸\n  400fad:\te8 88 04 00 00       \tcallq  40143a <explode_bomb>\n  400fb2:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400fb7:\teb 05                \tjmp    400fbe <phase_3+0x7b>\n  ;?\n  400fb9:\tb8 37 01 00 00       \tmov    $0x137,%eax\n  ; case 结束后跳转到的地方\n  ; 显然这里是把ssacnf获取的第二个输入数字与case处理后的eax比较\n  400fbe:\t3b 44 24 0c          \tcmp    0xc(%rsp),%eax\n  ; 若相等,则复原栈帧跳出去\n  400fc2:\t74 05                \tje     400fc9 <phase_3+0x86>\n  ; 不等就爆炸\n  400fc4:\te8 71 04 00 00       \tcallq  40143a <explode_bomb>\n  400fc9:\t48 83 c4 18          \tadd    $0x18,%rsp\n  400fcd:\tc3                   \tretq   \n```\n\n因此本题答案可不唯一，第一个数字应该无符号小于等于7，\n\n`gdb`打印跳转表\n\n```bash\n(gdb) x /8gx 0x402470\n0x402470:\t0x0000000000400f7c [case1]\t\t0x0000000000400fb9 [?]\n0x402480:\t0x0000000000400f83 [case2]     \t0x0000000000400f8a [case3]\n0x402490:\t0x0000000000400f91 [case4]\t\t0x0000000000400f98 [case5]\n0x4024a0:\t0x0000000000400f9f [case6]      0x0000000000400fa6 [case7]\n```\n\n因此 假设第一个数字是0，那么跳转到的是`case1`，`eax=0xcf`，第二个数字得是`0xcf=207`\n\n第一个数字是1，跳转到？,`eax=0x137=311`\n\n#### 第四个炸弹\n\n查看`phase_4`代码，考察的是函数递归调用\n\n```asm\n000000000040100c <phase_4>:\n  40100c:\t48 83 ec 18          \tsub    $0x18,%rsp ; 申请0x18=24直接栈帧\n  ;| phase_4 ret addr |\n  ;|                  |\t <- rcx   (sscanf 输入2nd)\n  ;|                  |  <- rdx   (sscanf 输入1st)\n  ;|                  |  <- rsp\n  401010:\t48 8d 4c 24 0c       \tlea    0xc(%rsp),%rcx\n  401015:\t48 8d 54 24 08       \tlea    0x8(%rsp),%rdx ; sscanf获取的输入存放的地址\n  \n  \n  40101a:\tbe cf 25 40 00       \tmov    $0x4025cf,%esi;esi(rsi)为sscanf的第二个参数,输入格式\n  40101f:\tb8 00 00 00 00       \tmov    $0x0,%eax ; eax(rax)清零 \n  401024:\te8 c7 fb ff ff       \tcallq  400bf0 <__isoc99_sscanf@plt>; 调用sscanf\n  401029:\t83 f8 02             \tcmp    $0x2,%eax; sscanf返回的eax是有效数据个数，判断是否是2\n  ; 不相等跳转到爆炸处,有效输入个数不是2,必然和密钥不匹配,错误\n  40102c:\t75 07                \tjne    401035 <phase_4+0x29>\n  ; 是2个有效输入,比较第一个输入和0xe=14\n  40102e:\t83 7c 24 08 0e       \tcmpl   $0xe,0x8(%rsp)\n  ; 第一个输入无符号小于等于14 跳转避开炸弹,否则到401035处爆炸\n  401033:\t76 05                \tjbe    40103a <phase_4+0x2e>\n  ; 引爆炸弹\n  401035:\te8 00 04 00 00       \tcallq  40143a <explode_bomb>\n  ; 避开炸弹跳转点,将edx置为0xe=14\n  40103a:\tba 0e 00 00 00       \tmov    $0xe,%edx\n  ; esi清零\n  40103f:\tbe 00 00 00 00       \tmov    $0x0,%esi\n  ; edi置为sscanf获取的第一个输入\n  401044:\t8b 7c 24 08          \tmov    0x8(%rsp),%edi\n  ; 调用func4函数\n  ;| phase_4 ret addr |\n  ;|                  |\t <- rcx   (sscanf 输入2nd)\n  ;|                  |  <- rdx   (sscanf 输入1st)\n  ;|                  | \n  ;| func4  ret addr  |  <- rsp\n  ;|                  |\n  401048:\te8 81 ff ff ff       \tcallq  400fce <func4>\n  ; 调用结束后检查 eax\n  40104d:\t85 c0                \ttest   %eax,%eax\n  ;  返回值非零引爆炸弹\n  40104f:\t75 07                \tjne    401058 <phase_4+0x4c>\n  ; 返回值为零 将第二个输入与0做比较\n  401051:\t83 7c 24 0c 00       \tcmpl   $0x0,0xc(%rsp)\n  ; 第二个输入是0 则跳出,否则仍然引爆炸弹\n  401056:\t74 05                \tje     40105d <phase_4+0x51>\n  ; 引爆炸弹\n  401058:\te8 dd 03 00 00       \tcallq  40143a <explode_bomb>\n  40105d:\t48 83 c4 18          \tadd    $0x18,%rsp\n  401061:\tc3                   \tretq  \n```\n\n又调用了`sscanf`函数，`esi`与`phase_3`中地址相同，因此输入格式又是`\"%d %d\"`\n\n\n\n其调用了一个函数`func4`\n\n```asm\n0000000000400fce <func4>:\n  400fce:\t48 83 ec 08          \tsub    $0x8,%rsp ;申请8字节栈帧\n  ;| phase_4 ret addr |\n  ;|      ...         |\t <- rcx (ecx)   (sscanf 输入2nd)\n  ;|      ...         |  <- rdx (edx)  (sscanf 输入1st)\n  ;|                  | \n  ;| func4  ret addr  |  \n  ;|                  |  <- rsp\n  ; 初次调用:edx=14,esi=0, edi = sscanf input 1\n  ; 此前edx被赋值为0xe=14,现eax=14\n  400fd2:\t89 d0                \tmov    %edx,%eax\n  ; eax=eax-esi  更新eax\n  400fd4:\t29 f0                \tsub    %esi,%eax\n  ; ecx=eax\n  400fd6:\t89 c1                \tmov    %eax,%ecx\n  ; 将ecx逻辑右移(加0右移)31位,ecx长为32位,也就是之前的最高位变为最低位,其余31位填充补0\n  400fd8:\tc1 e9 1f             \tshr    $0x1f,%ecx\n  ; eax=eax+(eax最高位)\n  400fdb:\t01 c8                \tadd    %ecx,%eax\n  ; 这里是一个缩写 sar $1,%eax (对应的机器码为 D1F8)  eax = eax/2\n  400fdd:\td1 f8                \tsar    %eax\n  ; ecx= rax+rsi\n  400fdf:\t8d 0c 30             \tlea    (%rax,%rsi,1),%ecx\n  ; ecx和edi比较\n  400fe2:\t39 f9                \tcmp    %edi,%ecx\n  ; ecx小于等于edi则跳至另一个递归方案\n  400fe4:\t7e 0c                \tjle    400ff2 <func4+0x24>\n  ; 否则 edx=rcx-1\n  400fe6:\t8d 51 ff             \tlea    -0x1(%rcx),%edx\n  ; 递归调用func4\n  400fe9:\te8 e0 ff ff ff       \tcallq  400fce <func4>\n  ; eax=2*eax\n  400fee:\t01 c0                \tadd    %eax,%eax\n  ; 本层递归结束,递归出口，回上一层递归\n  400ff0:\teb 15                \tjmp    401007 <func4+0x39>\n  ; 另一个递归方案 , eax清零\n  400ff2:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400ff7:\t39 f9                \tcmp    %edi,%ecx\n  ; 递归出口,回上一层递归\n  400ff9:\t7d 0c                \tjge    401007 <func4+0x39>\n  400ffb:\t8d 71 01             \tlea    0x1(%rcx),%esi\n  400ffe:\te8 cb ff ff ff       \tcallq  400fce <func4>\n  401003:\t8d 44 00 01          \tlea    0x1(%rax,%rax,1),%eax\n  ; 返回\n  401007:\t48 83 c4 08          \tadd    $0x8,%rsp\n  40100b:\tc3                   \tretq  \n```\n\n尝试将func4由汇编翻译回`C`代码，\n\n```c\n#include <stdio.h>\nint func4(int edi, int esi, int edx) {\n    int temp = (edx - esi);\n    int ecx=(temp>>31)&(0x0001);\n    temp+=ecx;\n    temp=temp>>1;\n    int mid = temp + esi;\n    if (mid > edi) {\n        edx = mid - 1;\n        int ret1 = func4(edi, esi, edx);\n        return 2 * ret1;\n    } else {\n        if (mid >= edi) {\n            return 0;\n        } else {\n            esi = mid + 1;\n            int ret2 = func4(edi, esi, edx);\n            return (2 * ret2 + 1);\n        }\n    }\n}\nint main() {\n    for (int edi = 0; edi < 10; edi++) {\n        int res = func4(edi, 0, 14);\n        printf(\"edi=%d, res=%d\\n\", edi, res);\n    }\n    return 0;\n}\n```\n\n```bash\n> gcc -o test .\\bombPhase4.c\n> .\\test.exe\nedi=0, res=0\nedi=1, res=0\nedi=2, res=4\nedi=3, res=0\nedi=4, res=2\nedi=5, res=2\nedi=6, res=6\nedi=7, res=0\nedi=8, res=1\nedi=9, res=1\n```\n\n因此，**7 0、3 0 、1 0**等均可\n\n#### 第五个炸弹\n\n查看`phase_5`代码\n\n```asm\n0000000000401062 <phase_5>:\n  401062:\t53                   \tpush   %rbx ; rbx入栈,本函数要使用rbx\n  401063:\t48 83 ec 20          \tsub    $0x20,%rsp ; 申请0x20=32字节大小的栈帧\n  ;|   phase_5 ret addr   |\n  ;|        %rbx          |\n  ;|                      |\n  ;|                      |\n  ;|                      |\n  ;|                      | <-rsp\n  \n  401067:\t48 89 fb             \tmov    %rdi,%rbx\t; rbx=rdi (rdi=&输入字符串,可由read_line分析得到) \n  ; 反汇编的at&t风格代码\n  40106a:\t64 48 8b 04 25 28 00 \tmov    %fs:0x28,%rax ;把fs选择子的偏移值0x28(64bit)放入rax(64bit暂存器)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n  401071:\t00 00 \n  401073:\t48 89 44 24 18       \tmov    %rax,0x18(%rsp)\n  ;|   phase_5 ret addr   |\n  ;|        %rbx          |\n  ;|        %rax          |\n  ;|                      |\n  ;|                      |\n  ;|                      | <-rsp\n  \n  401078:\t31 c0                \txor    %eax,%eax ; eax清零\n  40107a:\te8 9c 02 00 00       \tcallq  40131b <string_length> ; 猜测是获取字符串长度返回eax\n  40107f:\t83 f8 06             \tcmp    $0x6,%eax ; 判断输入字符串长度是否是6\n  ; 如果长度是6,跳转L2 清零eax(rax低32位,这里可视为rax)\n  401082:\t74 4e                \tje     4010d2 <phase_5+0x70>\n  ; 长度不是6,引爆炸弹\n  401084:\te8 b1 03 00 00       \tcallq  40143a <explode_bomb>\n  401089:\teb 47                \tjmp    4010d2 <phase_5+0x70>\n  ; L1 跳回 循环点   初次从L2跳来, eax为零\n  ; 这里是根据输入的6字节字符串低4位为序号从另一个字符串中取字符存到栈的rsp+0x10为最低地址处\n  40108b:\t0f b6 0c 03          \tmovzbl (%rbx,%rax,1),%ecx ; ecx= rbx(&输入字符串)+rax(当前匹配的字符序号)\n  40108f:\t88 0c 24             \tmov    %cl,(%rsp) ; 在栈顶存储%cl (rcx最低字节)\n  401092:\t48 8b 14 24          \tmov    (%rsp),%rdx \t; rdx=%cl\n  401096:\t83 e2 0f             \tand    $0xf,%edx \t; edx高位清零,只留下最低4位\n  401099:\t0f b6 92 b0 24 40 00 \tmovzbl 0x4024b0(%rdx), %edx ; edx= M[0x4024b0+%rdx]零扩展字节至双字\n  4010a0:\t88 54 04 10          \tmov    %dl,0x10(%rsp,%rax,1); M[rsp+rax+0x10]处存入%dl(%edx低字节)\n  4010a4:\t48 83 c0 01          \tadd    $0x1,%rax\t; rax++ , rax存放的应该是当前匹配的字符序号\n  4010a8:\t48 83 f8 06          \tcmp    $0x6,%rax\t; 比较取完没\n  4010ac:\t75 dd                \tjne    40108b <phase_5+0x29> ; 没有取完全部6个,返回L1循环\n  \n  ; rsp+0x10---rsp+0x15 存储的取出的新6字节字符串 , 将 rsp+0x16清零,即字符串末尾标志'\\0'\n  4010ae:\tc6 44 24 16 00       \tmovb   $0x0,0x16(%rsp)\n  ; esi 存储 要和比较的字符串基址\n  4010b3:\tbe 5e 24 40 00       \tmov    $0x40245e,%esi\n  ; rdi 存储 rsp+0x10,即新字符串的地址\n  4010b8:\t48 8d 7c 24 10       \tlea    0x10(%rsp),%rdi\n  ;进行比较;\n  ;由之前分析strings_not_equal函数使用edi和esi中的值当做两个字符址，并且判断他们是否相等，相等返回0\n  4010bd:\te8 76 02 00 00       \tcallq  401338 <strings_not_equal>\n  ; 判断返回值是否是0\n  4010c2:\t85 c0                \ttest   %eax,%eax\n  ; 为零说明完全匹配成功,跳到L3退出\n  4010c4:\t74 13                \tje     4010d9 <phase_5+0x77>\n  ; 不为零说明无法完全匹配,爆炸\n  4010c6:\te8 6f 03 00 00       \tcallq  40143a <explode_bomb>\n  4010cb:\t0f 1f 44 00 00       \tnopl   0x0(%rax,%rax,1)\n  4010d0:\teb 07                \tjmp    4010d9 <phase_5+0x77>\n  ;L2 eax清零后跳回L1\n  4010d2:\tb8 00 00 00 00       \tmov    $0x0,%eax \n  4010d7:\teb b2                \tjmp    40108b <phase_5+0x29>\n  ;L3:\n  4010d9:\t48 8b 44 24 18       \tmov    0x18(%rsp),%rax\n  4010de:\t64 48 33 04 25 28 00 \txor    %fs:0x28,%rax\n  4010e5:\t00 00 \n  4010e7:\t74 05                \tje     4010ee <phase_5+0x8c>\n  4010e9:\te8 42 fa ff ff       \tcallq  400b30 <__stack_chk_fail@plt>\n  4010ee:\t48 83 c4 20          \tadd    $0x20,%rsp\n  4010f2:\t5b                   \tpop    %rbx\n  4010f3:\tc3                   \tretq   \n```\n\n1. 要求输入6个字符，然后依次循环这个输入的字符数组\n2. 每一轮循环取一个字符，然后取这个字符的后四位作为索引，在第二个字符常量`0x4024b0`处取一个字符依次存放到`%rsp+0x10+i`处\n\n ```bash\n(gdb) print (char*)0x4024b0\n$1 = 0x4024b0 <array> \"maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?\"\n ```\n\n​\t3. 将新`0x10(%rsp)`处的字符串和`0x40245e`处的字符串比较，相同则通过，否则爆炸\n\n```bash\n(gdb) print (char*)0x40245e\n$2 = 0x40245e \"flyers\"\n```\n\n由于低4位只能表示0-15,因此只能从`<array>: maduiersnfotvbyl`取得\n\n`f :array[9] 1001=9`，查找`ASCII`表低位为9的字符:`)9IYiy`\n\n`l :array[15] 1111`=F, `/?O_0`\n`y :array[14] 1110=E ` , `.>N^n~`\n\n`e :array[5] 5`,`%5EUeu`\n\n`r :array[6] 6`, `&6FVfv`\n\n`s :array[7] 7`, `,7GWgw`\n\n答案多种，如**`YONEFw` 、`y?nevw`**\n\n`string_length`代码\n\n```asm\n000000000040131b <string_length>:\n  40131b:\t80 3f 00             \tcmpb   $0x0,(%rdi)\n  40131e:\t74 12                \tje     401332 <string_length+0x17>\n  401320:\t48 89 fa             \tmov    %rdi,%rdx\n  401323:\t48 83 c2 01          \tadd    $0x1,%rdx\n  401327:\t89 d0                \tmov    %edx,%eax\n  401329:\t29 f8                \tsub    %edi,%eax\n  40132b:\t80 3a 00             \tcmpb   $0x0,(%rdx)\n  40132e:\t75 f3                \tjne    401323 <string_length+0x8>\n  401330:\tf3 c3                \trepz retq \n  401332:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401337:\tc3                   \tretq   \n```\n\n结合`read_line`，应该是获取`rdi`为地址的字符串的长度返回给`eax(rax)`\n\n#### 第六个炸弹\n\n查看`phase_6`代码\n\n```asm\n00000000004010f4 <phase_6>:\n  4010f4:\t41 56                \tpush   %r14\n  4010f6:\t41 55                \tpush   %r13\n  4010f8:\t41 54                \tpush   %r12\n  4010fa:\t55                   \tpush   %rbp\n  4010fb:\t53                   \tpush   %rbx ; 寄存器入栈,将要被本函数调用\n  \n  4010fc:\t48 83 ec 50          \tsub    $0x50,%rsp; 申请80字节的栈帧\n  ;|  phase_6 ret addr  |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    | <- rsp <- r13 <- rsi\n  401100:\t49 89 e5             \tmov    %rsp,%r13\n  401103:\t48 89 e6             \tmov    %rsp,%rsi\n  \n  ;调用读取6数字函数,内部调用了sscanf\n  ;sscanf参数顺序分别是，\n  ;待读取内容的字符串(rdi)、\n  ;用于格式读取的格式化字符串(rsi)，\n  ;还有各个变量读取后存放的地址(rdx)。\n  ; <read_six_numbers>中,%rdx由 %rsi 给出，%rsi 在 phrase6中 又由 %rsp 给出\n  ; 因此输入的数字存到phase_6的%rsp处\n  ;返回读到的有效数据个数\n  401106:\te8 51 03 00 00       \tcallq  40145c <read_six_numbers>\n  ;读入了 6 个数字，分别放入了 %rsp+0x0、%rsp+0x4、%rsp+0x8、%rsp+0xc、%rsp+0x10、%rsp+0x14\n  40110b:\t49 89 e6             \tmov    %rsp,%r14 \n  ; 先将r12(d低32位)置零\n  ; r12 用于计数L4循环\n  40110e:\t41 bc 00 00 00 00    \tmov    $0x0,%r12d\n  ;====================================================================\n  ;L4\n  401114:\t4c 89 ed             \tmov    %r13,%rbp\n  ; 初始情况\n  ;|  phase_6 ret addr  |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|  num6     num5     |\n  ;|  num4     num3     |\n  ;|  num2     num1     | <- rsp r13 r14 rbp rsi\n  \n  ; eax赋值为r13指向的内存数据\n  401117:\t41 8b 45 00          \tmov    0x0(%r13),%eax\n  ; eax=eax-1\n  40111b:\t83 e8 01             \tsub    $0x1,%eax\n  ; 将eax与 5比较\n  40111e:\t83 f8 05             \tcmp    $0x5,%eax\n  ; eax无符号<=5,跳过起爆函数至L1,否则爆炸,即原数据<=6\n  401121:\t76 05                \tjbe    401128 <phase_6+0x34>\n  401123:\te8 12 03 00 00       \tcallq  40143a <explode_bomb>\n  ;L1: %r12d(r12低32位)++\n  401128:\t41 83 c4 01          \tadd    $0x1,%r12d\n  ; 将r12d与6做比较\n  40112c:\t41 83 fc 06          \tcmp    $0x6,%r12d\n  ; r12=6则跳转至L2\n  401130:\t74 21                \tje     401153 <phase_6+0x5f>\n  ; 否则 ebx=r12d \n  401132:\t44 89 e3             \tmov    %r12d,%ebx\n  ;L3: rax= ebx符号扩展4字 假设r12d=i\n  401135:\t48 63 c3             \tmovslq %ebx,%rax\n  ; rax= M[rsp+4*rax]  假设r12d=i , 则rax=num(i)\n  401138:\t8b 04 84             \tmov    (%rsp,%rax,4),%eax\n  ; eax(rax)= num(i+1)与 M[rbp]=M[r13]=num(i)进行比较\n  40113b:\t39 45 00             \tcmp    %eax,0x0(%rbp)\n  ;不相等跳过爆炸函数\n  40113e:\t75 05                \tjne    401145 <phase_6+0x51>\n  ; 相等起爆\n  401140:\te8 f5 02 00 00       \tcallq  40143a <explode_bomb>\n  ; 跳过起爆函数 ebx++\n  401145:\t83 c3 01             \tadd    $0x1,%ebx\n  ; 比较ebx和5\n  401148:\t83 fb 05             \tcmp    $0x5,%ebx\n  ; ebx<=5 跳转回L3,下一个num\n  40114b:\t7e e8                \tjle    401135 <phase_6+0x41>\n  ; ebx>=6, r13+=4\n  40114d:\t49 83 c5 04          \tadd    $0x4,%r13\n  ; 跳回L4,将 r13 rbp等寄存器调整为指向栈中下一个num\n  401151:\teb c1                \tjmp    401114 <phase_6+0x20>\n  ;==================================================================\n  ;上述代码的作用是,确保输入的6个数字均<=6，并且num(i)不和num(i+1)~num(6)相同 \n  ; 1<=i<=5\n  ;==================================================================\n  \n  \n  ;L2: r12=6跳转点;跳出上面的检查循环\n  401153:\t48 8d 74 24 18       \tlea    0x18(%rsp),%rsi\n  401158:\t4c 89 f0             \tmov    %r14,%rax\n  ;|  phase_6 ret addr  |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    | <- rsi\n  ;|  num6     num5     |\n  ;|  num4     num3     |\n  ;|  num2     num1     | <- rsp r14 rax\n  \n  40115b:\tb9 07 00 00 00       \tmov    $0x7,%ecx\n  ;L5: 循环,  num[i]=7-num[i] 6个输入数字全部对7求补\n  401160:\t89 ca                \tmov    %ecx,%edx\n  ; rcx=7, rdx=7\n  401162:\t2b 10                \tsub    (%rax),%edx; edx=7-num(rax point)\n  ; num(rax point)= edx=7-num(rax point) \n  401164:\t89 10                \tmov    %edx,(%rax)\n  ; rax+=4指向下一个num\n  401166:\t48 83 c0 04          \tadd    $0x4,%rax\n  ; 判断 rax指完所有num没有\n  40116a:\t48 39 f0             \tcmp    %rsi,%rax\n  ; 没指完，跳转L5继续指\n  40116d:\t75 f1                \tjne    401160 <phase_6+0x6c>\n  \n  ;================================================================\n  ; esi清零\n  40116f:\tbe 00 00 00 00       \tmov    $0x0,%esi\n  ; 无条件跳转至L6\n  401174:\teb 21                \tjmp    401197 <phase_6+0xa3>\n  ; L7: L6处理完后跳回点\n  401176:\t48 8b 52 08          \tmov    0x8(%rdx),%rdx ; rdx= M[rdx+8]; 而edx赋了个地址,数据大小是8字节\n  40117a:\t83 c0 01             \tadd    $0x1,%eax ; eax+=1\n  40117d:\t39 c8                \tcmp    %ecx,%eax ; 将eax和ecx比较\n  ; eax ecx不相等跳回L7\n  40117f:\t75 f5                \tjne    401176 <phase_6+0x82>\n  ; eax ecx相等跳到L9\n  401181:\teb 05                \tjmp    401188 <phase_6+0x94>\n  ;L8 : L6中ecx<=1跳回点\n  401183:\tba d0 32 60 00       \tmov    $0x6032d0,%edx; 同样也把edx赋地址值0x6032d0\n  ;L9 把rdx存储的数据(即从0x6032d0+OFFSET)处获取的数据存入栈中 M[rsp+0x20++2*rsi]\n  401188:\t48 89 54 74 20       \tmov    %rdx,0x20(%rsp,%rsi,2)\n  40118d:\t48 83 c6 04          \tadd    $0x4,%rsi; rsi+=4\n  401191:\t48 83 fe 18          \tcmp    $0x18,%rsi; 判断rsi是否等于0x18=24,即循环6次了\n  ; 循环6次,栈rsp+0x20+OFFSET存入6个8字节数据了,跳到L10\n  401195:\t74 14                \tje     4011ab <phase_6+0xb7>\n  ;L6\n  ; ecx= M[rsp+rsi] ; 注意40116f把esi清零 ecx=M[rsp+rsi]=num(1...6)\n  401197:\t8b 0c 34             \tmov    (%rsp,%rsi,1),%ecx\n  ; 将ecx(num1)与1比较\n  40119a:\t83 f9 01             \tcmp    $0x1,%ecx\n  ; ecx(num1)有符号<= 1跳回L8\n  40119d:\t7e e4                \tjle    401183 <phase_6+0x8f>\n  ; eax=1\n  40119f:\tb8 01 00 00 00       \tmov    $0x1,%eax\n  ; edx=0x6032d0,是一个地址\n  4011a4:\tba d0 32 60 00       \tmov    $0x6032d0,%edx\n  ; 跳回L7\n  4011a9:\teb cb                \tjmp    401176 <phase_6+0x82>\n  ;================================================================\n  ;作用是访问一个链表，链表的首地址为 0x6032d0，针对输入的第 i 个数，\n  ;按照 num[i] 的值获取链表第 num[i] 个节点，\n  ;并把节点首地址放入 %rsp+0x20+0x0~%rsp+0x20+0x28 刚好是 6 个节点。\n  ;================================================================\n  \n  ;L10:  \n  4011ab:\t48 8b 5c 24 20       \tmov    0x20(%rsp),%rbx\n  4011b0:\t48 8d 44 24 28       \tlea    0x28(%rsp),%rax\n  4011b5:\t48 8d 74 24 50       \tlea    0x50(%rsp),%rsi\n  4011ba:\t48 89 d9             \tmov    %rbx,%rcx\n  4011bd:\t48 8b 10             \tmov    (%rax),%rdx\n  4011c0:\t48 89 51 08          \tmov    %rdx,0x8(%rcx)\n  4011c4:\t48 83 c0 08          \tadd    $0x8,%rax\n  4011c8:\t48 39 f0             \tcmp    %rsi,%rax\n  4011cb:\t74 05                \tje     4011d2 <phase_6+0xde>\n  4011cd:\t48 89 d1             \tmov    %rdx,%rcx\n  4011d0:\teb eb                \tjmp    4011bd <phase_6+0xc9>\n  4011d2:\t48 c7 42 08 00 00 00 \tmovq   $0x0,0x8(%rdx)\n  4011d9:\t00 \n  4011da:\tbd 05 00 00 00       \tmov    $0x5,%ebp\n  \n  ;%rsp+0x20+0x0~ %rsp+0x20+0x28 存储的链表节点地址指向的数值必须是递减的。低地址存的数据要更大\n  ; rax= M[rbx+8]\n  4011df:\t48 8b 43 08          \tmov    0x8(%rbx),%rax\n  ; eax= M[rax]\n  4011e3:\t8b 00                \tmov    (%rax),%eax\n  ; 比较M[rax]=M[rbx+8]和M[rbx], 32位数据\n  4011e5:\t39 03                \tcmp    %eax,(%rbx)\n  ;若不爆炸需要M[rbx]>=M[rbx+8]\n  4011e7:\t7d 05                \tjge    4011ee <phase_6+0xfa>\n  4011e9:\te8 4c 02 00 00       \tcallq  40143a <explode_bomb>\n  4011ee:\t48 8b 5b 08          \tmov    0x8(%rbx),%rbx\n  4011f2:\t83 ed 01             \tsub    $0x1,%ebp\n  4011f5:\t75 e8                \tjne    4011df <phase_6+0xeb>\n  4011f7:\t48 83 c4 50          \tadd    $0x50,%rsp\n  \n  \n  4011fb:\t5b                   \tpop    %rbx\n  4011fc:\t5d                   \tpop    %rbp\n  4011fd:\t41 5c                \tpop    %r12\n  4011ff:\t41 5d                \tpop    %r13\n  401201:\t41 5e                \tpop    %r14\n  401203:\tc3                   \tretq   \n```\n\n用`gdb`查看`0x6032d0`开始的数据,根据`401176`以8字节为单位查看\n\n```bash\n(gdb) x /6gx 0x6032d0\n0x6032d0 <node1>:\t0x00000001 0000014c\t  0x00000000 006032e0\n0x6032e0 <node2>:\t0x00000002 000000a8\t  0x00000000 006032f0\n0x6032f0 <node3>:\t0x00000003 0000039c\t  0x00000000 00603300\n```\n\n访问一个链表，链表的首地址为 `0x6032d0`，针对输入的第 `i` 个数，按照 `a[i]` 的值获取链表第 `a[i]` 个节点，并把节点首地址放入 `%rsp+0x20+0x0`~ 到 `%rsp+0x20+0x28` 刚好是 6 个节点。\n\n| 地址     | 数据       |\n| -------- | ---------- |\n| 0x6032d0 | 0x0000014c |\n| 0x6032d4 | 0x00000001 |\n| 0x6032d8 | 0x006032e0 |\n| 0x6032dc | 0x00000000 |\n| 0x6032e0 | 0x000000a8 |\n| 0x6032e4 | 0x00000002 |\n| 0x6032e8 | 0x006032f0 |\n| 0x6032ec | 0x00000000 |\n| 0x6032f0 | 0x0000039c |\n\n```bash\n(gdb) x /wx 0x6032d0\n0x6032d0 <node1>:\t0x0000014c # 链表结点1 data的低32位,由于输入的数据是int 32位，可以先不看高32位data 5\n(gdb) x /wx 0x6032d0+8\n0x6032d8 <node1+8>:\t0x006032e0 # 结点1存储的结点2的地址\n\n(gdb) x /wx 0x6032e0\n0x6032e0 <node2>:\t0x000000a8 # data 6\n(gdb) x /wx 0x6032e0+8\n0x6032e8 <node2+8>:\t0x006032f0 # addr\n\n(gdb) x /wx 0x6032f0\n0x6032f0 <node3>:\t0x0000039c # data 1\n(gdb) x /wx 0x6032f0+8\n0x6032f8 <node3+8>:\t0x00603300 # addr\n\n(gdb) x /wx 0x603300\n0x603300 <node4>:\t0x000002b3 #data 2\n(gdb) x /wx 0x603300+8\n0x603308 <node4+8>:\t0x00603310 # addr\n\n(gdb) x /wx 0x603310\n0x603310 <node5>:\t0x000001dd #data 3\n(gdb) x /wx 0x603310+8\n0x603318 <node5+8>:\t0x00603320 # addr\n\n(gdb) x /wx 0x603320\n0x603320 <node6>:\t0x000001bb #data 4\n(gdb) x /wx 0x603320+8\n0x603328 <node6+8>:\t0x00000000\n```\n\n一共6个结点，第一个结点地址数据存在`%rsp+0x20+0x0`处，这个地址数据指向的结点data应该最大，由于比较`cmp`的是32位数据，只需要注意地址指向数据的低32位。\n\n最大的数据是`0x0000039c`，是第3个结点， 此时的num1=3，\n\n第2大的数据是`0x000002b3` ，第4个结点 num2=4\n\n第3大的数据是`0x000001dd` ，第5个结点 num3=5\n\n第4大的数据是`0x000001bb` ，第6个结点 num4=6\n\n第5大的数据是`0x0000014c` ，第1个结点 num5=1\n\n第6大的数据是`0x000000a8` ，第2个结点 num3=2\n\n`num=[3,4,5,6,1,2]`\n\n但是注意这是把输入的`num`进行了`num=7-num`\n\n所以输入是\n\n`num=[4,3,2,1,6,5]`\n\n最终答案是**4 3 2 1 6 5 **","tags":["计算机组成原理"]}]