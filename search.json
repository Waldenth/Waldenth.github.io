[{"title":"海康威视SDK开发","url":"/2022/11/05/HikVisionSDK/","content":"\n## demo测试运行\n\ndemo和动态连接库分为Linux和Windows版本,其中Windows使用Visual Studio构建工程,\nLinux下使用Ubuntu,但是要注意参考makefile编写\n\n<!-- more -->\n\n### 平台：Windows 64\n\nVisual Studio 2019\n\n#### demo运行\n....\n....\n#### 接口测试\n....\n....\n### 平台：Linux 64\n\nUbuntu + g++ + makefile\n\n#### demo运行\n....\n....\n#### 接口测试\n....\n....\n\n\n\n### RTSP链接格式\n\nHikvision \tRTSP 直播流：rtsp://admin:abcd1234@192.168.31.167:554/h264/ch1/sub/av_stream\n\t\t     \t\t\t\t\t\t\t\t  rtsp://admin:abcd1234@192.168.31.167:554/Streaming/Channels/101?transportmode=unicast\n  \t\t\t\t\tRTSP 回放流：rtsp://admin:abcd1234@192.168.31.167:554/streaming/tracks/101?starttime=20210509t122832z&endtime=20210509t125205z","tags":["C++"]},{"title":"CMU15-721-Lecture02笔记","url":"/2022/11/05/CMU15-721-Lec02-In-Memory-Databases/","content":"## Lec-02 In-memory Databases \n\n[video](https://www.bilibili.com/video/BV1Y7411o7GN?p=2)\n\n## Disk-oriented DBMS(面向磁盘的数据库)\n\n- 数据主要是在**非易失性存储器**中(HDD,SSD),以页或者帧(Page or Frame)为单位做存储\n\n- 使用在内存中的**缓存池(Buffer Pool)**来将磁盘数据导入内存并在内存中处理，缓存来自磁盘的page\n\n- **槽(slot)** , 数据库的数据存储结构是通过表空间（table space）->段(segment)->区（或者簇extends)->页（page)进行管理, 其中页是最小管理单元，而数据库表的记录在页内保持有序的方法就是**槽(slot)管理**，以MySQL为例分析：\n\n  - Innodb是多条记录对应一个槽，而槽的作用就是用来在页面内进行数据搜索的，因为查找一条数据时，是用B+tree来保证通过树形结构找到一个记录所在的页，而在页内部真正找到这条记录是通过槽来完成的\n\n  - 在页内部，Innodb划分出一个区域比如10byte，作为槽的区域（当然槽的区域根据使用的大小是可以变化的），一个槽占用2byte。那么现在可以将这个槽看作是长度大小为5的数组。\n\n  - 当我们将一条数据记录写入数据库时，通过数据库的Innodb最终决定写入在这个页内。那么写在这个页的哪里呢？形象的理解就是这个页，就相当于一张A4纸；数据记录就是一条信息，我们写的时候就是从上到下，从左至右的方法去写。Innodb的写入方式基本上也是这样的写入方式，但是这其中有很多问题需要数据库去解决。其中就是写入后数据记录的顺序问题。\n\n  - 模拟数据的写入过程：\n    1.写入第1条记录1，该记录在页内偏移量为120，长度为100，则slot[0]=120;\n    2.写入第2条记录10，该记录在页内偏移量为220，长度为100，则slot[1]=220;\n    3.写入第3条记录5，该记录在页内偏移量为320，长度为100，此时需要移动slot的内容，则slot[1]=320;slot[2]=220;\n\n  - 这样通过 slot的有序性，就保证了写入页内的数据记录的有序性。上面说过，Innodb的槽是多条记录对应一个slot。对于innodb它页内记录通过双向链表相互联接。\n\n    - slot[0]=120对应记录1的偏移量，而记录1有指向记录2的指针，记录2有指向记录3的指针；\n    - slot[1]=420对应记录4的偏移量（这里假设每条记录长度为100），记录4有指向记录5的指针，记录5的指向记录6的指针\n    - 后面的槽依次类推。slot[2]管理7，8，9三条记录；slot[3]管理10，11，12三条记录；slot[4]管理13，14，15三条记录；\n\n<!-- more -->\n    \n\n### Buffer Pool Issue（缓冲池）\n\n由于引入了缓冲池，磁盘型DB完整过程如下：\n\n- 完整查询过程：\n\n  1.从数据库索引中查找对应记录的**Page ID**和**slot(数据库页的槽)**，如果索引的节点没有加载到内存中，需要从磁盘中加载\n\n  2.去页表中查询该Page是否已经加载到内存\n\n  3.如果没有的话，从磁盘中找到该页，并且复制到缓存池的一帧中(frame)\n\n  4.如果缓存池没有空的frame，则按一定替换原则evict某页(LRU,FIFO,CLOCK)，并且还要更新page table\n\n  5.如果page是dirty的即被修改过，就需要把对应修改后的内容写回磁盘中\n\n  ![image-20211005210919847](https://gitee.com/waldenth/blogimage/raw/master/img/image-20211005210919847.png)\n\n- 这种架构的坏处：\n\n  Every tuple access has to go through the buffer pool manager regardless of whether that data will always be in memory.\n\n  无论查询元组是否在内存中都需要去buffer pool中查找\n\n  \n\n### Concurrency Control Issue（并发控制）\n\n面向磁盘的数据库假定**在尝试访问没有加载到内存的数据的时候，事务会“stall(抛锚，熄火)”**\n\n当然系统为了提高性能会允许一个事务stall的时候同时执行其他事务，靠上锁来实现ACID。(原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）)\n\n锁存储在in-memory的一个hash-table，叫lock manager,避免锁数据被swap到磁盘上，**All the info about lock is in memory!**，所有关于锁的信息全部在内存中！\n\n\n\n### Logging & Recovery Issue （日志与恢复）\n\n- 事务提交前，把修改写入**Write-Ahead-Log(WAL)**，WAL包含undo log 和 redo log\n- 每一个log entry（日志项）包含事务修改前后数据的镜像\n- The DBMS flushes WAL pages to disk separately from corresponding modified database pages, so it takes extra work to keep track of what log record is responsible for what page，DBMS将WAL页面从相应的修改过的数据库页面分别刷新到磁盘，因此需要额外的工作来跟踪日志记录负责哪个页面\n- 在事务提交之前，必须将所有修改刷新到WAL。\n- 需要维护log record是负责哪一个page的信息（利用LSN Log Sequence Number）\n\n### 开销比较\n\n如果不考虑disk flushing,面向磁盘数据库开销主要花费在：\n\nBUFFER POOL 34%\n\nLATCHING 14% (隔离的是线程,保证并发线程操作临界资源的正确性)\n\nLOCKING 16% (隔离的是事务，一般锁住的是数据库的表，行)\n\nLOGGING 12% \n\nB-TREE KEYS 16% 索引查找时间\n\nCPU 7% \n\n## In-memory DBMS(面向内存的数据库)\n\n背景：DRAM的发展，价格和容量足以把整个数据库的数据都存储到内存中\n\n这时候磁盘IO不再是数据库性能的瓶颈,而需要考虑以下可以优化的性能瓶颈\n\n- Locking/Latching：\n\n  - lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。此外，lock，正如在大多数数据库中一样，是有死锁机制的。\n  - latch一般称为闩锁（轻量级锁），因为其要求锁定的时间必须非常短。\n\n  ![20201207103106902](https://gitee.com/waldenth/blogimage/raw/master/img/20201207103106902.png)\n\n- Cache-line misses，cache命中\n\n- Pointer chasing，指针追踪\n\n- Predicate evaluation，谓词运算\n\n- Data movement and copying，数据移动和复制\n\n- Networking ，网络通信\n\n因为所有数据都在内存中，因此不会存在脏页，也不需要维护undo log信息，也不需要LSN机制\n\n\n\n### 与面向磁盘数据库的一些不同\n\n- Data Organization\n\n  1.从索引Index中查找数据指针所在的Block ID与Offset\n\n  2.根据Block ID与Offset找到数据指针的内存地址,指针存储在Fixed-Length Data Blocks(固定长度数据块)中\n\n  3.根据这个64-bits指针去Variable-Length Data Blocks(可变长度数据块)去寻找真正的数据\n\n![微信截图_20200426204351](https://gitee.com/waldenth/blogimage/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200426204351.png)\n\n\n- Indexes\n\n  In-memory DBMS并不会记录索引的更新。数据库再重启时，当所有数据加载到内存之后直接在内存中重建这个索引。\n\n- Query Processing\n\n  由于数据都在内存中，随机访问的速度并不比顺序访问要差\n\n- Logging & Revocery\n\n  1.仍然需要维护WAL，即修改数据库之前,把修改记录写入WAL然后同步到内存中\n\n  2.使用组提交来提交WAL，分摊fsync系统调用的开销\n\n  3.也可以使用更轻量级的logging策略，只存储redo信息\n\n- Concurrency control——提供原子性与隔离性\n\n  在面向磁盘的数据库中，锁是存放在另外一个内存中的hash表，与数据记录本身是分开来存储的。因为记录是可能被swap到外存。\n\n  而在IMDB中，由于数据记录一直在内存中，不会swap到外存，因此可以把记录有关的锁的信息与记录一起保存。\n\n  所以尝试取锁的效率=尝试获得数据的效率\n\n  瓶颈在于：多个事务同时尝试访问某个数据，只有一个事务能抢到锁\n\n  如果用mutex实现的话性能太慢，建议用CAS来保证这里的同步\n\n### CAS\n\n```c++\n__sync_bool_compare_and_swap(&M, 20, 30);\n```\n\n当且仅当M地址代表的值等于20的时候，把M地址所在的值设为30。否则失败，因为不等于的话说明这个值肯定被别的线程修改了\n\n### 并发控制\n\n接下来的会详细讨论并发控制的一些策略：\n\n#### 悲观策略——2 PHASE LOCKING 两段锁协议\n\n操作数据之前一定先抢锁\n\n2PL解决死锁两种策略：\n\n- 1.死锁探测\n\n  维护一个队列，队列存放着拿着锁的事务，一个后台线程周期性扫这个队列的事务，看哪些事务在运行，哪些stall，这就可以找到发生死锁的事务。\n\n- 2.死锁预防\n\n  在分配锁之前看有没有其他事务已经拿到这把锁，如果这个事务拿不了锁：\n\n  1）等待\n\n  2）自杀\n\n  3）杀死另外一个拿锁的事务\n\n#### 乐观策略——Timestamp Ordering 时间戳排序\n\n操作数据不抢锁，事务提交的时候比较时间戳，以时间为序，按每个transaction的时间来排谁先执行\n\n参考资料：[CMU Database Systems - Timestamp Ordering Concurrency Control - fxjwind - 博客园 (cnblogs.com)](https://www.cnblogs.com/fxjwind/p/11114136.html)\n\n##### Basic T/O Protocol\n\n首先每个txn(事务，Transaction)需要有一个独一无二的timestamp，这个在单机很容易实现；其次，Timestamp必须是单调递增的，最后，不同的schema会选择在不同的时间给txn打上timestamp，可能是txn刚到的时候，也可能是txn执行完的时候。\n\n**txn是transaction的简写，ts为timestamp**\n\n每一个事务txn都会分配一个时间戳，每一个记录的头部维护上一次事务操作的时间戳。然后事务对时间戳进行操作的时候，比较现在事务的时间戳与记录头部当前的时间戳。\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/312753-20190626115738779-1763049586.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n以课程案列，首先，给每个object加上读时间戳和写时间戳，表示最后一次读写该对象的时间，如图，对象A,B分别加上读写时间戳，均为10000，然后对图中事务txn的每个读写操作进行时间戳比对\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/image-20211005214323198.png\" alt=\"image-20211005214323198\" style=\"zoom: 33%;\" />\n\n\n\n- 读Object操作：拿**当前事务ts**和**Object的写ts**比较，如果Object的写ts比较新，那么读需要abort，因为，你不能读一个未来的值\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/image-20211005214627964.png\" alt=\"image-20211005214627964\" style=\"zoom:50%;\" />\n\n可以看到，案例txn中READ(A)首先将本事务ts=10001对象A的写ts=10000比较，本txn的ts更新，因此READ(A)操作合法，并将对象A的读时间戳更新为$max(R-ts(A),ts(txn))$,这里将A读ts改为10001\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/312753-20190626120512358-23562664.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/image-20211005215134735.png\" alt=\"image-20211005215134735\" style=\"zoom: 50%;\" />\n\n写Object操作：要同时将本txn的ts和该对象的读、写ts进行比较，比较对象写是因为你不能用过去的值覆盖未来的值，比较对象读是因为如果有未来的txn读过这个值，你就不能再更新。**即事务txn的时间戳要大于对象的读和写时间戳才可以进行操作**，操作后，需要更新对象的写时间戳\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/image-20211005215251726.png\" alt=\"image-20211005215251726\" style=\"zoom:50%;\" />\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/312753-20190626120535298-1569553780.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n课程案例中，假设本txn在省略号部分处理其他事情，无读写操作，此时另一个时间戳为10005的txn进行了对对象A的写操作，A的写ts修改为10005，当本txn其他事情完成，继续后续另一个的WRITE(A)操作时：\n\n<img src=\"https://gitee.com/waldenth/blogimage/raw/master/img/image-20211005215739487.png\" alt=\"image-20211005215739487\" style=\"zoom:50%;\" />\n\n进行ts比较，此时txn ts=10001< Object A write ts=10005，操作不合法，事务无法提交，处理失败，回滚\n\n##### 乐观并发控制\n\n```\n1. Read Phase: Transaction’s copy tuples accessed to private work space to ensure repeatable reads, and\nkeep track of read/write sets.\n\n2. Validation Phase: When the transaction invokes COMMIT, the DBMS checks if it conflicts with other\ntransactions. Parallel validation means that each transaction must check the read/write set of other\ntransactions that are trying to validate at the same time. Each transaction has to acquire locks for its\nwrite set records in some global order. Original OCC uses serial validation.\nThe DBMS can proceed with the validation in two directions:\n? Backward Validation: Check whether the committing transaction intersects its read/write sets\nwith those of any transactions that have already committed.\n? Forward Validation: Check whether the committing transaction intersects its read/write sets with\nany active transactions that have not yet committed.\n\n3. Write Phase: The DBMS propagates the changes in the transactions write set to the database and\nmakes them visible to other transactions’ items. As each record is updated, the transaction releases\nthe lock acquired during the Validation Phase\n```\n\n具体可以参考slides的过程\n\n##### 时间戳的分配策略\n\n- 基于互斥量：并发性能低\n- 原子加操作:   CAS操作去维护一个全局计数器\n- 批量原子加操作\n- 硬件CLOCK:  Intel CPU only\n- 硬件计数器: 尚未有硬件实现\n\n#### 并发控制的性能瓶颈\n\n- Lock Thrashing 锁抖动\n\n  Each transaction waits longer to acquire locks, causing other transaction to wait longer to acquire\n  locks.\n\n  Can measure this phenomenon by removing deadlock detection/prevention overhead. \n\n  solution： force txns to acquire locks in primary key order\n\n- Memory Allocation 内存分配\n\n  Copying data on every read/write access slows down the DBMS because of contention on the memory\n  controller.\n\n  Default libc malloc is slow. Never use it \n\n- Timestamp Allocation 时间戳分配\n\n","tags":["database"]},{"title":"微机原理-第三章-内存储器习题","url":"/2022/11/05/80X86-chapter3-Memory/","content":"\n### 3.8\n\n#### 3.8.1\n\n$512\\times 1b$的RAM芯片表示其有512个数据地址，每个数据1bit，要组成$16K\\times 8b$的存储矩阵，需要\n$$\n\\frac{16K}{512}\\times\\frac{8b}{1b}=32\\times8=256\n$$\n个RAM芯片，为保证实现每个数据8bit，需要分组，一组由8个$512\\times 1b$RAM芯片组成，为保证有$16K$个数据地址，每组只有512个地址，因此需要32组。\n\nRAM芯片数：256\n\n片内地址位数：$log_2{512}=9$\n\n片选地址位数(芯片选择端)：$log_2{\\frac{16K}{512}}=5$\n\n<!-- more -->\n\n#### 3.8.2\n\nRAM芯片数：$\\frac{16K}{1024}\\times\\frac{1b}{8b}=16\\times8=128$\n\n片内地址位数：$log_2{1024}=10$\n\n片选地址位数(芯片选择端)：$log_2{16}=4$\n\n#### 3.8.3\n\nRAM芯片数：$\\frac{16K}{2K}\\times\\frac{8b}{4b}=8\\times2=16$\n\n片内地址位数：$log_2{2K}=11$\n\n片选地址位数(芯片选择端)：3\n\n#### 3.8.4\n\nRAM芯片数：$\\frac{16K}{8K}\\times\\frac{8b}{8b}=2$\n\n片内地址位数：$log_2{8K}=13$\n\n片选地址位数(芯片选择端)：1\n\n### 3.14\n\nRAM芯片数：$\\frac{16K}{4k}\\times\\frac{8b}{1b}=4\\times8=32$\n\n片内寻址位数：$log_2{4K}=12$，因此低12位$A_0 - A_{11}$作为片内寻址\n\n片选地址位数：$14-12=2$，$A_{12},A_{13}$作为片选信号\n\n### 3.17\n\n采用字结构方式组织\n\n 2764为$8K\\times 8$结构，13根地址线，8根数据线\n\n* 字结构方式：一个字节的8位制作在一块芯片上，选中芯片可一次性读/写8位信息，封装时引线较多。例如：1K的存储器芯片由128×8组成，访问它要7根地址线和8根数据线。\n* 位结构方式：1个芯片内的基本单元作不同字的同一位，8位由8块芯片组成。优点是芯片封装时引线少，例如： 1 K存储器芯片由1024×1组成，访问它要10根地址线和1根数据线。\n\n由题干，地址区域为`00000H`至`0000 0111 1111 1111 1111H`，因此$A_{19}-A_{15}$为0，用$A_{19}-A_{17}$经过负与门产生$G_1$，$A_{16}$产生${G2}^- A^-$，$A_{15}$产生${G2}^- B^-$，$A_{14}-A_{13}$经过74LS138产生片选信号送至4个芯片，$A_0-A{12}$作为地址线\n\n![image-20200928174748637](https://i.loli.net/2020/09/28/qIPTkhexXAzcjGs.png)","tags":["计算机组成原理"]},{"title":"CSAPP Bomb Lab","url":"/2022/11/05/bomblabProcedure/","content":"\n## Bomb Lab Procedure\n\nThis is an x86-64 bomb for self-study students. \n\n**ATTENTION:**\nif `gdb` says its authority  not enough, \n`sudo su`\n`chmod 777 bomb `\n\n#### 准备工作\n\n首先使用`Linux objdump`工具反汇编保存bomb二进制文件的反汇编代码bomb.asm\n\n```bash\nobjdump -d bomb > bomb.asm\n```\n\n再开启`gdb`调试bomb二进制文件\n\n```bash\ngdb bomb\n```\n\n**注意**\n\n`gdb run`可能会提示权限不够，要修改成可读可写可执行，输入命令\n\n```bash\nsudo su;\nchomd 777 bomb\n```\n\n#### 查看代码\n\n##### C 代码\n\n首先查看`.c`代码，由于缺少头文件和其他文件，只能查看`bomb`的整体逻辑\n\n这一段起始代码是尝试进行读文件操作，大概意识是拆除炸弹可以把所有的炸弹密钥字符串写入一个文档，然后将路径作为参数传递给`bomb`启动执行，如果没有传递参数，那么炸弹密钥通过命令行读取\n\n```c\nint main(int argc, char *argv[])\n{\n    char *input; //源代码38行\n\n    /* Note to self: remember to port this bomb to Windows and put a \n     * fantastic GUI on it. */\n\n    /* When run with no arguments, the bomb reads its input lines \n     * from standard input. */\n    if (argc == 1) {  \n\tinfile = stdin;\n    } \n\n    /* When run with one argument <file>, the bomb reads from <file> \n     * until EOF, and then switches to standard input. Thus, as you \n     * defuse each phase, you can add its defusing string to <file> and\n     * avoid having to retype it. */\n    else if (argc == 2) {\n\tif (!(infile = fopen(argv[1], \"r\"))) {\n\t    printf(\"%s: Error: Couldn't open %s\\n\", argv[0], argv[1]);\n\t    exit(8);\n\t}\n    }\n\n    /* You can't call the bomb with more than 1 command line argument. */\n    else {\n\tprintf(\"Usage: %s [<input_file>]\\n\", argv[0]);\n\texit(8);\n    }\n```\n\n下面这一段是初始化炸弹` initialize_bomb();`想必是一个初始化函数，然后打印开始提示信息\n\n```c\n/* Do all sorts of secret stuff that makes the bomb harder to defuse. */ //66行\n    initialize_bomb();\n\n    printf(\"Welcome to my fiendish little bomb. You have 6 phases with\\n\");\n    printf(\"which to blow yourself up. Have a nice day!\\n\");\n```\n\n主体部分，程序分为6个phase，每一个都需要你输入一行字符串，然后对应调用phase_n()函数进行判断是否触发炸弹\n\n```c\n/* Hmm...  Six phases must be more secure than one phase! */  //72\n    input = read_line();             /* Get input                   */\n    phase_1(input);                  /* Run the phase               */\n    phase_defused();                 /* Drat!  They figured it out!\n\t\t\t\t      * Let me know how they did it. */\n    printf(\"Phase 1 defused. How about the next one?\\n\");\n\n    /* The second phase is harder.  No one will ever figure out\n     * how to defuse this... */\n    input = read_line();\n    phase_2(input);\n    phase_defused();\n    printf(\"That's number 2.  Keep going!\\n\");\n\n    /* I guess this is too easy so far.  Some more complex code will\n     * confuse people. */\n    input = read_line();\n    phase_3(input);\n    phase_defused();\n    printf(\"Halfway there!\\n\");\n\n    /* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */\n    input = read_line();\n    phase_4(input);\n    phase_defused();\n    printf(\"So you got that one.  Try this one.\\n\");\n    \n    /* Round and 'round in memory we go, where we stop, the bomb blows! */\n    input = read_line();\n    phase_5(input);\n    phase_defused();\n    printf(\"Good work!  On to the next...\\n\");\n\n    /* This phase will never be used, since no one will get past the\n     * earlier ones.  But just in case, make this one extra hard. */\n    input = read_line();\n    phase_6(input);\n    phase_defused();\n\n    /* Wow, they got it!  But isn't something... missing?  Perhaps\n     * something they overlooked?  Mua ha ha ha ha! */\n    \n    return 0;\n```\n\n##### 反汇编代码\n\n先定位到main\n\n```asm\n0000000000400da0 <main>:\n  400da0:\t53                   \tpush   %rbx\n  400da1:\t83 ff 01             \tcmp    $0x1,%edi\n  400da4:\t75 10                \tjne    400db6 <main+0x16>\n  400da6:\t48 8b 05 9b 29 20 00 \tmov    0x20299b(%rip),%rax        # 603748 <stdin@@GLIBC_2.2.5>\n  400dad:\t48 89 05 b4 29 20 00 \tmov    %rax,0x2029b4(%rip)        # 603768 <infile>\n  400db4:\teb 63                \tjmp    400e19 <main+0x79>\n  400db6:\t48 89 f3             \tmov    %rsi,%rbx\n  400db9:\t83 ff 02             \tcmp    $0x2,%edi\n  400dbc:\t75 3a                \tjne    400df8 <main+0x58>\n  400dbe:\t48 8b 7e 08          \tmov    0x8(%rsi),%rdi\n  400dc2:\tbe b4 22 40 00       \tmov    $0x4022b4,%esi\n  400dc7:\te8 44 fe ff ff       \tcallq  400c10 <fopen@plt>\n  400dcc:\t48 89 05 95 29 20 00 \tmov    %rax,0x202995(%rip)        # 603768 <infile>\n  400dd3:\t48 85 c0             \ttest   %rax,%rax\n  400dd6:\t75 41                \tjne    400e19 <main+0x79>\n  400dd8:\t48 8b 4b 08          \tmov    0x8(%rbx),%rcx\n  400ddc:\t48 8b 13             \tmov    (%rbx),%rdx\n  400ddf:\tbe b6 22 40 00       \tmov    $0x4022b6,%esi\n  400de4:\tbf 01 00 00 00       \tmov    $0x1,%edi\n  400de9:\te8 12 fe ff ff       \tcallq  400c00 <__printf_chk@plt>\n  400dee:\tbf 08 00 00 00       \tmov    $0x8,%edi\n  400df3:\te8 28 fe ff ff       \tcallq  400c20 <exit@plt>\n  400df8:\t48 8b 16             \tmov    (%rsi),%rdx\n  400dfb:\tbe d3 22 40 00       \tmov    $0x4022d3,%esi\n  400e00:\tbf 01 00 00 00       \tmov    $0x1,%edi\n  400e05:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400e0a:\te8 f1 fd ff ff       \tcallq  400c00 <__printf_chk@plt>\n  400e0f:\tbf 08 00 00 00       \tmov    $0x8,%edi\n  400e14:\te8 07 fe ff ff       \tcallq  400c20 <exit@plt>\n  400e19:\te8 84 05 00 00       \tcallq  4013a2 <initialize_bomb>;初始化炸弹\n  \n  \n  ;gdb调试信息：\n  ;(gdb) print (char*)(0x402338)\n  ;$1 = 0x402338 \"Welcome to my fiendish little bomb. You have 6 phases with\"\n  400e1e:\tbf 38 23 40 00       \tmov    $0x402338,%edi\n  400e23:\te8 e8 fc ff ff       \tcallq  400b10 <puts@plt>\n  ;gdb) print (char*)(0x402378)\n  ;$2 = 0x402378 \"which to blow yourself up. Have a nice day!\"\n  400e28:\tbf 78 23 40 00       \tmov    $0x402378,%edi\n  400e2d:\te8 de fc ff ff       \tcallq  400b10 <puts@plt>;打印提示信息\n  ; edi(第一参数寄存器)存放要打印的字符串的地址，通过callq  400b10 <puts@plt>打印\n  ;=========================================================================\n  ;下面一段就是一个炸弹,炸弹先调用read_line,然后将返回的地址传递给phase_n函数，\n  ;如果输入的不正确那么就会执行爆炸函数输出bomb!\n  ;\n  ;\n  ;; 获取输入字符串,rax返回值是字符串地址\n  400e32:\te8 67 06 00 00       \tcallq  40149e <read_line>\n  ;; 获取的输入字符串地址赋给rdi\n  400e37:\t48 89 c7             \tmov    %rax,%rdi\n  400e3a:\te8 a1 00 00 00       \tcallq  400ee0 <phase_1>\n  400e3f:\te8 80 07 00 00       \tcallq  4015c4 <phase_defused>\n  400e44:\tbf a8 23 40 00       \tmov    $0x4023a8,%edi\n  400e49:\te8 c2 fc ff ff       \tcallq  400b10 <puts@plt>\n  \n  \n  400e4e:\te8 4b 06 00 00       \tcallq  40149e <read_line>\n  400e53:\t48 89 c7             \tmov    %rax,%rdi\n  400e56:\te8 a1 00 00 00       \tcallq  400efc <phase_2>\n  400e5b:\te8 64 07 00 00       \tcallq  4015c4 <phase_defused>\n  400e60:\tbf ed 22 40 00       \tmov    $0x4022ed,%edi\n  400e65:\te8 a6 fc ff ff       \tcallq  400b10 <puts@plt>\n  \n  \n  400e6a:\te8 2f 06 00 00       \tcallq  40149e <read_line>\n  400e6f:\t48 89 c7             \tmov    %rax,%rdi\n  400e72:\te8 cc 00 00 00       \tcallq  400f43 <phase_3>\n  400e77:\te8 48 07 00 00       \tcallq  4015c4 <phase_defused>\n  400e7c:\tbf 0b 23 40 00       \tmov    $0x40230b,%edi\n  400e81:\te8 8a fc ff ff       \tcallq  400b10 <puts@plt>\n  \n  \n  400e86:\te8 13 06 00 00       \tcallq  40149e <read_line>\n  400e8b:\t48 89 c7             \tmov    %rax,%rdi\n  400e8e:\te8 79 01 00 00       \tcallq  40100c <phase_4>\n  400e93:\te8 2c 07 00 00       \tcallq  4015c4 <phase_defused>\n  400e98:\tbf d8 23 40 00       \tmov    $0x4023d8,%edi\n  400e9d:\te8 6e fc ff ff       \tcallq  400b10 <puts@plt>\n  \n  \n  400ea2:\te8 f7 05 00 00       \tcallq  40149e <read_line>\n  400ea7:\t48 89 c7             \tmov    %rax,%rdi\n  400eaa:\te8 b3 01 00 00       \tcallq  401062 <phase_5>\n  400eaf:\te8 10 07 00 00       \tcallq  4015c4 <phase_defused>\n  400eb4:\tbf 1a 23 40 00       \tmov    $0x40231a,%edi\n  400eb9:\te8 52 fc ff ff       \tcallq  400b10 <puts@plt>\n  \n  \n  400ebe:\te8 db 05 00 00       \tcallq  40149e <read_line>\n  400ec3:\t48 89 c7             \tmov    %rax,%rdi\n  400ec6:\te8 29 02 00 00       \tcallq  4010f4 <phase_6>\n  400ecb:\te8 f4 06 00 00       \tcallq  4015c4 <phase_defused>\n  400ed0:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400ed5:\t5b                   \tpop    %rbx\n  400ed6:\tc3                   \tretq   \n  400ed7:\t90                   \tnop\n  400ed8:\t90                   \tnop\n  400ed9:\t90                   \tnop\n  400eda:\t90                   \tnop\n  400edb:\t90                   \tnop\n  400edc:\t90                   \tnop\n  400edd:\t90                   \tnop\n  400ede:\t90                   \tnop\n  400edf:\t90                   \tnop\n```\n\n查看`read_line`\n\n```asm\n000000000040149e <read_line>:\n  40149e:\t48 83 ec 08          \tsub    $0x8,%rsp\n  4014a2:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  4014a7:\te8 4d ff ff ff       \tcallq  4013f9 <skip>\n  4014ac:\t48 85 c0             \ttest   %rax,%rax\n  4014af:\t75 6e                \tjne    40151f <read_line+0x81>\n  4014b1:\t48 8b 05 90 22 20 00 \tmov    0x202290(%rip),%rax        # 603748 <stdin@@GLIBC_2.2.5>\n  4014b8:\t48 39 05 a9 22 20 00 \tcmp    %rax,0x2022a9(%rip)        # 603768 <infile>\n  4014bf:\t75 14                \tjne    4014d5 <read_line+0x37>\n  4014c1:\tbf d5 25 40 00       \tmov    $0x4025d5,%edi\n  4014c6:\te8 45 f6 ff ff       \tcallq  400b10 <puts@plt>\n  4014cb:\tbf 08 00 00 00       \tmov    $0x8,%edi\n  4014d0:\te8 4b f7 ff ff       \tcallq  400c20 <exit@plt>\n  4014d5:\tbf f3 25 40 00       \tmov    $0x4025f3,%edi\n  4014da:\te8 01 f6 ff ff       \tcallq  400ae0 <getenv@plt>\n  \n  4014df:\t48 85 c0             \ttest   %rax,%rax\n  ; rax为零则跳转到4014ee,否则edi清零并callq  400c20 <exit@plt>\n  4014e2:\t74 0a                \tje     4014ee <read_line+0x50>\n  4014e4:\tbf 00 00 00 00       \tmov    $0x0,%edi\n  4014e9:\te8 32 f7 ff ff       \tcallq  400c20 <exit@plt>\n  \n  4014ee:\t48 8b 05 53 22 20 00 \tmov    0x202253(%rip),%rax        # 603748 <stdin@@GLIBC_2.2.5>\n  4014f5:\t48 89 05 6c 22 20 00 \tmov    %rax,0x20226c(%rip)        # 603768 <infile>\n  4014fc:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401501:\te8 f3 fe ff ff       \tcallq  4013f9 <skip>\n  401506:\t48 85 c0             \ttest   %rax,%rax\n  401509:\t75 14                \tjne    40151f <read_line+0x81>\n  40150b:\tbf d5 25 40 00       \tmov    $0x4025d5,%edi\n  401510:\te8 fb f5 ff ff       \tcallq  400b10 <puts@plt>\n  401515:\tbf 00 00 00 00       \tmov    $0x0,%edi\n  40151a:\te8 01 f7 ff ff       \tcallq  400c20 <exit@plt>\n  40151f:\t8b 15 3b 22 20 00    \tmov    0x20223b(%rip),%edx        # 603760 <num_input_strings>\n  401525:\t48 63 c2             \tmovslq %edx,%rax\n  401528:\t48 8d 34 80          \tlea    (%rax,%rax,4),%rsi\n  40152c:\t48 c1 e6 04          \tshl    $0x4,%rsi\n  401530:\t48 81 c6 80 37 60 00 \tadd    $0x603780,%rsi\n  401537:\t48 89 f7             \tmov    %rsi,%rdi\n  40153a:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  40153f:\t48 c7 c1 ff ff ff ff \tmov    $0xffffffffffffffff,%rcx\n  401546:\tf2 ae                \trepnz scas %es:(%rdi),%al\n  401548:\t48 f7 d1             \tnot    %rcx\n  40154b:\t48 83 e9 01          \tsub    $0x1,%rcx\n  40154f:\t83 f9 4e             \tcmp    $0x4e,%ecx\n  ;ecx有符号小于等于0x4e则跳转到40159a(引爆炸弹的下一条指令处)\n  401552:\t7e 46                \tjle    40159a <read_line+0xfc> \n  \n  401554:\tbf fe 25 40 00       \tmov    $0x4025fe,%edi\n  401559:\te8 b2 f5 ff ff       \tcallq  400b10 <puts@plt>\n  40155e:\t8b 05 fc 21 20 00    \tmov    0x2021fc(%rip),%eax        # 603760 <num_input_strings>\n  401564:\t8d 50 01             \tlea    0x1(%rax),%edx\n  401567:\t89 15 f3 21 20 00    \tmov    %edx,0x2021f3(%rip)        # 603760 <num_input_strings>\n  40156d:\t48 98                \tcltq   \n  40156f:\t48 6b c0 50          \timul   $0x50,%rax,%rax\n  401573:\t48 bf 2a 2a 2a 74 72 \tmovabs $0x636e7572742a2a2a,%rdi\n  40157a:\t75 6e 63 \n  40157d:\t48 89 b8 80 37 60 00 \tmov    %rdi,0x603780(%rax)\n  401584:\t48 bf 61 74 65 64 2a \tmovabs $0x2a2a2a64657461,%rdi\n  40158b:\t2a 2a 00 \n  40158e:\t48 89 b8 88 37 60 00 \tmov    %rdi,0x603788(%rax)\n  401595:\te8 a0 fe ff ff       \tcallq  40143a <explode_bomb> ;引爆炸弹\n  40159a:\t83 e9 01             \tsub    $0x1,%ecx\n  40159d:\t48 63 c9             \tmovslq %ecx,%rcx\n  4015a0:\t48 63 c2             \tmovslq %edx,%rax\n  4015a3:\t48 8d 04 80          \tlea    (%rax,%rax,4),%rax\n  4015a7:\t48 c1 e0 04          \tshl    $0x4,%rax\n  4015ab:\tc6 84 01 80 37 60 00 \tmovb   $0x0,0x603780(%rcx,%rax,1)\n  4015b2:\t00 \n  4015b3:\t83 c2 01             \tadd    $0x1,%edx\n  4015b6:\t89 15 a4 21 20 00    \tmov    %edx,0x2021a4(%rip)        # 603760 <num_input_strings>\n  4015bc:\t48 89 f0             \tmov    %rsi,%rax\n  4015bf:\t48 83 c4 08          \tadd    $0x8,%rsp\n  4015c3:\tc3                   \tretq   \n```\n\n`strings_not_equal`函数\n\n```asm\n0000000000401338 <strings_not_equal>:\n  401338:\t41 54                \tpush   %r12\n  40133a:\t55                   \tpush   %rbp \n  40133b:\t53                   \tpush   %rbx ; rbp,rbx压栈,说明该函数要使用\n  ; 分别赋值rdi,rsi,说明匹配的字符串地址应该在rdi,rsi处\n  40133c:\t48 89 fb             \tmov    %rdi,%rbx ;\n  40133f:\t48 89 f5             \tmov    %rsi,%rbp \n  \n  401342:\te8 d4 ff ff ff       \tcallq  40131b <string_length>\n  401347:\t41 89 c4             \tmov    %eax,%r12d\n  40134a:\t48 89 ef             \tmov    %rbp,%rdi\n  40134d:\te8 c9 ff ff ff       \tcallq  40131b <string_length>\n  401352:\tba 01 00 00 00       \tmov    $0x1,%edx\n  401357:\t41 39 c4             \tcmp    %eax,%r12d\n  40135a:\t75 3f                \tjne    40139b <strings_not_equal+0x63>\n  40135c:\t0f b6 03             \tmovzbl (%rbx),%eax\n  40135f:\t84 c0                \ttest   %al,%al\n  401361:\t74 25                \tje     401388 <strings_not_equal+0x50>\n  401363:\t3a 45 00             \tcmp    0x0(%rbp),%al\n  401366:\t74 0a                \tje     401372 <strings_not_equal+0x3a>\n  401368:\teb 25                \tjmp    40138f <strings_not_equal+0x57>\n  40136a:\t3a 45 00             \tcmp    0x0(%rbp),%al\n  40136d:\t0f 1f 00             \tnopl   (%rax)\n  401370:\t75 24                \tjne    401396 <strings_not_equal+0x5e>\n  401372:\t48 83 c3 01          \tadd    $0x1,%rbx\n  401376:\t48 83 c5 01          \tadd    $0x1,%rbp\n  40137a:\t0f b6 03             \tmovzbl (%rbx),%eax\n  40137d:\t84 c0                \ttest   %al,%al\n  40137f:\t75 e9                \tjne    40136a <strings_not_equal+0x32>\n  401381:\tba 00 00 00 00       \tmov    $0x0,%edx\n  401386:\teb 13                \tjmp    40139b <strings_not_equal+0x63>\n  401388:\tba 00 00 00 00       \tmov    $0x0,%edx\n  40138d:\teb 0c                \tjmp    40139b <strings_not_equal+0x63>\n  40138f:\tba 01 00 00 00       \tmov    $0x1,%edx\n  401394:\teb 05                \tjmp    40139b <strings_not_equal+0x63>\n  401396:\tba 01 00 00 00       \tmov    $0x1,%edx\n  40139b:\t89 d0                \tmov    %edx,%eax\n  40139d:\t5b                   \tpop    %rbx\n  40139e:\t5d                   \tpop    %rbp\n  40139f:\t41 5c                \tpop    %r12\n  4013a1:\tc3                   \tretq   \n```\n\n\n\n#### 第一个炸弹\n\n```asm\n0000000000400ee0 <phase_1>:\n  400ee0:\t48 83 ec 08          \tsub    $0x8,%rsp ;申请8字节栈空间\n  ;给寄存器esi(rsi低32位)赋值,应该是一个地址,esi(rsi)是第二个参数寄存器\n  400ee4:\tbe 00 24 40 00       \tmov    $0x402400,%esi ;\n  ;调用匹配字符串函数\n  400ee9:\te8 4a 04 00 00       \tcallq  401338 <strings_not_equal>\n  ;测试匹配函数结束后的eax(返回值rax低32位)寄存器值,若0,栈复原退出,否则调用炸弹爆炸函数\n  400eee:\t85 c0                \ttest   %eax,%eax\n  400ef0:\t74 05                \tje     400ef7 <phase_1+0x17>\n  400ef2:\te8 43 05 00 00       \tcallq  40143a <explode_bomb>\n  400ef7:\t48 83 c4 08          \tadd    $0x8,%rsp\n  400efb:\tc3                   \tretq   \n```\n\n结合phase1的代码\n\n```asm\n ;; 获取输入字符串,rax返回值是字符串地址\n  400e32:\te8 67 06 00 00       \tcallq  40149e <read_line>\n  ;; 获取的输入字符串地址赋给rdi\n  400e37:\t48 89 c7             \tmov    %rax,%rdi\n  400e3a:\te8 a1 00 00 00       \tcallq  400ee0 <phase_1>\n  400e3f:\te8 80 07 00 00       \tcallq  4015c4 <phase_defused>\n  400e44:\tbf a8 23 40 00       \tmov    $0x4023a8,%edi \n  400e49:\te8 c2 fc ff ff       \tcallq  400b10 <puts@plt>\n```\n\n`read_line`函数会将读入字符串地址存放在`rdi `和`rsi`中，`strings_not_equa`l函数会使用`edi`和`esi`中的值当做两个字符址，并且判断他们是否相等，相等返回0\n\n`edi`存放的是`callq  400b10 <puts@plt>`要打印的信息的地址，用gdb调试\n\n```bash\n(gdb) print (char*)(0x4023a8)\n$3 = 0x4023a8 \"Phase 1 defused. How about the next one?\"\n```\n\n可见打印的是成功拆除的信息。因此，炸弹1的整体逻辑就是\n\n```mermaid\ngraph LR\nA[开始] --> B[ 函数readline ]\n     B--> C(rdi=&输入字符串<br>rsi=&密钥字符串) --> D{string_not_equal}\n     D--> |返回0| E[puts success info]\n     D--> |返回非0| F[bomb_explode]\n```\n\n于是，重点在于找到给`rsi`赋地址的语句，这个地址存储的就是密钥字符串\n\n```asm\n0000000000400ee0 <phase_1>:\n  400ee0:\t48 83 ec 08          \tsub    $0x8,%rsp ;申请8字节栈空间\n  ;给寄存器esi(rsi低32位)赋值,应该是一个地址,esi(rsi)是第二个参数寄存器\n  400ee4:\tbe 00 24 40 00       \tmov    $0x402400,%esi ; rsi赋地址语句\n```\n\n`esi`是`rsi`的低32位，400ee4给`esi`赋值就是给`rsi`赋值为密钥字符串地址\n\n`gdb`调试\n\n```bash\n(gdb) print (char*) (0x402400)\n$7 = 0x402400 \"Border relations with Canada have never been better.\"\n```\n\n第一个炸弹的密钥就是**\"Border relations with Canada have never been better.\"**\n\n#### 第二个炸弹\n\n查看`phase_2`代码\n\n```asm\n0000000000400efc <phase_2>:\n  400efc:\t55                   \tpush   %rbp\n  400efd:\t53                   \tpush   %rbx ; rbx rbp压栈，要被调用\n  400efe:\t48 83 ec 28          \tsub    $0x28,%rsp ; 申请0x28=40字节栈帧\n  400f02:\t48 89 e6             \tmov    %rsp,%rsi ; 将rsp值赋给rsi\n  ;根据函数名,应该是读入六个数\n  400f05:\te8 52 05 00 00       \tcallq  40145c <read_six_numbers>\n  \n  400f0a:\t83 3c 24 01          \tcmpl   $0x1,(%rsp); 查栈顶元素是否是1,\n  \t\t\t\t\t\t\t\t\t\t\t\t\t  ; 由下文分析可知phase_2栈顶存储的是第一个输入的值\n  \t\t\t\t\t\t\t\t\t\t\t\t\t  ; 因此密钥第一个数字必定是1\n  400f0e:\t74 20                \tje     400f30 <phase_2+0x34>;是1，跳转到400f30进行首轮哨兵初始化等操作,不是则引爆炸弹\n  400f10:\te8 25 05 00 00       \tcallq  40143a <explode_bomb> ;引爆炸弹\n  400f15:\teb 19                \tjmp    400f30 <phase_2+0x34> \n  \n  ;取出rbx-4处的值赋给eax\n  400f17:\t8b 43 fc             \tmov    -0x4(%rbx),%eax\n  400f1a:\t01 c0                \tadd    %eax,%eax; eax=2*eax\n  ;比较eax*2和rbx处的值,注意:eax是rbx-4处的值，即将rbx和前一个数的两倍比较\n  400f1c:\t39 03                \tcmp    %eax,(%rbx)\n  ; rbx和前一个数的两倍相等则跳转\n  400f1e:\t74 05                \tje     400f25 <phase_2+0x29> \n  ; 不相等引爆炸弹\n  400f20:\te8 15 05 00 00       \tcallq  40143a <explode_bomb>\n  ; rbx=rbx+4\n  400f25:\t48 83 c3 04          \tadd    $0x4,%rbx\n  ; 将rbx和rbp比较\n  ;将加4后的值和rbp比较，\n  ;注意rbp是rsp+24 (400f30代码),而rsp是第一个数，一个数四个字节。那么rbp就应该是\n  ;后那个数后面那个地址，即rbp是个循环哨兵\n  400f29:\t48 39 eb             \tcmp    %rbp,%rbx\n  ; 不相等跳转回rbx-4，继续取rbx前一个数的两倍与其比较\n  400f2c:\t75 e9                \tjne    400f17 <phase_2+0x1b>\n  ; 相等则直接跳转出去\n  400f2e:\teb 0c                \tjmp    400f3c <phase_2+0x40>\n  \n  400f30:\t48 8d 5c 24 04       \tlea    0x4(%rsp),%rbx ;将rsp+4存到rbx\n  400f35:\t48 8d 6c 24 18       \tlea    0x18(%rsp),%rbp ; 将rsp +24 存到rbp\n  ; 无条件跳回去,取rbx前一个数的两倍与其比较\n  400f3a:\teb db                \tjmp    400f17 <phase_2+0x1b> \n  \n  400f3c:\t48 83 c4 28          \tadd    $0x28,%rsp\n  400f40:\t5b                   \tpop    %rbx\n  400f41:\t5d                   \tpop    %rbp\n  400f42:\tc3                   \tretq   \n```\n\n查看`read_six_number`代码\n\n内部调用了`sscanf` 这个函数（功能是从一个字符串中读取一定格式的数据，和 `scanf` 一样，除了 `scanf` 是从标准输入流中读取）。参数顺序分别是，待读取内容的字符串(`rdi`)、用于格式读取的格式化字符串(`rsi`)，还有各个变量读取后存放的地址(`rdx`)。返回读到的有效数据个数\n\n- `%rdx`由 `%rsi` 给出，`%rsi` 又由 `phrase2` 的 `%rsp` 给出，所以 `phrase2` 中的 `%rsp` 地址处存放 `sscanf` 中第1个输入的值。\n\n```asm\n000000000040145c <read_six_numbers>:\n  40145c:\t48 83 ec 18          \tsub    $0x18,%rsp ; 申请0x18=24字节栈帧\n  401460:\t48 89 f2             \tmov    %rsi,%rdx; rdx=rsi\n  401463:\t48 8d 4e 04          \tlea    0x4(%rsi),%rcx; rcx=rsi+4\n  \n  ;                                       \trax=rsi+0x14\n  401467:\t48 8d 46 14          \tlea    0x14(%rsi),%rax\n  40146b:\t48 89 44 24 08       \tmov    %rax,0x8(%rsp);将rax存入rsp+8处\n  ;此时栈\n  ;| ......... |  <- rsi,rdx \n  ;|  返回地址  |\n  ;|           |\n  ;|  rsi+0x14 |\n  ;|           |  <- rsp\n  \n  401470:\t48 8d 46 10          \tlea    0x10(%rsi),%rax; rax=rsi+0x10\n  401474:\t48 89 04 24          \tmov    %rax,(%rsp); 将rax存入rsp处\n  ;此时栈\n  ;| ......... |  <- rsi,rdx \n  ;|  返回地址  |\n  ;|           |\n  ;|  rsi+0x14 |\n  ;|  rsi+0x10 |  <- rsp\n  401478:\t4c 8d 4e 0c          \tlea    0xc(%rsi),%r9\n  40147c:\t4c 8d 46 08          \tlea    0x8(%rsi),%r8\n  \n  \n  ;将rsi赋值为0x4025c3\n  401480:\tbe c3 25 40 00       \tmov    $0x4025c3,%esi\n  401485:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  ;调用了scanf\n  40148a:\te8 61 f7 ff ff       \tcallq  400bf0 <__isoc99_sscanf@plt>\n  \n  \n  40148f:\t83 f8 05             \tcmp    $0x5,%eax\n  ; eax 大于5 跳转到401499准备返回,否则调用爆炸函数,eax存放的应该是读到的数字个数\n  401492:\t7f 05                \tjg     401499 <read_six_numbers+0x3d>\n  401494:\te8 a1 ff ff ff       \tcallq  40143a <explode_bomb>\n  ; 释放栈帧，返回\n  401499:\t48 83 c4 18          \tadd    $0x18,%rsp\n  40149d:\tc3                   \tretq   \n```\n\n- `%rcx`，`phrase2` 中的 `%rsp+0x4` 处存放第2个值\n- `%r8`，`phrase2` 中的 `%rsp+0x8` 存放第3个值\n- `%r9`，`phrase2` 中的 `%rsp+0xc` 存放第4个值\n\n- 第5个、第6个值所在的地址需要通过压栈传参，参数的入栈顺序是从右至左。可知，`phrase2` 中的 `%rsp+0x10` 存放第五个值、`phrase2` 中的 `%rsp+0x14` 存放第六个值。第六个值先入栈，更加靠近栈底（高地址）。\n\n打印0x4025c3处的值\n\n```bash\n(gdb) x /4wd 0x4025c3\n0x4025c3:\t622879781\t1680154724\t543434016\t622879781\n```\n\n乱七八糟，尝试用字符串打印\n\n```asm\n(gdb) print (char*)0x4025c3\n$5 = 0x4025c3 \"%d %d %d %d %d %d\"\n```\n\n这说明`sscanf`读取的确实是6个数字。可以确定，第2个炸弹的密钥是**1 2 4 8 16 32**\n\n#### 第三个炸弹\n\n查看`phase_3`代码\n\n```asm\n0000000000400f43 <phase_3>:\n  400f43:\t48 83 ec 18          \tsub    $0x18,%rsp\n  400f47:\t48 8d 4c 24 0c       \tlea    0xc(%rsp),%rcx ; rcx存储接受输入的第2个数字的地址\n  400f4c:\t48 8d 54 24 08       \tlea    0x8(%rsp),%rdx ; rdx 是sscanf接受输入字符串的地址,为rsp+8\n  \n  400f51:\tbe cf 25 40 00       \tmov    $0x4025cf,%esi ;esi(rsi)为sscanf的第二个参数,输入格式\n  400f56:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400f5b:\te8 90 fc ff ff       \tcallq  400bf0 <__isoc99_sscanf@plt> ; 又调用sscanf获取输入\n  \n```\n\n代码开头就调用了`sscanf`，所以这个函数前面一定会有一个字符串常量存储需要读取的数据格式，函数的第二个参数用`rsi(esi)`存储，`400f51:`处代码告诉了`esi`的字符串首地址是`0x4025cf`，\n\n使用`gdb`调试\n\n```bash\n(gdb) print (char*) 0x4025cf\n$1 = 0x4025cf \"%d %d\"\n```\n\n确定这个炸弹的输入是两个数字\n\n继续查看代码，发现其`cmp,jmp`等跳转指令很多，而且极其的有规律，猜测是个switch语句\n\n```asm\n  400f60:\t83 f8 01             \tcmp    $0x1,%eax ; eax与1比较,应该是返回值sscanf返回读到的2数据个数\n  ; eax大于1 跳转L1,否则触发爆炸,因为密钥是2个数字,小于等于1个有效数据肯定错误\n  400f63:\t7f 05                \tjg     400f6a <phase_3+0x27>\n  400f65:\te8 d0 04 00 00       \tcallq  40143a <explode_bomb>\n  ; L1, 结合上文代码,这是比较ssacnf获取的第一个输入数据和0x7的大小\n  400f6a:\t83 7c 24 08 07       \tcmpl   $0x7,0x8(%rsp)\n  ; 无符号大于7跳转到L2爆炸\n  400f6f:\t77 3c                \tja     400fad <phase_3+0x6a>\n  ; 无符号小于等于7, 将eax赋值为sscanf获取的第一个输入\n  400f71:\t8b 44 24 08          \tmov    0x8(%rsp),%eax\n  ; 间接跳转, 跳转到 (0x402470+%rax*8)内存数据表示的地址,这是switch典型代码,0x402470存储的应该是一个跳转表\n  400f75:\tff 24 c5 70 24 40 00 \tjmpq   *0x402470(,%rax,8)\n  ; 跳转表元素的每个数据应该是下面的一段,进行一次mov操作,修改eax值后统一跳转到400fbe处\n  ; case1\n  400f7c:\tb8 cf 00 00 00       \tmov    $0xcf,%eax\n  400f81:\teb 3b                \tjmp    400fbe <phase_3+0x7b>\n  ; case2\n  400f83:\tb8 c3 02 00 00       \tmov    $0x2c3,%eax\n  400f88:\teb 34                \tjmp    400fbe <phase_3+0x7b>\n  ; case3\n  400f8a:\tb8 00 01 00 00       \tmov    $0x100,%eax\n  400f8f:\teb 2d                \tjmp    400fbe <phase_3+0x7b>\n  ; case4\n  400f91:\tb8 85 01 00 00       \tmov    $0x185,%eax\n  400f96:\teb 26                \tjmp    400fbe <phase_3+0x7b>\n  ; case5\n  400f98:\tb8 ce 00 00 00       \tmov    $0xce,%eax\n  400f9d:\teb 1f                \tjmp    400fbe <phase_3+0x7b>\n  ; case6\n  400f9f:\tb8 aa 02 00 00       \tmov    $0x2aa,%eax\n  400fa4:\teb 18                \tjmp    400fbe <phase_3+0x7b>\n  ; case7\n  400fa6:\tb8 47 01 00 00       \tmov    $0x147,%eax\n  400fab:\teb 11                \tjmp    400fbe <phase_3+0x7b>\n  ; L2 触发爆炸\n  400fad:\te8 88 04 00 00       \tcallq  40143a <explode_bomb>\n  400fb2:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400fb7:\teb 05                \tjmp    400fbe <phase_3+0x7b>\n  ;?\n  400fb9:\tb8 37 01 00 00       \tmov    $0x137,%eax\n  ; case 结束后跳转到的地方\n  ; 显然这里是把ssacnf获取的第二个输入数字与case处理后的eax比较\n  400fbe:\t3b 44 24 0c          \tcmp    0xc(%rsp),%eax\n  ; 若相等,则复原栈帧跳出去\n  400fc2:\t74 05                \tje     400fc9 <phase_3+0x86>\n  ; 不等就爆炸\n  400fc4:\te8 71 04 00 00       \tcallq  40143a <explode_bomb>\n  400fc9:\t48 83 c4 18          \tadd    $0x18,%rsp\n  400fcd:\tc3                   \tretq   \n```\n\n因此本题答案可不唯一，第一个数字应该无符号小于等于7，\n\n`gdb`打印跳转表\n\n```bash\n(gdb) x /8gx 0x402470\n0x402470:\t0x0000000000400f7c [case1]\t\t0x0000000000400fb9 [?]\n0x402480:\t0x0000000000400f83 [case2]     \t0x0000000000400f8a [case3]\n0x402490:\t0x0000000000400f91 [case4]\t\t0x0000000000400f98 [case5]\n0x4024a0:\t0x0000000000400f9f [case6]      0x0000000000400fa6 [case7]\n```\n\n因此 假设第一个数字是0，那么跳转到的是`case1`，`eax=0xcf`，第二个数字得是`0xcf=207`\n\n第一个数字是1，跳转到？,`eax=0x137=311`\n\n#### 第四个炸弹\n\n查看`phase_4`代码，考察的是函数递归调用\n\n```asm\n000000000040100c <phase_4>:\n  40100c:\t48 83 ec 18          \tsub    $0x18,%rsp ; 申请0x18=24直接栈帧\n  ;| phase_4 ret addr |\n  ;|                  |\t <- rcx   (sscanf 输入2nd)\n  ;|                  |  <- rdx   (sscanf 输入1st)\n  ;|                  |  <- rsp\n  401010:\t48 8d 4c 24 0c       \tlea    0xc(%rsp),%rcx\n  401015:\t48 8d 54 24 08       \tlea    0x8(%rsp),%rdx ; sscanf获取的输入存放的地址\n  \n  \n  40101a:\tbe cf 25 40 00       \tmov    $0x4025cf,%esi;esi(rsi)为sscanf的第二个参数,输入格式\n  40101f:\tb8 00 00 00 00       \tmov    $0x0,%eax ; eax(rax)清零 \n  401024:\te8 c7 fb ff ff       \tcallq  400bf0 <__isoc99_sscanf@plt>; 调用sscanf\n  401029:\t83 f8 02             \tcmp    $0x2,%eax; sscanf返回的eax是有效数据个数，判断是否是2\n  ; 不相等跳转到爆炸处,有效输入个数不是2,必然和密钥不匹配,错误\n  40102c:\t75 07                \tjne    401035 <phase_4+0x29>\n  ; 是2个有效输入,比较第一个输入和0xe=14\n  40102e:\t83 7c 24 08 0e       \tcmpl   $0xe,0x8(%rsp)\n  ; 第一个输入无符号小于等于14 跳转避开炸弹,否则到401035处爆炸\n  401033:\t76 05                \tjbe    40103a <phase_4+0x2e>\n  ; 引爆炸弹\n  401035:\te8 00 04 00 00       \tcallq  40143a <explode_bomb>\n  ; 避开炸弹跳转点,将edx置为0xe=14\n  40103a:\tba 0e 00 00 00       \tmov    $0xe,%edx\n  ; esi清零\n  40103f:\tbe 00 00 00 00       \tmov    $0x0,%esi\n  ; edi置为sscanf获取的第一个输入\n  401044:\t8b 7c 24 08          \tmov    0x8(%rsp),%edi\n  ; 调用func4函数\n  ;| phase_4 ret addr |\n  ;|                  |\t <- rcx   (sscanf 输入2nd)\n  ;|                  |  <- rdx   (sscanf 输入1st)\n  ;|                  | \n  ;| func4  ret addr  |  <- rsp\n  ;|                  |\n  401048:\te8 81 ff ff ff       \tcallq  400fce <func4>\n  ; 调用结束后检查 eax\n  40104d:\t85 c0                \ttest   %eax,%eax\n  ;  返回值非零引爆炸弹\n  40104f:\t75 07                \tjne    401058 <phase_4+0x4c>\n  ; 返回值为零 将第二个输入与0做比较\n  401051:\t83 7c 24 0c 00       \tcmpl   $0x0,0xc(%rsp)\n  ; 第二个输入是0 则跳出,否则仍然引爆炸弹\n  401056:\t74 05                \tje     40105d <phase_4+0x51>\n  ; 引爆炸弹\n  401058:\te8 dd 03 00 00       \tcallq  40143a <explode_bomb>\n  40105d:\t48 83 c4 18          \tadd    $0x18,%rsp\n  401061:\tc3                   \tretq  \n```\n\n又调用了`sscanf`函数，`esi`与`phase_3`中地址相同，因此输入格式又是`\"%d %d\"`\n\n\n\n其调用了一个函数`func4`\n\n```asm\n0000000000400fce <func4>:\n  400fce:\t48 83 ec 08          \tsub    $0x8,%rsp ;申请8字节栈帧\n  ;| phase_4 ret addr |\n  ;|      ...         |\t <- rcx (ecx)   (sscanf 输入2nd)\n  ;|      ...         |  <- rdx (edx)  (sscanf 输入1st)\n  ;|                  | \n  ;| func4  ret addr  |  \n  ;|                  |  <- rsp\n  ; 初次调用:edx=14,esi=0, edi = sscanf input 1\n  ; 此前edx被赋值为0xe=14,现eax=14\n  400fd2:\t89 d0                \tmov    %edx,%eax\n  ; eax=eax-esi  更新eax\n  400fd4:\t29 f0                \tsub    %esi,%eax\n  ; ecx=eax\n  400fd6:\t89 c1                \tmov    %eax,%ecx\n  ; 将ecx逻辑右移(加0右移)31位,ecx长为32位,也就是之前的最高位变为最低位,其余31位填充补0\n  400fd8:\tc1 e9 1f             \tshr    $0x1f,%ecx\n  ; eax=eax+(eax最高位)\n  400fdb:\t01 c8                \tadd    %ecx,%eax\n  ; 这里是一个缩写 sar $1,%eax (对应的机器码为 D1F8)  eax = eax/2\n  400fdd:\td1 f8                \tsar    %eax\n  ; ecx= rax+rsi\n  400fdf:\t8d 0c 30             \tlea    (%rax,%rsi,1),%ecx\n  ; ecx和edi比较\n  400fe2:\t39 f9                \tcmp    %edi,%ecx\n  ; ecx小于等于edi则跳至另一个递归方案\n  400fe4:\t7e 0c                \tjle    400ff2 <func4+0x24>\n  ; 否则 edx=rcx-1\n  400fe6:\t8d 51 ff             \tlea    -0x1(%rcx),%edx\n  ; 递归调用func4\n  400fe9:\te8 e0 ff ff ff       \tcallq  400fce <func4>\n  ; eax=2*eax\n  400fee:\t01 c0                \tadd    %eax,%eax\n  ; 本层递归结束,递归出口，回上一层递归\n  400ff0:\teb 15                \tjmp    401007 <func4+0x39>\n  ; 另一个递归方案 , eax清零\n  400ff2:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  400ff7:\t39 f9                \tcmp    %edi,%ecx\n  ; 递归出口,回上一层递归\n  400ff9:\t7d 0c                \tjge    401007 <func4+0x39>\n  400ffb:\t8d 71 01             \tlea    0x1(%rcx),%esi\n  400ffe:\te8 cb ff ff ff       \tcallq  400fce <func4>\n  401003:\t8d 44 00 01          \tlea    0x1(%rax,%rax,1),%eax\n  ; 返回\n  401007:\t48 83 c4 08          \tadd    $0x8,%rsp\n  40100b:\tc3                   \tretq  \n```\n\n尝试将func4由汇编翻译回`C`代码，\n\n```c\n#include <stdio.h>\nint func4(int edi, int esi, int edx) {\n    int temp = (edx - esi);\n    int ecx=(temp>>31)&(0x0001);\n    temp+=ecx;\n    temp=temp>>1;\n    int mid = temp + esi;\n    if (mid > edi) {\n        edx = mid - 1;\n        int ret1 = func4(edi, esi, edx);\n        return 2 * ret1;\n    } else {\n        if (mid >= edi) {\n            return 0;\n        } else {\n            esi = mid + 1;\n            int ret2 = func4(edi, esi, edx);\n            return (2 * ret2 + 1);\n        }\n    }\n}\nint main() {\n    for (int edi = 0; edi < 10; edi++) {\n        int res = func4(edi, 0, 14);\n        printf(\"edi=%d, res=%d\\n\", edi, res);\n    }\n    return 0;\n}\n```\n\n```bash\n> gcc -o test .\\bombPhase4.c\n> .\\test.exe\nedi=0, res=0\nedi=1, res=0\nedi=2, res=4\nedi=3, res=0\nedi=4, res=2\nedi=5, res=2\nedi=6, res=6\nedi=7, res=0\nedi=8, res=1\nedi=9, res=1\n```\n\n因此，**7 0、3 0 、1 0**等均可\n\n#### 第五个炸弹\n\n查看`phase_5`代码\n\n```asm\n0000000000401062 <phase_5>:\n  401062:\t53                   \tpush   %rbx ; rbx入栈,本函数要使用rbx\n  401063:\t48 83 ec 20          \tsub    $0x20,%rsp ; 申请0x20=32字节大小的栈帧\n  ;|   phase_5 ret addr   |\n  ;|        %rbx          |\n  ;|                      |\n  ;|                      |\n  ;|                      |\n  ;|                      | <-rsp\n  \n  401067:\t48 89 fb             \tmov    %rdi,%rbx\t; rbx=rdi (rdi=&输入字符串,可由read_line分析得到) \n  ; 反汇编的at&t风格代码\n  40106a:\t64 48 8b 04 25 28 00 \tmov    %fs:0x28,%rax ;把fs选择子的偏移值0x28(64bit)放入rax(64bit暂存器)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n  401071:\t00 00 \n  401073:\t48 89 44 24 18       \tmov    %rax,0x18(%rsp)\n  ;|   phase_5 ret addr   |\n  ;|        %rbx          |\n  ;|        %rax          |\n  ;|                      |\n  ;|                      |\n  ;|                      | <-rsp\n  \n  401078:\t31 c0                \txor    %eax,%eax ; eax清零\n  40107a:\te8 9c 02 00 00       \tcallq  40131b <string_length> ; 猜测是获取字符串长度返回eax\n  40107f:\t83 f8 06             \tcmp    $0x6,%eax ; 判断输入字符串长度是否是6\n  ; 如果长度是6,跳转L2 清零eax(rax低32位,这里可视为rax)\n  401082:\t74 4e                \tje     4010d2 <phase_5+0x70>\n  ; 长度不是6,引爆炸弹\n  401084:\te8 b1 03 00 00       \tcallq  40143a <explode_bomb>\n  401089:\teb 47                \tjmp    4010d2 <phase_5+0x70>\n  ; L1 跳回 循环点   初次从L2跳来, eax为零\n  ; 这里是根据输入的6字节字符串低4位为序号从另一个字符串中取字符存到栈的rsp+0x10为最低地址处\n  40108b:\t0f b6 0c 03          \tmovzbl (%rbx,%rax,1),%ecx ; ecx= rbx(&输入字符串)+rax(当前匹配的字符序号)\n  40108f:\t88 0c 24             \tmov    %cl,(%rsp) ; 在栈顶存储%cl (rcx最低字节)\n  401092:\t48 8b 14 24          \tmov    (%rsp),%rdx \t; rdx=%cl\n  401096:\t83 e2 0f             \tand    $0xf,%edx \t; edx高位清零,只留下最低4位\n  401099:\t0f b6 92 b0 24 40 00 \tmovzbl 0x4024b0(%rdx), %edx ; edx= M[0x4024b0+%rdx]零扩展字节至双字\n  4010a0:\t88 54 04 10          \tmov    %dl,0x10(%rsp,%rax,1); M[rsp+rax+0x10]处存入%dl(%edx低字节)\n  4010a4:\t48 83 c0 01          \tadd    $0x1,%rax\t; rax++ , rax存放的应该是当前匹配的字符序号\n  4010a8:\t48 83 f8 06          \tcmp    $0x6,%rax\t; 比较取完没\n  4010ac:\t75 dd                \tjne    40108b <phase_5+0x29> ; 没有取完全部6个,返回L1循环\n  \n  ; rsp+0x10---rsp+0x15 存储的取出的新6字节字符串 , 将 rsp+0x16清零,即字符串末尾标志'\\0'\n  4010ae:\tc6 44 24 16 00       \tmovb   $0x0,0x16(%rsp)\n  ; esi 存储 要和比较的字符串基址\n  4010b3:\tbe 5e 24 40 00       \tmov    $0x40245e,%esi\n  ; rdi 存储 rsp+0x10,即新字符串的地址\n  4010b8:\t48 8d 7c 24 10       \tlea    0x10(%rsp),%rdi\n  ;进行比较;\n  ;由之前分析strings_not_equal函数使用edi和esi中的值当做两个字符址，并且判断他们是否相等，相等返回0\n  4010bd:\te8 76 02 00 00       \tcallq  401338 <strings_not_equal>\n  ; 判断返回值是否是0\n  4010c2:\t85 c0                \ttest   %eax,%eax\n  ; 为零说明完全匹配成功,跳到L3退出\n  4010c4:\t74 13                \tje     4010d9 <phase_5+0x77>\n  ; 不为零说明无法完全匹配,爆炸\n  4010c6:\te8 6f 03 00 00       \tcallq  40143a <explode_bomb>\n  4010cb:\t0f 1f 44 00 00       \tnopl   0x0(%rax,%rax,1)\n  4010d0:\teb 07                \tjmp    4010d9 <phase_5+0x77>\n  ;L2 eax清零后跳回L1\n  4010d2:\tb8 00 00 00 00       \tmov    $0x0,%eax \n  4010d7:\teb b2                \tjmp    40108b <phase_5+0x29>\n  ;L3:\n  4010d9:\t48 8b 44 24 18       \tmov    0x18(%rsp),%rax\n  4010de:\t64 48 33 04 25 28 00 \txor    %fs:0x28,%rax\n  4010e5:\t00 00 \n  4010e7:\t74 05                \tje     4010ee <phase_5+0x8c>\n  4010e9:\te8 42 fa ff ff       \tcallq  400b30 <__stack_chk_fail@plt>\n  4010ee:\t48 83 c4 20          \tadd    $0x20,%rsp\n  4010f2:\t5b                   \tpop    %rbx\n  4010f3:\tc3                   \tretq   \n```\n\n1. 要求输入6个字符，然后依次循环这个输入的字符数组\n2. 每一轮循环取一个字符，然后取这个字符的后四位作为索引，在第二个字符常量`0x4024b0`处取一个字符依次存放到`%rsp+0x10+i`处\n\n ```bash\n(gdb) print (char*)0x4024b0\n$1 = 0x4024b0 <array> \"maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?\"\n ```\n\n​\t3. 将新`0x10(%rsp)`处的字符串和`0x40245e`处的字符串比较，相同则通过，否则爆炸\n\n```bash\n(gdb) print (char*)0x40245e\n$2 = 0x40245e \"flyers\"\n```\n\n由于低4位只能表示0-15,因此只能从`<array>: maduiersnfotvbyl`取得\n\n`f :array[9] 1001=9`，查找`ASCII`表低位为9的字符:`)9IYiy`\n\n`l :array[15] 1111`=F, `/?O_0`\n`y :array[14] 1110=E ` , `.>N^n~`\n\n`e :array[5] 5`,`%5EUeu`\n\n`r :array[6] 6`, `&6FVfv`\n\n`s :array[7] 7`, `,7GWgw`\n\n答案多种，如**`YONEFw` 、`y?nevw`**\n\n`string_length`代码\n\n```asm\n000000000040131b <string_length>:\n  40131b:\t80 3f 00             \tcmpb   $0x0,(%rdi)\n  40131e:\t74 12                \tje     401332 <string_length+0x17>\n  401320:\t48 89 fa             \tmov    %rdi,%rdx\n  401323:\t48 83 c2 01          \tadd    $0x1,%rdx\n  401327:\t89 d0                \tmov    %edx,%eax\n  401329:\t29 f8                \tsub    %edi,%eax\n  40132b:\t80 3a 00             \tcmpb   $0x0,(%rdx)\n  40132e:\t75 f3                \tjne    401323 <string_length+0x8>\n  401330:\tf3 c3                \trepz retq \n  401332:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  401337:\tc3                   \tretq   \n```\n\n结合`read_line`，应该是获取`rdi`为地址的字符串的长度返回给`eax(rax)`\n\n#### 第六个炸弹\n\n查看`phase_6`代码\n\n```asm\n00000000004010f4 <phase_6>:\n  4010f4:\t41 56                \tpush   %r14\n  4010f6:\t41 55                \tpush   %r13\n  4010f8:\t41 54                \tpush   %r12\n  4010fa:\t55                   \tpush   %rbp\n  4010fb:\t53                   \tpush   %rbx ; 寄存器入栈,将要被本函数调用\n  \n  4010fc:\t48 83 ec 50          \tsub    $0x50,%rsp; 申请80字节的栈帧\n  ;|  phase_6 ret addr  |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    | <- rsp <- r13 <- rsi\n  401100:\t49 89 e5             \tmov    %rsp,%r13\n  401103:\t48 89 e6             \tmov    %rsp,%rsi\n  \n  ;调用读取6数字函数,内部调用了sscanf\n  ;sscanf参数顺序分别是，\n  ;待读取内容的字符串(rdi)、\n  ;用于格式读取的格式化字符串(rsi)，\n  ;还有各个变量读取后存放的地址(rdx)。\n  ; <read_six_numbers>中,%rdx由 %rsi 给出，%rsi 在 phrase6中 又由 %rsp 给出\n  ; 因此输入的数字存到phase_6的%rsp处\n  ;返回读到的有效数据个数\n  401106:\te8 51 03 00 00       \tcallq  40145c <read_six_numbers>\n  ;读入了 6 个数字，分别放入了 %rsp+0x0、%rsp+0x4、%rsp+0x8、%rsp+0xc、%rsp+0x10、%rsp+0x14\n  40110b:\t49 89 e6             \tmov    %rsp,%r14 \n  ; 先将r12(d低32位)置零\n  ; r12 用于计数L4循环\n  40110e:\t41 bc 00 00 00 00    \tmov    $0x0,%r12d\n  ;====================================================================\n  ;L4\n  401114:\t4c 89 ed             \tmov    %r13,%rbp\n  ; 初始情况\n  ;|  phase_6 ret addr  |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|  num6     num5     |\n  ;|  num4     num3     |\n  ;|  num2     num1     | <- rsp r13 r14 rbp rsi\n  \n  ; eax赋值为r13指向的内存数据\n  401117:\t41 8b 45 00          \tmov    0x0(%r13),%eax\n  ; eax=eax-1\n  40111b:\t83 e8 01             \tsub    $0x1,%eax\n  ; 将eax与 5比较\n  40111e:\t83 f8 05             \tcmp    $0x5,%eax\n  ; eax无符号<=5,跳过起爆函数至L1,否则爆炸,即原数据<=6\n  401121:\t76 05                \tjbe    401128 <phase_6+0x34>\n  401123:\te8 12 03 00 00       \tcallq  40143a <explode_bomb>\n  ;L1: %r12d(r12低32位)++\n  401128:\t41 83 c4 01          \tadd    $0x1,%r12d\n  ; 将r12d与6做比较\n  40112c:\t41 83 fc 06          \tcmp    $0x6,%r12d\n  ; r12=6则跳转至L2\n  401130:\t74 21                \tje     401153 <phase_6+0x5f>\n  ; 否则 ebx=r12d \n  401132:\t44 89 e3             \tmov    %r12d,%ebx\n  ;L3: rax= ebx符号扩展4字 假设r12d=i\n  401135:\t48 63 c3             \tmovslq %ebx,%rax\n  ; rax= M[rsp+4*rax]  假设r12d=i , 则rax=num(i)\n  401138:\t8b 04 84             \tmov    (%rsp,%rax,4),%eax\n  ; eax(rax)= num(i+1)与 M[rbp]=M[r13]=num(i)进行比较\n  40113b:\t39 45 00             \tcmp    %eax,0x0(%rbp)\n  ;不相等跳过爆炸函数\n  40113e:\t75 05                \tjne    401145 <phase_6+0x51>\n  ; 相等起爆\n  401140:\te8 f5 02 00 00       \tcallq  40143a <explode_bomb>\n  ; 跳过起爆函数 ebx++\n  401145:\t83 c3 01             \tadd    $0x1,%ebx\n  ; 比较ebx和5\n  401148:\t83 fb 05             \tcmp    $0x5,%ebx\n  ; ebx<=5 跳转回L3,下一个num\n  40114b:\t7e e8                \tjle    401135 <phase_6+0x41>\n  ; ebx>=6, r13+=4\n  40114d:\t49 83 c5 04          \tadd    $0x4,%r13\n  ; 跳回L4,将 r13 rbp等寄存器调整为指向栈中下一个num\n  401151:\teb c1                \tjmp    401114 <phase_6+0x20>\n  ;==================================================================\n  ;上述代码的作用是,确保输入的6个数字均<=6，并且num(i)不和num(i+1)~num(6)相同 \n  ; 1<=i<=5\n  ;==================================================================\n  \n  \n  ;L2: r12=6跳转点;跳出上面的检查循环\n  401153:\t48 8d 74 24 18       \tlea    0x18(%rsp),%rsi\n  401158:\t4c 89 f0             \tmov    %r14,%rax\n  ;|  phase_6 ret addr  |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    |\n  ;|                    | <- rsi\n  ;|  num6     num5     |\n  ;|  num4     num3     |\n  ;|  num2     num1     | <- rsp r14 rax\n  \n  40115b:\tb9 07 00 00 00       \tmov    $0x7,%ecx\n  ;L5: 循环,  num[i]=7-num[i] 6个输入数字全部对7求补\n  401160:\t89 ca                \tmov    %ecx,%edx\n  ; rcx=7, rdx=7\n  401162:\t2b 10                \tsub    (%rax),%edx; edx=7-num(rax point)\n  ; num(rax point)= edx=7-num(rax point) \n  401164:\t89 10                \tmov    %edx,(%rax)\n  ; rax+=4指向下一个num\n  401166:\t48 83 c0 04          \tadd    $0x4,%rax\n  ; 判断 rax指完所有num没有\n  40116a:\t48 39 f0             \tcmp    %rsi,%rax\n  ; 没指完，跳转L5继续指\n  40116d:\t75 f1                \tjne    401160 <phase_6+0x6c>\n  \n  ;================================================================\n  ; esi清零\n  40116f:\tbe 00 00 00 00       \tmov    $0x0,%esi\n  ; 无条件跳转至L6\n  401174:\teb 21                \tjmp    401197 <phase_6+0xa3>\n  ; L7: L6处理完后跳回点\n  401176:\t48 8b 52 08          \tmov    0x8(%rdx),%rdx ; rdx= M[rdx+8]; 而edx赋了个地址,数据大小是8字节\n  40117a:\t83 c0 01             \tadd    $0x1,%eax ; eax+=1\n  40117d:\t39 c8                \tcmp    %ecx,%eax ; 将eax和ecx比较\n  ; eax ecx不相等跳回L7\n  40117f:\t75 f5                \tjne    401176 <phase_6+0x82>\n  ; eax ecx相等跳到L9\n  401181:\teb 05                \tjmp    401188 <phase_6+0x94>\n  ;L8 : L6中ecx<=1跳回点\n  401183:\tba d0 32 60 00       \tmov    $0x6032d0,%edx; 同样也把edx赋地址值0x6032d0\n  ;L9 把rdx存储的数据(即从0x6032d0+OFFSET)处获取的数据存入栈中 M[rsp+0x20++2*rsi]\n  401188:\t48 89 54 74 20       \tmov    %rdx,0x20(%rsp,%rsi,2)\n  40118d:\t48 83 c6 04          \tadd    $0x4,%rsi; rsi+=4\n  401191:\t48 83 fe 18          \tcmp    $0x18,%rsi; 判断rsi是否等于0x18=24,即循环6次了\n  ; 循环6次,栈rsp+0x20+OFFSET存入6个8字节数据了,跳到L10\n  401195:\t74 14                \tje     4011ab <phase_6+0xb7>\n  ;L6\n  ; ecx= M[rsp+rsi] ; 注意40116f把esi清零 ecx=M[rsp+rsi]=num(1...6)\n  401197:\t8b 0c 34             \tmov    (%rsp,%rsi,1),%ecx\n  ; 将ecx(num1)与1比较\n  40119a:\t83 f9 01             \tcmp    $0x1,%ecx\n  ; ecx(num1)有符号<= 1跳回L8\n  40119d:\t7e e4                \tjle    401183 <phase_6+0x8f>\n  ; eax=1\n  40119f:\tb8 01 00 00 00       \tmov    $0x1,%eax\n  ; edx=0x6032d0,是一个地址\n  4011a4:\tba d0 32 60 00       \tmov    $0x6032d0,%edx\n  ; 跳回L7\n  4011a9:\teb cb                \tjmp    401176 <phase_6+0x82>\n  ;================================================================\n  ;作用是访问一个链表，链表的首地址为 0x6032d0，针对输入的第 i 个数，\n  ;按照 num[i] 的值获取链表第 num[i] 个节点，\n  ;并把节点首地址放入 %rsp+0x20+0x0~%rsp+0x20+0x28 刚好是 6 个节点。\n  ;================================================================\n  \n  ;L10:  \n  4011ab:\t48 8b 5c 24 20       \tmov    0x20(%rsp),%rbx\n  4011b0:\t48 8d 44 24 28       \tlea    0x28(%rsp),%rax\n  4011b5:\t48 8d 74 24 50       \tlea    0x50(%rsp),%rsi\n  4011ba:\t48 89 d9             \tmov    %rbx,%rcx\n  4011bd:\t48 8b 10             \tmov    (%rax),%rdx\n  4011c0:\t48 89 51 08          \tmov    %rdx,0x8(%rcx)\n  4011c4:\t48 83 c0 08          \tadd    $0x8,%rax\n  4011c8:\t48 39 f0             \tcmp    %rsi,%rax\n  4011cb:\t74 05                \tje     4011d2 <phase_6+0xde>\n  4011cd:\t48 89 d1             \tmov    %rdx,%rcx\n  4011d0:\teb eb                \tjmp    4011bd <phase_6+0xc9>\n  4011d2:\t48 c7 42 08 00 00 00 \tmovq   $0x0,0x8(%rdx)\n  4011d9:\t00 \n  4011da:\tbd 05 00 00 00       \tmov    $0x5,%ebp\n  \n  ;%rsp+0x20+0x0~ %rsp+0x20+0x28 存储的链表节点地址指向的数值必须是递减的。低地址存的数据要更大\n  ; rax= M[rbx+8]\n  4011df:\t48 8b 43 08          \tmov    0x8(%rbx),%rax\n  ; eax= M[rax]\n  4011e3:\t8b 00                \tmov    (%rax),%eax\n  ; 比较M[rax]=M[rbx+8]和M[rbx], 32位数据\n  4011e5:\t39 03                \tcmp    %eax,(%rbx)\n  ;若不爆炸需要M[rbx]>=M[rbx+8]\n  4011e7:\t7d 05                \tjge    4011ee <phase_6+0xfa>\n  4011e9:\te8 4c 02 00 00       \tcallq  40143a <explode_bomb>\n  4011ee:\t48 8b 5b 08          \tmov    0x8(%rbx),%rbx\n  4011f2:\t83 ed 01             \tsub    $0x1,%ebp\n  4011f5:\t75 e8                \tjne    4011df <phase_6+0xeb>\n  4011f7:\t48 83 c4 50          \tadd    $0x50,%rsp\n  \n  \n  4011fb:\t5b                   \tpop    %rbx\n  4011fc:\t5d                   \tpop    %rbp\n  4011fd:\t41 5c                \tpop    %r12\n  4011ff:\t41 5d                \tpop    %r13\n  401201:\t41 5e                \tpop    %r14\n  401203:\tc3                   \tretq   \n```\n\n用`gdb`查看`0x6032d0`开始的数据,根据`401176`以8字节为单位查看\n\n```bash\n(gdb) x /6gx 0x6032d0\n0x6032d0 <node1>:\t0x00000001 0000014c\t  0x00000000 006032e0\n0x6032e0 <node2>:\t0x00000002 000000a8\t  0x00000000 006032f0\n0x6032f0 <node3>:\t0x00000003 0000039c\t  0x00000000 00603300\n```\n\n访问一个链表，链表的首地址为 `0x6032d0`，针对输入的第 `i` 个数，按照 `a[i]` 的值获取链表第 `a[i]` 个节点，并把节点首地址放入 `%rsp+0x20+0x0`~ 到 `%rsp+0x20+0x28` 刚好是 6 个节点。\n\n| 地址     | 数据       |\n| -------- | ---------- |\n| 0x6032d0 | 0x0000014c |\n| 0x6032d4 | 0x00000001 |\n| 0x6032d8 | 0x006032e0 |\n| 0x6032dc | 0x00000000 |\n| 0x6032e0 | 0x000000a8 |\n| 0x6032e4 | 0x00000002 |\n| 0x6032e8 | 0x006032f0 |\n| 0x6032ec | 0x00000000 |\n| 0x6032f0 | 0x0000039c |\n\n```bash\n(gdb) x /wx 0x6032d0\n0x6032d0 <node1>:\t0x0000014c # 链表结点1 data的低32位,由于输入的数据是int 32位，可以先不看高32位data 5\n(gdb) x /wx 0x6032d0+8\n0x6032d8 <node1+8>:\t0x006032e0 # 结点1存储的结点2的地址\n\n(gdb) x /wx 0x6032e0\n0x6032e0 <node2>:\t0x000000a8 # data 6\n(gdb) x /wx 0x6032e0+8\n0x6032e8 <node2+8>:\t0x006032f0 # addr\n\n(gdb) x /wx 0x6032f0\n0x6032f0 <node3>:\t0x0000039c # data 1\n(gdb) x /wx 0x6032f0+8\n0x6032f8 <node3+8>:\t0x00603300 # addr\n\n(gdb) x /wx 0x603300\n0x603300 <node4>:\t0x000002b3 #data 2\n(gdb) x /wx 0x603300+8\n0x603308 <node4+8>:\t0x00603310 # addr\n\n(gdb) x /wx 0x603310\n0x603310 <node5>:\t0x000001dd #data 3\n(gdb) x /wx 0x603310+8\n0x603318 <node5+8>:\t0x00603320 # addr\n\n(gdb) x /wx 0x603320\n0x603320 <node6>:\t0x000001bb #data 4\n(gdb) x /wx 0x603320+8\n0x603328 <node6+8>:\t0x00000000\n```\n\n一共6个结点，第一个结点地址数据存在`%rsp+0x20+0x0`处，这个地址数据指向的结点data应该最大，由于比较`cmp`的是32位数据，只需要注意地址指向数据的低32位。\n\n最大的数据是`0x0000039c`，是第3个结点， 此时的num1=3，\n\n第2大的数据是`0x000002b3` ，第4个结点 num2=4\n\n第3大的数据是`0x000001dd` ，第5个结点 num3=5\n\n第4大的数据是`0x000001bb` ，第6个结点 num4=6\n\n第5大的数据是`0x0000014c` ，第1个结点 num5=1\n\n第6大的数据是`0x000000a8` ，第2个结点 num3=2\n\n`num=[3,4,5,6,1,2]`\n\n但是注意这是把输入的`num`进行了`num=7-num`\n\n所以输入是\n\n`num=[4,3,2,1,6,5]`\n\n最终答案是**4 3 2 1 6 5 **","tags":["计算机组成原理"]}]